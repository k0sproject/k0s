{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#k0s-the-zero-friction-kubernetes","title":"k0s - The Zero Friction Kubernetes","text":""},{"location":"#overview","title":"Overview","text":"<p>k0s is an open source, all-inclusive Kubernetes distribution, which is configured with all of the features needed to build a Kubernetes cluster and packaged as a single binary for ease of use. Due to its simple design, flexible deployment options and modest system requirements, k0s is well suited for</p> <ul> <li>Any cloud</li> <li>Bare metal</li> <li>Edge and IoT</li> </ul> <p>k0s drastically reduces the complexity of installing and running a CNCF certified Kubernetes distribution. With k0s new clusters can be bootstrapped in minutes and developer friction is reduced to zero. This allows anyone with no special skills or expertise in Kubernetes to easily get started.</p> <p>k0s is distributed as a single binary with zero host OS dependencies besides the host OS kernel. It works with any Linux without additional software packages or configuration. Any security vulnerabilities or performance issues can be fixed directly in the k0s distribution that makes it extremely straightforward to keep the clusters up-to-date and secure.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Certified and 100% upstream Kubernetes</li> <li>Multiple installation methods: single-node, multi-node, airgap and Docker</li> <li>Automatic lifecycle management with k0sctl: upgrade, backup and restore</li> <li>Modest system requirements (1 vCPU, 1 GB RAM)</li> <li>Available as a single binary with no external runtime dependencies besides the kernel</li> <li>Flexible deployment options with control plane isolation as default</li> <li>Scalable from a single node to large, high-available clusters</li> <li>Supports custom Container Network Interface (CNI) plugins (Kube-Router is the default, Calico is offered as a preconfigured alternative)</li> <li>Supports custom Container Runtime Interface (CRI) plugins (containerd is the default)</li> <li>Supports all Kubernetes storage options with Container Storage Interface (CSI)</li> <li>Supports a variety of datastore backends: etcd (default for multi-node clusters), SQLite (default for single node clusters), MySQL, and PostgreSQL</li> <li>Supports x86-64, ARM64 and ARMv7</li> <li>Includes Konnectivity service, CoreDNS and Metrics Server</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start Guide for creating a full Kubernetes cluster with a single node.</li> <li>Install using k0sctl - Deploy and upgrade multi-node clusters with one command.</li> <li>Run k0s in Docker - Run k0s controllers and workers in containers.</li> </ul>"},{"location":"#demo","title":"Demo","text":""},{"location":"#join-the-community","title":"Join the Community","text":"<ul> <li>k8s Slack - Reach out for support and help from the k0s community.</li> <li>GitHub Issues - Submit your issues and feature requests via GitHub.</li> </ul> <p>We welcome your help in building k0s! If you are interested, we invite you to check out the Contributing Guide and the Code of Conduct.</p>"},{"location":"#community-hours","title":"Community hours","text":"<p>We will be holding regular community hours. Everyone in the community is welcome to drop by and ask questions, talk about projects, and chat.</p> <p>We currently have a monthly office hours call on the last Tuesday of the month.</p> <p>To see the call details in your local timezone, check out https://dateful.com/eventlink/2735919704.</p>"},{"location":"#adopters","title":"Adopters","text":"<p>k0s is used across diverse environments, from small-scale far-edge deployments to large data centers. Share your use case and add yourself to the list of adopters.</p>"},{"location":"#commercial-support","title":"Commercial Support","text":"<p>Mirantis offers technical support, professional services and training for k0s. The support subscriptions include, for example, prioritized support (Phone, Web, Email) and access to verified extensions on top of your k0s cluster.</p> <p>For any k0s inquiries, please contact us via email info@k0sproject.io.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>We have seen a gap between the host OS and Kubernetes that runs on top of it: How to ensure they work together as they are upgraded independent from each other? Who is responsible for vulnerabilities or performance issues originating from the host OS that affect the K8S on top?</p> <p>\u2192 k0s is fully self contained. It\u2019s distributed as a single binary with no host OS deps besides the kernel. Any vulnerability or perf issues may be fixed in k0s Kubernetes.</p> <p>We have seen K8S with partial FIPS security compliance: How to ensure security compliance for critical applications if only part of the system is FIPS compliant?</p> <p>\u2192 k0s core + all included host OS dependencies + components on top may be compiled and packaged as a 100% FIPS compliant distribution using a proper toolchain.</p> <p>We have seen Kubernetes with cumbersome lifecycle management, high minimum system requirements, weird host OS and infra restrictions, and/or need to use different distros to meet different use cases.</p> <p>\u2192 k0s is designed to be lightweight at its core. It comes with a tool to automate cluster lifecycle management. It works on any host OS and infrastructure, and may be extended to work with any use cases such as edge, IoT, telco, public clouds, private data centers, and hybrid &amp; hyper converged cloud applications without sacrificing the pure Kubernetes compliance or amazing developer experience.</p>"},{"location":"#scope","title":"Scope","text":"<p>While some Kubernetes distros package everything and the kitchen sink, k0s tries to minimize the amount of \"add-ons\" to bundle in. Instead, we aim to provide a robust and versatile \"base\" for running Kubernetes in various setups. Of course we will provide some ways to easily control and setup various \"add-ons\", but we will not bundle many of those into k0s itself. There are a couple of reasons why we think this is the correct way:</p> <ul> <li>Many of the addons such as ingresses, service meshes, storage etc. are VERY opinionated. We try to build this base with fewer opinions. :D</li> <li>Keeping up with the upstream releases with many external addons is very maintenance heavy. Shipping with old versions does not make much sense either.</li> </ul> <p>With strong enough arguments we might take in new addons, but in general those should be something that are essential for the \"core\" of k0s.</p>"},{"location":"adopters/","title":"Adopters","text":""},{"location":"adopters/#adopters-of-k0s","title":"Adopters of k0s","text":"<p>This page lists, in alphabetical order, individuals and organizations that are using k0s in production. If you would like to add your use case for k0s to the list, we'd be more than happy to see a pull request.</p>"},{"location":"adopters/#adopters","title":"Adopters","text":"<ul> <li>AudioCodes   Project: Underlying support for AudioCodes VoI/VoiceAI   AudioCodes uses it for VoIP/VoiceAI (see page 17).</li> </ul> <ul> <li>DeepSquare   Project: HPCaaS   DeepSquare embeds it into their HPCaaS service.</li> </ul> <ul> <li>k0smotron   Project: Managing hosted k0s clusters and full Cluster API provider for k0s   K0smotron focuses on managing hosted k0s clusters within an existing   Kubernetes cluster. It acts as a Cluster API provider, enabling seamless   provisioning, scaling, and lifecycle management of k0s control planes. By   leveraging the native capabilities of Kubernetes, k0smotron simplifies   multi-cluster operations and provides flexibility in connecting worker nodes   from different infrastructures.</li> </ul> <ul> <li>@k0sproject   Project: k0s build and CI infrastructure   k0s maintainers use k0s to host build and CI infrastructure, mainly dynamic   GitHub Runners.</li> </ul> <ul> <li>KubeArmor   Project: Supported in their security product</li> </ul> <ul> <li>Mirantis   Project: k0s support   Mirantis provides support for various customers utilizing k0s in their   production environments and k0s is included in a number of Mirantis products   such as MKE.</li> </ul> <ul> <li>National Astronomical Observatory for Japan   Project: Providing compute nodes in telemetry HPC cluster   Used for deploying and managing   NVIDIA GPUs for data analysis.</li> </ul> <ul> <li>Progress Chef 360   Project: Embedded Clusters for Chef 360 Using it for embedded Kubernetes clusters.</li> </ul> <ul> <li>Replicated, Inc.   Project: Embedded Cluster   Contact: Chris Sanders   Replicated builds their Embedded Cluster project on top   of k0s. Replicated Embedded Cluster allows you to distribute a Kubernetes   cluster and your application together as a single appliance, making it easy   for enterprise users to install, update, and manage the application and the   cluster in tandem.</li> </ul> <ul> <li>Splunk   Project: Data Stream Processor   Used in their Data Stream Processor.</li> </ul> <ul> <li>vCluster   Project: Virtual Clusters   vCluster supports both k0s and k3s for their virtual kubernetes nested clusters.</li> </ul>"},{"location":"adopters/#additional-use-cases","title":"Additional use cases","text":"<p>In addition, it is being used for novel use cases in the wild:</p> <ul> <li>Kubernetes vs Philippine Power Outages - On setting up k0s over Tailscale</li> <li>New England Research Cloud provides it as an option vs k3s.</li> <li>Amaze Systems job posting includes requirement for k0s experience.</li> <li>k0s with Traefik for a Tokyo smart cities project.</li> </ul>"},{"location":"airgap-install/","title":"Airgapped Installation","text":""},{"location":"airgap-install/#air-gapped-installation","title":"Air gapped Installation","text":"<p>You can install k0s in environments without Internet access. Air gapped installations require an image bundle that contains all the container images that would normally be pulled over the network. K0s uses so-called OCI archives for this: Tarball representations of an OCI Image Layout. They allow for multiple images to be packed into a single file. K0s will watch for image bundles in the <code>&lt;data-dir&gt;/images</code> folder will automatically import them into the container runtime.</p> <p>There are several ways to obtain an image bundle:</p> <ul> <li>Use the pre-built image bundles for different target platforms that are   created for each k0s release. They contain all the images for the default k0s   image configuration and can be downloaded from   the GitHub releases page.</li> <li>Create your own image bundle. In this case, you can easily customize the   bundle to include container images that are not used by default in k0s.</li> </ul> <p>Note: When importing image bundles, k0s uses \"loose\" platform matching. For example, on arm/v8, k0s will also import arm/v7, arm/v6, and arm/v5 images. This means that your bundle can contain multi-arch images, and the import will be done using platform compatibility.</p>"},{"location":"airgap-install/#creating-image-bundles","title":"Creating image bundles","text":""},{"location":"airgap-install/#using-k0s-built-in-tooling","title":"Using k0s built-in tooling","text":"<p>k0s ships with the <code>k0s airgap</code> sub-command, which is dedicated for tooling for airgapped environments. It allows for listing the required images for a given configuration, as well as bundling them into an OCI Image Layout archive.</p> <ol> <li> <p>Create the list of images required by k0s.</p> <pre><code>k0s airgap list-images --all &gt;airgap-images.txt\n</code></pre> </li> <li> <p>Review this list and edit it according to your needs.</p> </li> <li> <p>Create the image bundle.</p> <pre><code>k0s airgap bundle-artifacts -v -o image-bundle.tar &lt;airgap-images.txt\n</code></pre> </li> </ol>"},{"location":"airgap-install/#from-a-running-worker-node","title":"From a running worker node","text":"<p>As containerd pulls all the images during the k0s worker normal bootstrap, you can use it to build the OCI bundle with images.</p> <p>Use the following commands on a machine with an installed k0s worker:</p> <pre><code>k0s ctr images export image-bundle.tar $(k0s airgap list-images | xargs)\n</code></pre>"},{"location":"airgap-install/#using-third-party-tools","title":"Using third-party tools","text":"<p>There are several CLI tools that can help you fetch OCI artifacts and manage OCI Image Layouts, such as skopeo, oras, or crane. The following is an example uses Docker:</p>"},{"location":"airgap-install/#docker","title":"Docker","text":"<ol> <li> <p>Create the list of images required by k0s.</p> <pre><code>k0s airgap list-images --all &gt;airgap-images.txt\n</code></pre> </li> <li> <p>Review this list and edit it according to your needs.</p> </li> <li> <p>Pull the images.</p> <pre><code>xargs -I{} docker pull {} &lt;airgap-images.txt\n</code></pre> </li> <li> <p>Create the bundle.</p> <pre><code>docker image save -o image-bundle.tar $(xargs &lt;airgap-images.txt)\n</code></pre> </li> </ol>"},{"location":"airgap-install/#placing-image-bundles-on-worker-nodes","title":"Placing image bundles on worker nodes","text":""},{"location":"airgap-install/#by-hand","title":"By hand","text":"<p>Copy the <code>image-bundle.tar</code> to the target machine into the <code>images</code> directory in the k0s data directory. Copy the bundle only to the worker nodes. Controller nodes don't use it.</p> <pre><code># mkdir -p /var/lib/k0s/images\n# cp image-bundle.tar /var/lib/k0s/images/image-bundle.tar\n</code></pre>"},{"location":"airgap-install/#via-k0sctl","title":"Via k0sctl","text":"<p>As an alternative to the previous step, you can use <code>k0sctl</code> to upload image bundles to worker nodes. <code>k0sctl</code> can also be used to upload the k0s binary file to all nodes. Take a look at this example configuration with one controller and one worker node to upload k0s binary and an image bundle:</p> <pre><code>apiVersion: k0sctl.k0sproject.io/v1beta1\nkind: ClusterConfig\nmetadata:\n  name: k0s\nspec:\n  k0s:\n    version: v1.34.1+head\n  hosts:\n    - role: controller\n      ssh:\n        address: &lt;controller-ip-address&gt;\n        user: ubuntu\n        keyPath: /path/to/.ssh/id_rsa\n\n      #  uploadBinary: &lt;boolean&gt;\n      #    When true the k0s binaries are cached and uploaded\n      #    from the host running k0sctl instead of downloading\n      #    directly to the target host.\n      uploadBinary: true\n\n      #  k0sBinaryPath: &lt;local filepath&gt;\n      #    Upload a custom or manually downloaded k0s binary\n      #    from a local path on the host running k0sctl to the\n      #    target host.\n      # k0sBinaryPath: path/to/k0s_binary/k0s\n\n    - role: worker\n      ssh:\n        address: &lt;worker-ip-address&gt;\n        user: ubuntu\n        keyPath: /path/to/.ssh/id_rsa\n      uploadBinary: true\n      files:\n        # This airgap bundle file will be uploaded from the k0sctl\n        # host to the specified directory on the target host\n        - src: /path/to/airgap-bundle-amd64.tar\n          dstDir: /var/lib/k0s/images\n          perm: 0755\n</code></pre>"},{"location":"airgap-install/#disable-image-pulling-optional","title":"Disable image pulling (optional)","text":"<p>Use the following k0s configuration to ensure that all pods and pod templates managed by k0s contain an <code>imagePullPolicy</code> of <code>Never</code>, ensuring that no images are pulled from the Internet at any time.</p> <pre><code>apiVersion: k0s.k0sproject.io/v1beta1\nkind: ClusterConfig\nmetadata:\n  name: k0s\nspec:\n  images:\n    default_pull_policy: Never\n</code></pre>"},{"location":"autopilot-multicommand/","title":"Multi-Command Plans","text":""},{"location":"autopilot-multicommand/#multi-command-plans","title":"Multi-Command Plans","text":"<p>Autopilot relies on a Plan for defining the Commands that should be executed, the Signal Nodes that each should be run on, and the status of each Command.</p> <p>A Plan:</p> <ul> <li>Defines one or many Commands that specify what actions should be performed.</li> <li>Specifies how Signal Nodes should be discovered per-Command.</li> <li>Saves the status of the Plan execution by resolved Signal Nodes</li> </ul> <p>A Command:</p> <ul> <li>An instructional step inside of a Plan that is applied against a Signal Node</li> </ul> <p>A Signal Node:</p> <ul> <li>Any node (controller or worker) that can receive updates with Autopilot.</li> </ul>"},{"location":"autopilot-multicommand/#execution","title":"Execution","text":"<p>The execution of a Plan is the result of processing Commands through a number of Processing States.</p> <p>When a Plan is executed, each of the Commands are executed in the order of their appearance in the Plan.</p> <ul> <li>A Plan transitions to the next Command only when the current Command posts a state of Completed.</li> <li>Any Command that posts one of the recognized Error States will result in the current Command and Plan to abort processing.<ul> <li>The status of the Command and Plan will reflect this.</li> </ul> </li> <li>A Plan is considered finished only when all of its defined Commands post a Completed state.</li> </ul>"},{"location":"autopilot-multicommand/#status","title":"Status","text":"<p>The progress and state of each Command is recorded in the Plan status.</p> <ul> <li>Every Command in the Plan has an associated status entry with the same index as the Command<ul> <li>i.e. The second Command in a Plan has an index of <code>1</code>, and so does its status.</li> </ul> </li> <li>The status of all Commands is taken into consideration when determining if the Plan is finished.</li> </ul>"},{"location":"autopilot-multicommand/#example","title":"Example","text":"<p>The following is an example of a Plan that has been applied as is currently being processed by autopilot.</p> <p>(line numbers added for commentary below)</p> <pre><code> 1:  apiVersion: autopilot.k0sproject.io/v1beta2\n 2:  kind: Plan\n 3:  metadata:\n 4:    annotations:\n 5:      &lt;omitted&gt;\n 6:  spec:\n 7:    commands:\n 8:    - airgapupdate:\n 9:        version: v1.34.1+head\n10:        platforms:\n11:          linux-amd64:\n12:            url: https://github.com/k0sproject/k0s/releases/download/v1.34.1+head/k0s-airgap-bundle-v1.34.1+head-amd64\n13:        workers:\n14:          discovery:\n15:            static:\n16:              nodes:\n17:              - worker0\n18:    - k0supdate:\n19:        version: v1.34.1+head\n20:        platforms:\n21:          linux-amd64:\n22:            url: https://github.com/k0sproject/k0s/releases/download/v1.34.1+head/k0s-v1.34.1+head-amd64\n23:        targets:\n24:          controllers:\n25:            discovery:\n26:              static:\n27:                nodes:\n28:                - controller0\n29:          workers:\n30:            discovery:\n31:              static:\n32:                nodes:\n33:                - worker0\n34:    id: id123\n35:    timestamp: now\n36:  status:\n37:    commands:\n38:    - airgapupdate:\n39:        workers:\n40:        - lastUpdatedTimestamp: \"2022-05-11T19:13:02Z\"\n41:          name: worker0\n42:          state: SignalSent\n43:      id: 0\n44:      state: SchedulableWait\n45:    - id: 1\n46:      k0supdate:\n47:        controllers:\n48:        - lastUpdatedTimestamp: \"2022-05-11T19:13:02Z\"\n49:          name: controller0\n50:          state: SignalPending\n51:        workers:\n52:        - lastUpdatedTimestamp: \"2022-05-11T19:13:02Z\"\n53:          name: worker0\n54:          state: SignalPending\n55:      state: SchedulableWait\n56:    state: SchedulableWait\n</code></pre> <ul> <li>Lines 7-33 are the two Commands that make up this plan - an <code>airgapupdate</code> and <code>k0supdate</code>.</li> <li>Lines 38-55 are the associated status entries for the two Commands.</li> </ul> <p>The state of this Plan excerpt is that autopilot has successfully processed the Plan, and has begun processing the <code>airgapupdate</code> Command. Its status indicates SignalSent which means that the Signal Node has been sent signaling information to perform an air gapped update.</p>"},{"location":"autopilot-multicommand/#processing-states","title":"Processing States","text":"<p>The following are the various states that both <code>Plan</code>s and <code>Command</code>s adhere to.</p> <pre><code>stateDiagram-v2\n    [*]--&gt;NewPlan\n    NewPlan--&gt;SchedulableWait\n    NewPlan--&gt;Errors***\n\n    SchedulableWait--&gt;Schedulable\n    SchedulableWait--&gt;Completed\n    Schedulable--&gt;SchedulableWait\n\n    Errors***--&gt;[*]\n    Completed--&gt;[*]</code></pre> <p>Note that the Errors state is elaborated in detail below in Error States*.</p>"},{"location":"autopilot-multicommand/#newplan","title":"NewPlan","text":"<p>When a Plan is created with the name <code>autopilot</code>, the NewPlan state processing takes effect.</p> <p>It is the responsibility of NewPlan to ensure that the status of all the Commands are represented in the Plan status. This Plan status is needed at later points in Plan processing to determine if the entire Plan is completed.</p> <p>The main difference between NewPlan and all the other states is that NewPlan will iterate over all commands; the other states deal with the active command.</p>"},{"location":"autopilot-multicommand/#schedulablewait","title":"SchedulableWait","text":"<p>Used to evaluate a Command to determine if it can be scheduled for processing. If the Command is determined that it can be processed, the state is set to Schedulable.</p>"},{"location":"autopilot-multicommand/#schedulable","title":"Schedulable","text":"<p>The Schedulable state is set by SchedulableWait to indicate that this command should execute. The execution of a Command in this state will be whichever logic is defined by the Command.</p> <p>The ending of this state should either transition to SchedulableWait for further processing + completion detection, or transition to an error.</p>"},{"location":"autopilot-multicommand/#completed","title":"Completed","text":"<p>The Completed state indicates that the command has finished processing. Once a plan/command are in the Completed state, no further processing will occur on this plan/command.</p>"},{"location":"autopilot-multicommand/#error-states","title":"Error States","text":"<p>When a plan or command processing goes into one of the designated error states, this is considered fatal and the plan/command processing will terminate.</p> <p>Error states are generally defined by the Command implementation. The core autopilot functionality is only interested when in the 4 core states (NewPlan, SchedulableWait, Schedulable, Completed), and treats all other states as an error.</p> <pre><code>flowchart TD\n    Errors --&gt; InconsistentTargets\n    Errors --&gt; IncompleteTargets\n    Errors --&gt; Restricted\n    Errors --&gt; MissingPlatform\n    Errors --&gt; MissingSignalNode</code></pre> Error State Command States Description InconsistentTargets <code>k0supdate</code> Schedulable Indicates that a Signal Node probe has failed for any node that was previously discovered during NewPlan. IncompleteTargets <code>airgapupdate</code>, <code>k0supdate</code> NewPlan, Schedulable Indicates that a Signal Node that existed during the discover phase in NewPlan no longer exists (ie. no <code>ControlNode</code> or <code>Node</code> object) Restricted <code>airgapupdate</code>, <code>k0supdate</code> NewPlan Indicates that a Plan has requested an update of a Signal Node type that contradicts the startup exclusions (the <code>--exclude-from-plans</code> argument) MissingSignalNode <code>airgapupdate</code>, <code>k0supdate</code> Schedulable Indicates that a Signal Node that existed during the discover phase in NewPlan no longer exists (i.e. no matching <code>ControlNode</code> or <code>Node</code> object)"},{"location":"autopilot-multicommand/#sequence-example","title":"Sequence: Example","text":"<p>Using the example above as a reference, this outlines the basic sequence of events of state transitions to the operations performed on each object.</p> <pre><code>sequenceDiagram\n  PlanStateHandler-&gt;&gt;+AirgapUpdateCommand: State: NewPlan\n  AirgapUpdateCommand-&gt;&gt;-AirgapUpdateCommand: cmd.NewPlan() -- &gt;SchedulableWait\n  PlanStateHandler-&gt;&gt;+K0sUpdateCommand: State: NewPlan\n  K0sUpdateCommand-&gt;&gt;-K0sUpdateCommand: cmd.NewPlan() --&gt; SchedulableWait\n  Note over PlanStateHandler,SignalNode(worker0): NewPlan Finished / All Commands\n\n  PlanStateHandler-&gt;&gt;+AirgapUpdateCommand: State: SchedulableWait\n  AirgapUpdateCommand-&gt;&gt;-AirgapUpdateCommand: cmd.SchedulableWait() --&gt; Schedulable\n  PlanStateHandler-&gt;&gt;+AirgapUpdateCommand: State: Schedulable\n  AirgapUpdateCommand-&gt;&gt;-SignalNode(worker0): signal_v2(airgap-data) --&gt; SchedulableWait\n  PlanStateHandler-&gt;&gt;+AirgapUpdateCommand: State: SchedulableWait\n  AirgapUpdateCommand-&gt;&gt;-AirgapUpdateCommand: cmd.SchedulableWait() --&gt; Completed\n  Note over PlanStateHandler,SignalNode(worker0): AirgapUpdate Finished / worker0\n\n  PlanStateHandler-&gt;&gt;+K0sUpdateCommand: State: SchedulableWait\n  K0sUpdateCommand-&gt;&gt;-K0sUpdateCommand: cmd.SchedulableWait() --&gt; Schedulable\n  PlanStateHandler-&gt;&gt;+K0sUpdateCommand: State: Schedulable\n  K0sUpdateCommand-&gt;&gt;-SignalNode(controller0): signal_v2(k0s-data) --&gt; SchedulableWait\n  PlanStateHandler-&gt;&gt;+K0sUpdateCommand: State: SchedulableWait\n  K0sUpdateCommand-&gt;&gt;-K0sUpdateCommand: cmd.SchedulableWait() --&gt; Completed\n  Note over PlanStateHandler,SignalNode(controller0): K0sUpdate Finished / controller0\n\n  PlanStateHandler-&gt;&gt;+K0sUpdateCommand: State: SchedulableWait\n  K0sUpdateCommand-&gt;&gt;-K0sUpdateCommand: cmd.SchedulableWait() --&gt; Schedulable\n  PlanStateHandler-&gt;&gt;+K0sUpdateCommand: State: Schedulable\n  K0sUpdateCommand-&gt;&gt;-SignalNode(worker0): signal_v2(k0s-data) --&gt; SchedulableWait\n  PlanStateHandler-&gt;&gt;+K0sUpdateCommand: State: SchedulableWait\n  K0sUpdateCommand-&gt;&gt;-K0sUpdateCommand: cmd.SchedulableWait() --&gt; Completed\n  Note over PlanStateHandler,SignalNode(worker0): K0sUpdate Finished / worker0\n\n  PlanStateHandler-&gt;&gt;PlanStateHandler: Completed</code></pre>"},{"location":"autopilot/","title":"Overview","text":""},{"location":"autopilot/#autopilot","title":"Autopilot","text":"<p>A tool for updating your <code>k0s</code> controller and worker nodes using specialized plans. There is a public update-server hosted on the same domain as the documentation site. See the example below on how to use it. There is only a single channel <code>edge_release</code> available. The channel exposes the latest released version.</p>"},{"location":"autopilot/#how-it-works","title":"How it works","text":"<ul> <li>You create a <code>Plan</code> YAML<ul> <li>Defining the update payload (new version of <code>k0s</code>, URLs for platforms, etc.)</li> <li>Add definitions for all the nodes that should receive the update.<ul> <li>Either statically, or dynamically using label/field selectors</li> </ul> </li> </ul> </li> <li>Apply the <code>Plan</code><ul> <li>Applying a <code>Plan</code> is a simple <code>kubectl apply</code> operation.</li> </ul> </li> <li>Monitor the progress<ul> <li>The applied <code>Plan</code> provides a status that details the progress.</li> </ul> </li> </ul>"},{"location":"autopilot/#automatic-updates","title":"Automatic updates","text":"<p>To enable automatic updates, create an <code>UpdateConfig</code> object:</p> <pre><code>apiVersion: autopilot.k0sproject.io/v1beta2\nkind: UpdateConfig\nmetadata:\n  name: example\n  namespace: default\nspec:\n  channel: edge_release\n  updateServer: https://updates.k0sproject.io/\n  upgradeStrategy:\n    type: periodic\n    periodic:\n      # The following fields configures updates to happen only on Tue or Wed at 13:00-15:00\n      days: [Tuesdays,Wednesday]\n      startTime: \"13:00\"\n      length: 2h\n  planSpec: # This defines the plan to be created IF there are updates available\n    ...\n</code></pre>"},{"location":"autopilot/#safeguards","title":"Safeguards","text":"<p>There are a number of safeguards in place to avoid breaking a cluster.</p>"},{"location":"autopilot/#stateless-component","title":"Stateless Component","text":"<ul> <li>The autopilot component were designed to not require any heavy state, or massive synchronization. Controllers can disappear, and backup controllers can resume the autopilot operations.</li> </ul>"},{"location":"autopilot/#workers-update-only-after-controllers","title":"Workers Update Only After Controllers","text":"<ul> <li>The versioning that Kubelet and the Kubernetes API server adhere to requires that Kubelets should not be of a newer version than the API server.</li> </ul> <ul> <li>How autopilot handles this is that when a <code>Plan</code> is applied that has both controller and worker nodes, all the controller nodes will be updated first. It is only when all controllers have updated successfully that worker nodes will receive their update instructions.</li> </ul>"},{"location":"autopilot/#plans-are-immutable","title":"Plans are Immutable","text":"<ul> <li>When you apply a <code>Plan</code>, autopilot evaluates all of the controllers and workers that should be included into the <code>Plan</code>, and tracks them in the status. After this point, no additional changes to the plan (other than status) will be recognized.<ul> <li>This helps in largely dynamic worker node environments where nodes that may have been   matched by the <code>selector</code> discovery method no longer exist by the time the update   is ready to be scheduled.</li> </ul> </li> </ul>"},{"location":"autopilot/#controller-quorum-safety","title":"Controller Quorum Safety","text":"<ul> <li>Prior to scheduling a controller update, autopilot queries the API server of all   controllers to ensure that they report a successful <code>/ready</code></li> <li>Only once all controllers are <code>/ready</code> will the current controller get sent update signaling.</li> <li>In the event that any controller reports a non-ready, the <code>Plan</code> transitions into an   <code>InconsistentTargets</code> state, and the <code>Plan</code> execution ends.</li> </ul>"},{"location":"autopilot/#controllers-update-sequentially","title":"Controllers Update Sequentially","text":"<ul> <li>Despite having the configuration options for controllers to set concurrency, only one   controller will be updated at a time.</li> </ul>"},{"location":"autopilot/#update-payload-verification","title":"Update Payload Verification","text":"<ul> <li>Each <code>update</code> object payload can provide an optional <code>sha256</code> hash of the update content   (specified in <code>url</code>), which is compared against the update content after it downloads.</li> </ul>"},{"location":"autopilot/#configuration","title":"Configuration","text":"<p>Autopilot relies on a <code>Plan</code> object on its instructions on what to update.</p> <p>Here is an arbitrary Autopilot plan:</p> <pre><code>apiVersion: autopilot.k0sproject.io/v1beta2\nkind: Plan\nmetadata:\n  name: autopilot\n\nspec:\n  id: id1234\n  timestamp: now\n\n  commands:\n    - k0supdate:\n        version: v1.34.1+head\n        platforms:\n          linux-amd64:\n            url: https://github.com/k0sproject/k0s/releases/download/v1.34.1+head/k0s-v1.34.1+head-amd64\n            sha256: '0000000000000000000000000000000000000000000000000000000000000000'\n        targets:\n          controllers:\n            discovery:\n              static:\n                nodes:\n                  - ip-172-31-44-131\n                  - ip-172-31-42-134\n                  - ip-172-31-39-65\n          workers:\n            limits:\n              concurrent: 5\n            discovery:\n              selector:\n                labels: environment=staging\n                fields: metadata.name=worker2\n</code></pre>"},{"location":"autopilot/#core-fields","title":"Core Fields","text":""},{"location":"autopilot/#apiversion-string-required","title":"<code>apiVersion &lt;string&gt; (required)</code>","text":"<ul> <li>The current version of the Autopilot API is <code>v1beta2</code>, with a full group-version of <code>autopilot.k0sproject.io/v1beta2</code></li> </ul>"},{"location":"autopilot/#metadataname-string-required","title":"<code>metadata.name &lt;string&gt; (required)</code>","text":"<ul> <li>The name of the plan should always be <code>autopilot</code><ul> <li>Note: Plans will not execute if they don't follow this convention.</li> </ul> </li> </ul>"},{"location":"autopilot/#spec-fields","title":"Spec Fields","text":""},{"location":"autopilot/#specid-string-optional","title":"<code>spec.id &lt;string&gt; (optional)</code>","text":"<ul> <li>An identifier that can be provided by the creator for informational and tracking purposes.</li> </ul>"},{"location":"autopilot/#spectimestamp-string-optional","title":"<code>spec.timestamp &lt;string&gt; (optional)</code>","text":"<ul> <li>A timestamp value that can be provided by the creator for informational purposes. Autopilot does nothing with this information.</li> </ul>"},{"location":"autopilot/#speccommands-required","title":"<code>spec.commands[] (required)</code>","text":"<ul> <li>The <code>commands</code> contains the commands that should be performed as a part of the plan.</li> </ul>"},{"location":"autopilot/#k0supdate-command","title":"<code>k0supdate</code> Command","text":""},{"location":"autopilot/#speccommandsk0supdateversion-string-required","title":"<code>spec.commands[].k0supdate.version &lt;string&gt; (required)</code>","text":"<ul> <li>The version of the binary being updated. This version is used to compare against the installed version before and after update to ensure success.</li> </ul>"},{"location":"autopilot/#speccommandsk0supdateplatformsurl-string-required","title":"<code>spec.commands[].k0supdate.platforms.*.url &lt;string&gt; (required)</code>","text":"<ul> <li>A URL providing where the updated binary should be downloaded from, for this specific platform.<ul> <li>The naming of platforms is a combination of <code>$GOOS</code> and <code>$GOARCH</code>, separated by a hyphen (<code>-</code>)<ul> <li>e.g.: <code>linux-amd64</code>, <code>linux-arm64</code>, <code>linux-arm</code></li> </ul> </li> <li>Note: The main supported platform is <code>linux</code>. Autopilot may work on other platforms, however this has not been tested.</li> </ul> </li> </ul>"},{"location":"autopilot/#speccommandsk0supdateplatformssha256-string-optional","title":"<code>spec.commands[].k0supdate.platforms.*.sha256 &lt;string&gt; (optional)</code>","text":"<ul> <li>If a SHA256 hash is provided for the binary, the completed downloaded will be verified against it.</li> </ul>"},{"location":"autopilot/#speccommandsk0supdatetargetscontrollers-object-optional","title":"<code>spec.commands[].k0supdate.targets.controllers &lt;object&gt; (optional)</code>","text":"<ul> <li>This object provides the details of how <code>controllers</code> should be updated.</li> </ul>"},{"location":"autopilot/#speccommandsk0supdatetargetscontrollerslimitsconcurrent-int-fixed-as-1","title":"<code>spec.commands[].k0supdate.targets.controllers.limits.concurrent &lt;int&gt; (fixed as 1)</code>","text":"<ul> <li>The configuration allows for specifying the number of concurrent controller updates through the plan spec, however for controller targets this is fixed always to <code>1</code>.</li> <li>By ensuring that only one controller updates at a time, we aim to avoid scenarios where quorom may be disrupted.</li> </ul>"},{"location":"autopilot/#speccommandsk0supdatetargetsworkers-object-optional","title":"<code>spec.commands[].k0supdate.targets.workers &lt;object&gt; (optional)</code>","text":"<ul> <li>This object provides the details of how <code>workers</code> should be updated.</li> </ul>"},{"location":"autopilot/#speccommandsk0supdatetargetsworkerslimitsconcurrent-int-optional-default-1","title":"<code>spec.commands[].k0supdate.targets.workers.limits.concurrent &lt;int&gt; (optional, default = 1)</code>","text":"<ul> <li>Specifying a <code>concurrent</code> value for worker targets will allow for that number of workers to be updated at a time. If no value is provided, <code>1</code> is assumed.</li> </ul>"},{"location":"autopilot/#airgapupdate-command","title":"<code>airgapupdate</code> Command","text":""},{"location":"autopilot/#speccommandsairgapupdateversion-string-required","title":"<code>spec.commands[].airgapupdate.version &lt;string&gt; (required)</code>","text":"<ul> <li>The version of the airgap bundle being updated.</li> </ul>"},{"location":"autopilot/#speccommandsairgapupdateplatformsurl-string-required","title":"<code>spec.commands[].airgapupdate.platforms.*.url &lt;string&gt; (required)</code>","text":"<ul> <li>An URL providing where the updated binary should be downloaded from, for this specific platform.<ul> <li>The naming of platforms is a combination of <code>$GOOS</code> and <code>$GOARCH</code>, separated by a hyphen (<code>-</code>)<ul> <li>eg: <code>linux-amd64</code>, <code>linux-arm64</code>, <code>linux-arm</code></li> </ul> </li> <li>Note: The main supported platform is <code>linux</code>. Autopilot may work on other platforms, however this has not been tested.</li> </ul> </li> </ul>"},{"location":"autopilot/#speccommandsairgapupdateplatformssha256-string-optional","title":"<code>spec.commands[].airgapupdate.platforms.*.sha256 &lt;string&gt; (optional)</code>","text":"<ul> <li>If a SHA256 hash is provided for the binary, the completed downloaded will be verified against it.</li> </ul>"},{"location":"autopilot/#speccommandsairgapupdateworkers-object-optional","title":"<code>spec.commands[].airgapupdate.workers &lt;object&gt; (optional)</code>","text":"<ul> <li>This object provides the details of how <code>workers</code> should be updated.</li> </ul>"},{"location":"autopilot/#speccommandsairgapupdateworkerslimitsconcurrent-int-optional-default-1","title":"<code>spec.commands[].airgapupdate.workers.limits.concurrent &lt;int&gt; (optional, default = 1)</code>","text":"<ul> <li>Specifying a <code>concurrent</code> value for worker targets will allow for that number of workers to be updated at a time. If no value is provided, <code>1</code> is assumed.</li> </ul>"},{"location":"autopilot/#static-discovery","title":"Static Discovery","text":"<p>This defines the <code>static</code> discovery method used for this set of targets (<code>controllers</code>, <code>workers</code>). The <code>static</code> discovery method relies on a fixed set of hostnames defined in <code>.nodes</code>.</p> <p>It is expected that a <code>Node</code> (workers) or <code>ControlNode</code> (controllers) object exists with the same name.</p> <pre><code>  static:\n    nodes:\n      - ip-172-31-44-131\n      - ip-172-31-42-134\n      - ip-172-31-39-65\n</code></pre>"},{"location":"autopilot/#speccommandsk0supdatetargetsdiscoverystaticnodes-string-required-for-static","title":"<code>spec.commands[].k0supdate.targets.*.discovery.static.nodes[] &lt;string&gt; (required for static)</code>","text":"<ul> <li>A list of hostnames that should be included in target set (<code>controllers</code>, <code>workers</code>).</li> </ul>"},{"location":"autopilot/#selector-target-discovery","title":"Selector Target Discovery","text":"<p>The <code>selector</code> target discovery method relies on a dynamic query to the Kubernetes API using labels and fields to produce a set of hosts that should be updated.</p> <p>Providing both <code>labels</code> and <code>fields</code> in the <code>selector</code> definition will result in a logical <code>AND</code> of both operands.</p> <pre><code>  selector:\n    labels: environment=staging\n    fields: metadata.name=worker2\n</code></pre> <p>Specifying an empty selector will result in all nodes being selected for this target set.</p> <pre><code>  selector: {}\n</code></pre>"},{"location":"autopilot/#speccommandsk0supdatetargetsdiscoveryselectorlabels-string-optional","title":"<code>spec.commands[].k0supdate.targets.*.discovery.selector.labels &lt;string&gt; (optional)</code>","text":"<ul> <li>A collection of name/value labels that should be used for finding the appropriate nodes for the update of this target set.</li> </ul>"},{"location":"autopilot/#speccommandsk0supdatetargetsdiscoveryselectorfields-string-optional","title":"<code>spec.commands[].k0supdate.targets.*.discovery.selector.fields &lt;string&gt; (optional)</code>","text":"<ul> <li>A collection of name/value fields that should be used for finding the appropriate nodes for the update of this target set.<ul> <li>Note: Currently only the field <code>metadata.name</code> is available as a query field.</li> </ul> </li> </ul>"},{"location":"autopilot/#status-reporting","title":"Status Reporting","text":"<p>After a <code>Plan</code> has been applied, its progress can be viewed in the <code>.status</code> of the <code>autopilot</code> Plan.</p> <pre><code>    kubectl get plan autopilot -oyaml\n</code></pre> <p>An example of a <code>Plan</code> status:</p> <pre><code>  status:\n    state: SchedulableWait\n    commands:\n    - state: SchedulableWait\n      k0supdate:\n        controllers:\n        - lastUpdatedTimestamp: \"2022-04-07T15:52:44Z\"\n          name: controller0\n          state: SignalCompleted\n        - lastUpdatedTimestamp: \"2022-04-07T15:52:24Z\"\n          name: controller1\n          state: SignalCompleted\n        - lastUpdatedTimestamp: \"2022-04-07T15:52:24Z\"\n          name: controller2\n          state: SignalPending\n        workers:\n        - lastUpdatedTimestamp: \"2022-04-07T15:52:24Z\"\n          name: worker0\n          state: SignalPending\n        - lastUpdatedTimestamp: \"2022-04-07T15:52:24Z\"\n          name: worker1\n          state: SignalPending\n        - lastUpdatedTimestamp: \"2022-04-07T15:52:24Z\"\n          name: worker2\n          state: SignalPending\n</code></pre> <p>To read this status, this indicates that:</p> <ul> <li>The overall status of the update is <code>SchedulableWait</code>, meaning that autopilot is   waiting for the next opportunity to process a command.</li> <li>There are three controller nodes<ul> <li>Two controllers have <code>SignalCompleted</code> successfully</li> <li>One is waiting to be signaled (<code>SignalPending</code>)</li> </ul> </li> <li>There are also three worker nodes<ul> <li>All are awaiting signaling updates (<code>SignalPending</code>)</li> </ul> </li> </ul>"},{"location":"autopilot/#plan-status","title":"Plan Status","text":"<p>The <code>Plan</code> status at <code>.status.status</code> represents the overall status of the autopilot update operation. There are a number of statuses available:</p> Status Description Ends Plan? <code>IncompleteTargets</code> There are nodes in the resolved <code>Plan</code> that do not have associated <code>Node</code> (worker) or <code>ControlNode</code> (controller) objects. Yes <code>InconsistentTargets</code> A controller has reported itself as not-ready during the selection of the next controller to update. Yes <code>Schedulable</code> Indicates that the <code>Plan</code> can be re-evaluated to determine which next node to update. No <code>SchedulableWait</code> Scheduling operations are in progress, and no further update scheduling should occur. No <code>Completed</code> The <code>Plan</code> has run successfully to completion. Yes <code>Restricted</code> The <code>Plan</code> included node types (controller or worker) that violates the <code>--exclude-from-plans</code> restrictions. Yes"},{"location":"autopilot/#node-status","title":"Node Status","text":"<p>Similar to the Plan Status, the individual nodes can have their own statuses:</p> Status Description <code>SignalPending</code> The node is available and awaiting an update signal <code>SignalSent</code> Update signaling has been successfully applied to this node. <code>MissingPlatform</code> This node is a platform that an update has not been provided for. <code>MissingSignalNode</code> This node does have an associated <code>Node</code> (worker) or <code>ControlNode</code> (controller) object."},{"location":"autopilot/#updateconfig","title":"UpdateConfig","text":""},{"location":"autopilot/#updateconfig-core-fields","title":"UpdateConfig Core Fields","text":""},{"location":"autopilot/#apiversion-string-required-field","title":"<code>apiVersion &lt;string&gt; (required field)</code>","text":"<ul> <li>API version. The current version of the Autopilot API is <code>v1beta2</code>, with a full group-version of <code>autopilot.k0sproject.io/v1beta2</code></li> </ul>"},{"location":"autopilot/#metadataname-string-required-field","title":"<code>metadata.name &lt;string&gt; (required field)</code>","text":"<ul> <li>Name of the config.</li> </ul>"},{"location":"autopilot/#spec","title":"Spec","text":""},{"location":"autopilot/#specchannel-string-optional","title":"<code>spec.channel &lt;string&gt; (optional)</code>","text":"<ul> <li>Update channel to use. Supported values: <code>stable</code>(default), <code>unstable</code>.</li> </ul>"},{"location":"autopilot/#specupdateserver-string-optional","title":"<code>spec.updateServer &lt;string&gt; (optional)</code>","text":"<ul> <li>Update server url. Defaults to <code>https://updates.k0sproject.io</code></li> </ul>"},{"location":"autopilot/#specupgradestrategytype-enumcronperiodic","title":"<code>spec.upgradeStrategy.type &lt;enum:cron|periodic&gt;</code>","text":"<ul> <li>Select which update strategy to use.</li> </ul>"},{"location":"autopilot/#specupgradestrategycron-string-optional-deprecated","title":"<code>spec.upgradeStrategy.cron &lt;string&gt; (optional)</code> DEPRECATED","text":"<ul> <li>Schedule to check for updates in crontab format.</li> </ul>"},{"location":"autopilot/#specupgradestrategycron-object","title":"<code>spec.upgradeStrategy.cron &lt;object&gt;</code>","text":"<p>Fields:</p> <ul> <li><code>days</code>: On which weekdays to check for updates</li> <li><code>startTime</code>: At which time of day to check updates</li> <li><code>length</code>: The length of the update window</li> </ul>"},{"location":"autopilot/#specplanspec-string-optional","title":"<code>spec.planSpec &lt;string&gt; (optional)</code>","text":"<ul> <li>Describes the behavior of the autopilot generated <code>Plan</code></li> </ul>"},{"location":"autopilot/#example","title":"Example","text":"<pre><code>apiVersion: autopilot.k0sproject.io/v1beta2\nkind: UpdaterConfig\nmetadata:\n  name: example\nspec:\n  channel: stable\n  updateServer: https://updates.k0sproject.io/\n  upgradeStrategy:\n    type: periodic\n    periodic:\n      # The following fields configures updates to happen only on Tue or Wed at 13:00-15:00\n      days: [Tuesdays,Wednesday]\n      startTime: \"13:00\"\n      length: 2h\n  # Optional. Specifies a created Plan object\n  planSpec:\n    commands:\n      - k0supdate: # optional\n          forceupdate: true # optional\n          targets:\n            controllers:\n              discovery:\n                static:\n                  nodes:\n                    - ip-172-31-44-131\n                    - ip-172-31-42-134\n                    - ip-172-31-39-65\n            workers:\n              limits:\n                concurrent: 5\n              discovery:\n                selector:\n                  labels: environment=staging\n                  fields: metadata.name=worker2\n        airgapupdate: # optional\n          workers:\n            limits:\n              concurrent: 5\n            discovery:\n              selector:\n                labels: environment=staging\n                fields: metadata.name=worker2\n</code></pre>"},{"location":"autopilot/#faq","title":"FAQ","text":""},{"location":"autopilot/#q-how-do-i-apply-the-plan-and-controlnode-crds","title":"Q: How do I apply the <code>Plan</code> and <code>ControlNode</code> CRDs?","text":"<p>A: These CRD definitions are embedded in the k0s binary and applied on startup. No additional action is needed.</p>"},{"location":"autopilot/#q-how-will-controlnode-instances-get-removed","title":"Q: How will <code>ControlNode</code> instances get removed?","text":"<p>A: <code>ControlNode</code> instances are created by autopilot controllers as they startup. When controllers disappear, they will not remove their associated <code>ControlNode</code> instance. It is the responsibility of the operator/administrator to ensure their maintenance.</p>"},{"location":"autopilot/#q-i-upgraded-my-workers-and-now-kubelets-are-no-longer-reporting","title":"Q: I upgraded my workers, and now Kubelets are no longer reporting","text":"<p>You probably upgraded your workers to an API version greater than what is available on the API server.</p> <p>https://kubernetes.io/releases/version-skew-policy/</p> <p>Make sure that your controllers are at the desired version first before upgrading workers.</p>"},{"location":"backup/","title":"Backup/Restore","text":""},{"location":"backup/#backuprestore-overview","title":"Backup/Restore overview","text":"<p>k0s has integrated support for backing up cluster state and configuration. The k0s backup utility is aiming to back up and restore k0s managed parts of the cluster.</p> <p>The backups created by <code>k0s backup</code> command have following pieces of your cluster:</p> <ul> <li>certificates (the content of the <code>&lt;data-dir&gt;/pki</code> directory)</li> <li>etcd snapshot, if the etcd data store is used</li> <li>Kine/SQLite snapshot, if the Kine/SQLite data store is used</li> <li>k0s.yaml</li> <li>any custom defined manifests under the <code>&lt;data-dir&gt;/manifests</code></li> <li>any image bundles located under the <code>&lt;data-dir&gt;/images</code></li> <li>any helm configuration</li> </ul> <p>Parts NOT covered by the backup utility:</p> <ul> <li><code>PersistentVolumes</code> of any running application</li> <li>data store, in case something else than etcd or Kine/SQLite is used</li> <li>any configuration to the cluster introduced by manual changes (e.g. changes that weren't saved under the <code>&lt;data-dir&gt;/manifests</code>)</li> </ul> <p>Any of the backup/restore related operations MUST be performed on the controller node.</p>"},{"location":"backup/#backuprestore-a-k0s-node-locally","title":"Backup/restore a k0s node locally","text":""},{"location":"backup/#backup-local","title":"Backup (local)","text":"<p>To create backup run the following command on the controller node:</p> <pre><code>k0s backup --save-path=&lt;directory&gt;\n</code></pre> <p>The directory used for the <code>save-path</code> value must exist and be writable. The default value is the current working directory. The command provides backup archive using following naming convention: <code>k0s_backup_&lt;ISODatetimeString&gt;.tar.gz</code></p> <p>Because of the date/time usage, it is guaranteed that none of the previously created archives would be overwritten.</p> <p>To output the backup archive to standard output, use <code>-</code> as the save path.</p>"},{"location":"backup/#restore-local","title":"Restore (local)","text":"<p>To restore cluster state from the archive use the following command on the controller node:</p> <pre><code>k0s restore /tmp/k0s_backup_2021-04-26T19_51_57_000Z.tar.gz\n</code></pre> <p>The command would fail if the data directory for the current controller has overlapping data with the backup archive content.</p> <p>The command would use the archived <code>k0s.yaml</code> as the cluster configuration description.</p> <p>In case if your cluster is HA, after restoring single controller node, join the rest of the controller nodes to the cluster. E.g. steps for N nodes cluster would be:</p> <ul> <li>Restore backup on fresh machine</li> <li>Run controller there</li> <li>Join N-1 new machines to the cluster the same way as for the first setup.</li> </ul> <p>To read the backup archive from standard input, use <code>-</code> as the file path.</p>"},{"location":"backup/#encrypting-backups-local","title":"Encrypting backups (local)","text":"<p>By using <code>-</code> as the save or restore path, it is possible to pipe the backup archive through an encryption utility such as GnuPG or OpenSSL.</p> <p>Note that unencrypted data will still briefly exist as temporary files on the local file system during the backup archive generation.</p>"},{"location":"backup/#encrypting-backups-using-gnupg","title":"Encrypting backups using GnuPG","text":"<p>Follow the instructions for your operating system to install the <code>gpg</code> command if it is not already installed.</p> <p>This tutorial only covers the bare minimum for example purposes. For secure key management practices and advanced usage refer to the GnuPG user manual.</p> <p>To generate a new key-pair, use:</p> <pre><code>gpg --gen-key\n</code></pre> <p>The key will be stored in your key ring.</p> <pre><code>gpg --list-keys\n</code></pre> <p>This will output a list of keys:</p> <pre><code>/home/user/.gnupg/pubring.gpg\n------------------------------\npub   4096R/BD33228F 2022-01-13\nuid                  Example User &lt;user@example.com&gt;\nsub   4096R/2F78C251 2022-01-13\n</code></pre> <p>To export the private key for decrypting the backup on another host, note the key ID (<code>BD33228F</code> in this example) in the list and use:</p> <pre><code>gpg --export-secret-keys --armor BD33228F &gt; k0s.key\n</code></pre> <p>To create an encrypted k0s backup:</p> <pre><code>k0s backup --save-path - | gpg --encrypt --recipient user@example.com &gt; backup.tar.gz.gpg\n</code></pre>"},{"location":"backup/#restoring-encrypted-backups-using-gnupg","title":"Restoring encrypted backups using GnuPG","text":"<p>You must have the private key in your GnuPG keychain. To import the key that was exported in the previous example, use:</p> <pre><code>gpg --import k0s.key\n</code></pre> <p>To restore the encrypted backup, use:</p> <pre><code>gpg --decrypt backup.tar.gz.gpg | k0s restore -\n</code></pre>"},{"location":"backup/#backuprestore-a-k0s-cluster-using-k0sctl","title":"Backup/restore a k0s cluster using k0sctl","text":"<p>With k0sctl you can perform cluster level backup and restore remotely with one command.</p>"},{"location":"backup/#backup-remote","title":"Backup (remote)","text":"<p>To create backup run the following command:</p> <pre><code>k0sctl backup\n</code></pre> <p>k0sctl connects to the cluster nodes to create a backup. The backup file is stored in the current working directory.</p>"},{"location":"backup/#restore-remote","title":"Restore (remote)","text":"<p>To restore cluster state from the archive use the following command:</p> <pre><code>k0sctl apply --restore-from /path/to/backup_file.tar.gz\n</code></pre> <p>The control plane load balancer address (<code>externalAddress</code>) needs to remain the same between backup and restore. This is caused by the fact that all worker node components connect to this address and cannot currently be re-configured.</p>"},{"location":"cis_benchmark/","title":"Kube-bench Security Benchmark","text":""},{"location":"cis_benchmark/#kube-bench-security-benchmark","title":"Kube-bench Security Benchmark","text":"<p>Kube-bench is an open source tool which can be used to verify security best practices as defined in CIS Kubernetes Benchmark. It provides a number of tests to help harden your k0s clusters. By default, k0s will pass Kube-bench benchmarks with some exceptions, which are shown below.</p>"},{"location":"cis_benchmark/#run","title":"Run","text":"<p>Follow the Kube-bench quick start instructions.</p> <p>After installing the Kube-bench on the host that is running <code>k0s</code> cluster run the following command:</p> <pre><code>kube-bench run --config-dir docs/kube-bench/cfg/ --benchmark k0s-1.0\n</code></pre>"},{"location":"cis_benchmark/#summary-of-disabled-checks","title":"Summary of disabled checks","text":""},{"location":"cis_benchmark/#master-node-security-configuration","title":"Master Node Security Configuration","text":"<p>The current configuration has in total 8 master checks disabled:</p> <ol> <li> <p>id: 1.2.10 - EventRateLimit requires external yaml config. It is left for the users to configure it</p> <pre><code>type: skip\ntext: \"Ensure that the admission control plugin EventRateLimit is set (Manual)\"\n</code></pre> </li> <li> <p>id: 1.2.12 - By default this isn't passed to the apiserver for air-gap functionality</p> <pre><code>type: skip\ntext: \"Ensure that the admission control plugin AlwaysPullImages is set (Manual)\"\n</code></pre> </li> <li> <p>id: 1.2.22 - For sake of simplicity of k0s all audit configurations are skipped. It is left for the users to configure it</p> <pre><code>type: skip\ntext: \"Ensure that the --audit-log-path argument is set (Automated)\"\n</code></pre> </li> <li> <p>id: 1.2.23 - For sake of simplicity of k0s all audit configuration are skipped. It is left for the users to configure it</p> <pre><code>type: skip\ntext: \"Ensure that the --audit-log-maxage argument is set to 30 or as appropriate (Automated)\"\n</code></pre> </li> <li> <p>id: 1.2.24 - For sake of simplicity of k0s all audit configurations are skipped. It is left for the users to configure it</p> <pre><code>type: skip\ntext: \"Ensure that the --audit-log-maxbackup argument is set to 10 or as appropriate (Automated)\"\n</code></pre> </li> <li> <p>id: 1.2.25 - For sake of simplicity of k0s all audit configurations are skipped. It is left for the users to configure it</p> <pre><code>type: skip\ntext: \"Ensure that the --audit-log-maxsize argument is set to 100 or as appropriate (Automated)\"\n</code></pre> </li> <li> <p>id: 1.2.33 - By default it is not enabled. Left for the users to decide</p> <pre><code>type: skip\ntext: \"Ensure that the --encryption-provider-config argument is set as appropriate (Manual)\"\n</code></pre> </li> <li> <p>id: 1.2.34 - By default it is not enabled. Left for the users to decide</p> <pre><code>type: skip\ntext: \"Ensure that encryption providers are appropriately configured (Manual)\"\n</code></pre> </li> </ol>"},{"location":"cis_benchmark/#worker-node-security-configuration","title":"Worker Node Security Configuration","text":"<p>and 4 node checks disabled:</p> <ol> <li> <p>id: 4.1.1 - not applicable since k0s does not use kubelet service file</p> <pre><code>type: skip\ntext: \"Ensure that the kubelet service file permissions are set to 644 or more restrictive (Automated)\"\n</code></pre> </li> <li> <p>id: 4.1.2 - not applicable since k0s does not use kubelet service file</p> <pre><code>type: skip\ntext: \"Ensure that the kubelet service file ownership is set to root:root (Automated)\"\n</code></pre> </li> <li> <p>id: 4.2.6 - k0s does not set this. See https://github.com/kubernetes/kubernetes/issues/66693</p> <pre><code>type: skip\ntext: \"Ensure that the --protect-kernel-defaults argument is set to true (Automated)\"\n</code></pre> </li> <li> <p>id: 4.2.10 - k0s doesn't set this up because certs get auto rotated</p> <pre><code>type: skip\ntext: \"Ensure that the --tls-cert-file and --tls-private-key-file arguments are set as appropriate (Manual)\"\n</code></pre> </li> </ol>"},{"location":"cis_benchmark/#control-plane-configuration","title":"Control Plane Configuration","text":"<p>3 checks for the control plane:</p> <ol> <li> <p>id: 3.1.1 - For purpose of being fully automated k0s is skipping this check</p> <pre><code>type: skip\ntext: \"Client certificate authentication should not be used for users (Manual)\"\n</code></pre> </li> <li> <p>id: 3.2.1 - out-of-the box configuration does not have any audit policy configuration but users can customize it in spec.api.extraArgs section of the config</p> <pre><code>type: skip\ntext: \"Ensure that a minimal audit policy is created (Manual)\"\n</code></pre> </li> <li> <p>id: 3.2.2 - Same as previous</p> <pre><code>type: skip\ntext: \"Ensure that the audit policy covers key security concerns (Manual)\"\n</code></pre> </li> </ol>"},{"location":"cis_benchmark/#kubernetes-policies","title":"Kubernetes Policies","text":"<p>Policy checks are also disabled. The checks are manual and are up to the end user to decide on them.</p>"},{"location":"cloud-providers/","title":"Cloud Providers","text":""},{"location":"cloud-providers/#cloud-providers","title":"Cloud providers","text":"<p>K0s supports all Kubernetes cloud controllers. However, those must be installed as separate cluster add-ons since k0s builds Kubernetes components in providerless mode.</p>"},{"location":"cloud-providers/#enable-cloud-provider-support-in-kubelet","title":"Enable cloud provider support in kubelet","text":"<p>You must enable cloud provider mode for kubelet. To do this, run the workers with <code>--enable-cloud-provider=true</code>.</p> <p>When deploying with k0sctl, you can add this into the <code>installFlags</code> of worker hosts.</p> <pre><code>spec:\n  hosts:\n  - ssh:\n      address: 10.0.0.1\n      user: root\n      keyPath: ~/.ssh/id_rsa\n    installFlags:\n      - --enable-cloud-provider\n      - --kubelet-extra-args=\"--cloud-provider=external\"\n    role: worker\n</code></pre>"},{"location":"cloud-providers/#deploy-the-cloud-provider","title":"Deploy the cloud provider","text":"<p>You can use any means to deploy your cloud controller into the cluster. Most providers support Helm charts to deploy them.</p> <p>Note: The prerequisites for the various cloud providers can vary (for example, several require that configuration files be present on all of the nodes). Refer to your chosen cloud provider's documentation as necessary.</p>"},{"location":"cloud-providers/#k0s-cloud-provider","title":"k0s Cloud Provider","text":"<p>Alternatively, k0s provides its own lightweight cloud provider that can be used to statically assign <code>ExternalIP</code> values to worker nodes via Kubernetes annotations.  This is beneficial for those who need to expose worker nodes externally via static IP assignments.</p> <p>To enable this functionality, add the parameter <code>--enable-k0s-cloud-provider=true</code> to all controllers, and <code>--enable-cloud-provider=true</code> to all workers.</p> <p>Adding a static IP address to a node using <code>kubectl</code>:</p> <pre><code>kubectl annotate \\\n    node &lt;node&gt; \\\n    k0sproject.io/node-ip-external=&lt;external IP&gt;[,&lt;external IP 2&gt;][,&lt;external IP 3&gt;]\n</code></pre> <p>Both IPv4 and IPv6 addresses and multiple comma-separated values are supported.</p>"},{"location":"cloud-providers/#defaults","title":"Defaults","text":"<p>The default node refresh interval is <code>2m</code>, which can be overridden using the <code>--k0s-cloud-provider-update-frequency=&lt;duration&gt;</code> parameter when launching the controller(s).</p> <p>The default port that the cloud provider binds to can be overridden using the <code>--k0s-cloud-provider-port=&lt;int&gt;</code> parameter when launching the controller(s).</p>"},{"location":"commercial-support/","title":"Commercial support","text":""},{"location":"commercial-support/#commercial-support","title":"Commercial support","text":"<p>Commercial support for k0s if offered by Mirantis Inc..</p> <p>Mirantis can provide various different levels of support starting from DevCare (9-to-5) all the way to OpsCare+ with fully managed service.</p> <p>On top of our normal release and support model our commercial customers have access to critical security patches even for released versions that fall outside of the Open Source maintained releases.<sup>1</sup> Commercial support also includes support for k0s related tooling such as k0sctl.</p> <p>If you are interested in commercial support for k0s check out our support description and please contact us for further details.</p> <ol> <li> <p>This is assuming there is a compatible release of upstream project with the fix\u00a0\u21a9</p> </li> </ol>"},{"location":"configuration-validation/","title":"Configuration Validation","text":""},{"location":"configuration-validation/#configuration-validation","title":"Configuration validation","text":"<p>k0s command-line interface has the ability to validate config syntax:</p> <pre><code>k0s config validate --config path/to/config/file\n</code></pre> <p><code>config validate</code> sub-command can validate the following:</p> <ol> <li>YAML formatting</li> <li>SAN addresses</li> <li>Network providers</li> <li>Worker profiles</li> </ol>"},{"location":"configuration/","title":"Configuration Options","text":""},{"location":"configuration/#configuration-options","title":"Configuration options","text":""},{"location":"configuration/#using-a-configuration-file","title":"Using a configuration file","text":"<p>k0s can be installed without a config file. In that case the default configuration will be used. You can, though, create and run your own non-default configuration (used by the k0s controller nodes).</p> <p>k0s supports providing only partial configurations. In case of partial configuration is provided, k0s will use the defaults for any missing values.</p> <ol> <li> <p>Generate a YAML config file that uses the default settings.</p> <pre><code>mkdir -p /etc/k0s\nk0s config create &gt; /etc/k0s/k0s.yaml\n</code></pre> </li> <li> <p>Modify the new YAML config file according to your needs, refer to Configuration file reference below. You can remove the default values if wanted as k0s supports partial configs too.</p> </li> <li> <p>Install k0s with your new config file.</p> <pre><code>sudo k0s install controller -c /etc/k0s/k0s.yaml\n</code></pre> </li> <li> <p>If you need to modify your existing configuration later on, you can change your config file also when k0s is running, but remember to restart k0s to apply your configuration changes.</p> <pre><code>sudo k0s stop\nsudo k0s start\n</code></pre> </li> </ol>"},{"location":"configuration/#configuring-k0s-via-k0sctl","title":"Configuring k0s via k0sctl","text":"<p>k0sctl can deploy your configuration options at cluster creation time. Your options should be placed in the <code>spec.k0s.config</code> section of the k0sctl configuration file. See the section on how to install k0s via k0sctl and the k0sctl README for more information.</p>"},{"location":"configuration/#configuration-file-reference","title":"Configuration file reference","text":"<p>CAUTION: As many of the available options affect items deep in the stack, you should fully understand the correlation between the configuration file components and your specific environment before making any changes.</p> <p>A YAML config file follows, with defaults as generated by the <code>k0s config create</code> command:</p> <pre><code>apiVersion: k0s.k0sproject.io/v1beta1\nkind: ClusterConfig\nmetadata:\n  name: k0s\nspec:\n  api:\n    address: 192.168.68.104\n    k0sApiPort: 9443\n    port: 6443\n    sans:\n    - 192.168.68.104\n    ca:\n      expiresAfter: 87600h\n      certificatesExpireAfter: 8760h\n  controllerManager: {}\n  extensions:\n    helm:\n      concurrencyLevel: 5\n  installConfig:\n    users:\n      etcdUser: etcd\n      kineUser: kube-apiserver\n      konnectivityUser: konnectivity-server\n      kubeAPIserverUser: kube-apiserver\n      kubeSchedulerUser: kube-scheduler\n  konnectivity:\n    adminPort: 8133\n    agentPort: 8132\n  network:\n    clusterDomain: cluster.local\n    dualStack:\n      enabled: false\n    kubeProxy:\n      iptables:\n        minSyncPeriod: 0s\n        syncPeriod: 0s\n      ipvs:\n        minSyncPeriod: 0s\n        syncPeriod: 0s\n        tcpFinTimeout: 0s\n        tcpTimeout: 0s\n        udpTimeout: 0s\n      metricsBindAddress: 0.0.0.0:10249\n      mode: iptables\n    kuberouter:\n      autoMTU: true\n      hairpin: Enabled\n      metricsPort: 8080\n    nodeLocalLoadBalancing:\n      enabled: false\n      envoyProxy:\n        apiServerBindPort: 7443\n        konnectivityServerBindPort: 7132\n      type: EnvoyProxy\n    podCIDR: 10.244.0.0/16\n    provider: kuberouter\n    serviceCIDR: 10.96.0.0/12\n  scheduler: {}\n  storage:\n    etcd:\n      peerAddress: 192.168.68.104\n      ca:\n        expiresAfter: 87600h\n        certificatesExpireAfter: 8760h\n    type: etcd\n  telemetry:\n    enabled: true\n</code></pre>"},{"location":"configuration/#spec-key-detail","title":"<code>spec</code> Key Detail","text":""},{"location":"configuration/#specapi","title":"<code>spec.api</code>","text":"Element Description <code>address</code> IP Address used by cluster components to talk to the API server. Also serves as one of the addresses pushed on the k0s create service certificate on the API. Defaults to first non-local address found on the node. <code>onlyBindToAddress</code> The API server binds to all interfaces by default. With this option set to <code>true</code>, the API server will only listen on the IP address configured by the <code>address</code> option (first non-local address by default). This can be necessary with multi-homed control plane nodes. <code>externalAddress</code> The load balancer address (for k0s controllers running behind a load balancer). Configures all cluster components to connect to this address and configures this address for use when joining new nodes to the cluster. <code>sans</code> List of additional addresses to push to API servers serving the certificate. <code>ca.expiresAfter</code> The expiration duration of the CA certificate (default: 87600h) <code>ca.certificatesExpireAfter</code> The expiration duration of the server certificate (default: 8760h) <code>extraArgs</code> Map of key-values (strings) for any extra arguments to pass down to Kubernetes API server process. <code>extraArgs</code> are recommended over <code>rawArgs</code> if the use case allows it. Any behavior triggered by these parameters is outside k0s support. (default: empty) <code>rawArgs</code> Slice of strings for any raw arguments to pass down to the kube-apiserver process. These are appended after <code>extraArgs</code>. If possible, it's recommended to use <code>extraArgs</code> over <code>rawArgs</code>. Any behavior triggered by these parameters is outside k0s support. (default: empty) <code>port</code>\u00b9 Custom port for the Kubernetes API server to listen on (default: 6443) <code>k0sApiPort</code>\u00b9 Custom port for k0s API server to listen on (default: 9443) <p>\u00b9 If <code>port</code> and <code>k0sApiPort</code> are used with the <code>externalAddress</code> element, the load balancer serving at <code>externalAddress</code> must listen on the same ports.</p>"},{"location":"configuration/#specstorage","title":"<code>spec.storage</code>","text":"Element Description <code>type</code> Type of the data store (valid values:<code>etcd</code> or <code>kine</code>). Note: Type <code>etcd</code> will cause k0s to create and manage an elastic etcd cluster within the controller nodes. <code>etcd.peerAddress</code> Node address used for etcd cluster peering. <code>etcd.extraArgs</code> Map of key-values (strings) for any extra arguments to pass down to etcd process. <code>extraArgs</code> are recommeneded over <code>rawrArgs</code> if the use case allows it.  Any behavior triggered by these parameters is outside k0s support. <code>etcd.rawArgs</code> Slice of strings for any raw arguments to pass down to the etcd process. These are appeneded after <code>extraArg</code>. If possible, it's recommended to use <code>extraArgs</code> over <code>rawArgs</code>. Any behavior triggered by these parameters is outside k0s support. <code>etcd.ca.expiresAfter</code> The expiration duration of the CA certificate (default: 87600h) <code>etcd.ca.certificatesExpireAfter</code> The expiration duration of the server certificate (default: 8760h) <code>kine.dataSource</code> kine data source URL. <code>etcd.externalCluster</code> Configuration when etcd is externally managed, i.e. running on dedicated nodes. See <code>spec.storage.etcd.externalCluster</code>"},{"location":"configuration/#specstorageetcdexternalcluster","title":"<code>spec.storage.etcd.externalCluster</code>","text":"<p>k0s can also work with an externally managed Etcd cluster. If this is configured, k0s will NOT set up etcd, it has to be managed manually.</p> Element Description <code>endpoints</code> Array of Etcd endpoints to use. <code>etcdPrefix</code> Prefix to use for this cluster. The same external Etcd cluster can be used for several k0s clusters, each prefixed with a unique prefix to store data with. <code>caFile</code> CaFile is the host path to a file with the Etcd cluster CA certificate. <code>clientCertFile</code> ClientCertFile is the host path to a file with the TLS certificate for etcd client. <code>clientKeyFile</code> ClientKeyFile is the host path to a file with the TLS key for etcd client."},{"location":"configuration/#specnetwork","title":"<code>spec.network</code>","text":"Element Description <code>provider</code> Network provider (valid values: <code>calico</code>, <code>kuberouter</code>, or <code>custom</code>). For <code>custom</code>, you can push any network provider (default: <code>kuberouter</code>). Be aware that it is your responsibility to configure all the CNI-related setups, including the CNI provider itself and all necessary host levels setups (for example, CNI binaries). Note: Once you initialize the cluster with a network provider the only way to change providers is through a full cluster redeployment. <code>podCIDR</code> Pod network CIDR to use in the cluster. Defaults to <code>10.244.0.0/16</code>. <code>serviceCIDR</code> Network CIDR to use for cluster VIP services. Defaults to <code>10.96.0.0/12</code>. <code>primaryAddressFamily</code> Defines the primary family for the cluster. Valid values are empty, <code>IPv4</code>, <code>IPv6</code>. If empty, K0s determines it based on <code>.spec.API.ExternalAddress</code>, if this isn't present it will use <code>.spec.API.Address.</code>. If both addresses are empty or the chosen address is a host name, defaults to <code>IPv4</code>. <code>clusterDomain</code> Cluster domain to be passed to the kubelet and the CoreDNS configuration. Defaults to <code>cluster.local</code>."},{"location":"configuration/#specnetworkcalico","title":"<code>spec.network.calico</code>","text":"Element Description <code>mode</code> Indicates the Calico backend to use. Either <code>bird</code> or <code>vxlan</code> (default). The deprecated legacy value <code>ipip</code> is also accepted. <code>overlay</code> Overlay mode: <code>Always</code> (default), <code>CrossSubnet</code> or <code>Never</code> (requires <code>mode=vxlan</code> to disable Calico overlay-network). <code>vxlanPort</code> The UDP port for VXLAN (default: <code>4789</code>). <code>vxlanVNI</code> The virtual network ID for VXLAN (default: <code>4096</code>). <code>mtu</code> MTU for overlay network (default: <code>0</code>, which causes Calico to detect optimal MTU during bootstrap). <code>wireguard</code> Enable WireGuard-based encryption (default: <code>false</code>). Your host system must be WireGuard ready (refer to the Calico documentation for details). <code>flexVolumeDriverPath</code> The host path for Calico's flex-volume-driver(default: <code>/usr/libexec/k0s/kubelet-plugins/volume/exec/nodeagent~uds</code>). Change this path only if the default path cannot be used (refer to Project Calico Issue #2712 for details). Ideally, you will pair this option with a custom <code>volumePluginDir</code> in the profile you use for your worker nodes. <code>ipAutodetectionMethod</code> Used to force Calico to pick up the interface for pod network inter-node routing (default: <code>\"\"</code>, meaning not set, so that Calico will instead use its defaults). For more information, refer to the Calico documentation. <code>envVars</code> Map of key-values (strings) for any calico-node environment variable."},{"location":"configuration/#specnetworkcalicoenvvars","title":"<code>spec.network.calico.envVars</code>","text":"<p>Environment variable's value must be string, e.g.:</p> <pre><code>spec:\n  network:\n    provider: calico\n    calico:\n      envVars:\n        TEST_BOOL_VAR: \"true\"\n        TEST_INT_VAR: \"42\"\n        TEST_STRING_VAR: test\n</code></pre> <p>K0s runs Calico with some predefined vars, which can be overwritten by setting new value in <code>spec.network.calico.envVars</code>:</p> <pre><code>CALICO_IPV4POOL_CIDR: \"{{ spec.network.podCIDR }}\"\nCALICO_DISABLE_FILE_LOGGING: \"true\"\nFELIX_DEFAULTENDPOINTTOHOSTACTION: \"ACCEPT\"\nFELIX_LOGSEVERITYSCREEN: \"info\"\nFELIX_HEALTHENABLED: \"true\"\nFELIX_PROMETHEUSMETRICSENABLED: \"true\"\nFELIX_FEATUREDETECTOVERRIDE: \"ChecksumOffloadBroken=true\"\n</code></pre> <p><code>FELIX_FEATUREDETECTOVERRIDE: ChecksumOffloadBroken=true</code> disables VXLAN offloading because of projectcalico/calico#4727.</p> <p>In single-stack mode, there are additional vars:</p> <pre><code>FELIX_IPV6SUPPORT: \"false\"\n</code></pre> <p>In dual-stack mode, there are additional vars:</p> <pre><code>CALICO_IPV6POOL_NAT_OUTGOING: \"true\"\nFELIX_IPV6SUPPORT: \"true\"\nIP6: \"autodetect\"\nCALICO_IPV6POOL_CIDR: \"{{ spec.network.dualStack.IPv6podCIDR }}\"\n</code></pre>"},{"location":"configuration/#specnetworkkuberouter","title":"<code>spec.network.kuberouter</code>","text":"Element Description <code>autoMTU</code> Auto-detection of used MTU (default: <code>true</code>). <code>mtu</code> Override MTU setting, if <code>autoMTU</code> must be set to <code>false</code>. <code>metricsPort</code> Kube-router metrics server port. Set to 0 to disable metrics (default: <code>8080</code>). <code>peerRouterIPs</code> DEPRECATED: Use extraArgs with peerRouterIPs instead. Comma-separated list of global peer addresses. <code>peerRouterASNs</code> DEPRECATED: Use extraArgs with peerRouterASNs instead. Comma-separated list of global peer ASNs. <code>hairpin</code> Configure hairpin mode. Supported modes are <code>Enabled</code>: enabled cluster wide, <code>Allowed</code>: must be allowed per service using annotations, <code>Disabled</code>: doesn't work at all (default: <code>Enabled</code>) <code>hairpinMode</code> Deprecated Use <code>hairpin</code> instead. If both <code>hairpin</code> and <code>hairpinMode</code> are defined, this is ignored. If only hairpinMode is configured explicitly activates hairpinMode. <code>ipMasq</code> IP masquerade for traffic originating from the pod network, and destined outside of it (default: false) <code>extraArgs</code> Extra arguments to pass to Kube-router. <code>extraArgs</code> are recommended over <code>rawArgs</code> if the use case allows it. Can be also used to override any k0s managed arguments. For reference, see Kube-router documentation. Any behavior triggered by these parameters is outside k0s support. (default: empty) <code>rawArgs</code> Slice of strings for any raw arguments to pass down to the kube-router process. These are appended after <code>extraArgs</code>. Any behavior triggered by these parameters is outside k0s support. (default: empty) <p>Note: Kube-router allows many networking aspects to be configured per node, service, and pod (for more information, refer to the Kube-router user guide).</p>"},{"location":"configuration/#specnetworkkubeproxy","title":"<code>spec.network.kubeProxy</code>","text":"<p>| Element             | Description                                                                                                                                                                                                                                                               | ---------------------------------------------------------------------------------------------------------|---------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <code>disabled</code>          | Disable kube-proxy altogether (default: <code>false</code>).                                                                                                                                                                                                                         | | <code>mode</code>              | Kube proxy operating mode, supported modes <code>iptables</code>, <code>ipvs</code>, <code>nftables</code>, <code>userspace</code> (default: <code>iptables</code>)                                                                                                                                                              | | <code>iptables</code>          | Kube proxy iptables settings                                                                                                                                                                                                                                              | | <code>ipvs</code>              | Kube proxy IPVS settings                                                                                                                                                                                                                                                  | | <code>nftables</code>          | Kube proxy nftables settings                                                                                                                                                                                                                                              | | <code>nodePortAddresses</code> | Kube proxy nodePortAddresses                                                                                                                                                             | | <code>extraArgs</code>         | Map of key-values (strings) for any extra arguments to pass down to kube-proxy process. <code>extraArgs</code> are recommended over <code>rawArgs</code> if the use case allows it. Any behavior triggered by these parameters is outside k0s support. (default: empty)                         | | <code>rawArgs</code>           | Slice of strings for any raw arguments to pass down to the kube-proxy process. These are appended after <code>extraArgs</code>. If possible, it's recommended to use <code>extraArgs</code> over <code>rawArgs</code>. Any behavior triggered by these parameters is outside k0s support. (default: empty) |</p> <p>Default kube-proxy iptables settings:</p> <pre><code>iptables:\n  masqueradeAll: false\n  masqueradeBit: null\n  minSyncPeriod: 0s\n  syncPeriod: 0s\n</code></pre> <p>Default kube-proxy IPVS settings:</p> <pre><code>ipvs:\n  excludeCIDRs: null\n  minSyncPeriod: 0s\n  scheduler: \"\"\n  strictARP: false\n  syncPeriod: 0s\n  tcpFinTimeout: 0s\n  tcpTimeout: 0s\n  udpTimeout: 0s\n</code></pre> <p>Default kube-proxy nftables settings:</p> <pre><code>nftables:\n  masqueradeAll: false\n  masqueradeBit: null\n  minSyncPeriod: 0s\n  syncPeriod: 0s\n</code></pre>"},{"location":"configuration/#specnetworknodelocalloadbalancing","title":"<code>spec.network.nodeLocalLoadBalancing</code>","text":"<p>Configuration options related to k0s's node-local load balancing feature.</p> Element Description <code>enabled</code> Indicates if node-local load balancing should be used to access Kubernetes API servers from worker nodes. Default: <code>false</code>. <code>type</code> The type of the node-local load balancer to deploy on worker nodes. Default: <code>EnvoyProxy</code>. (This is the only option for now.) <code>envoyProxy</code> Configuration options related to the \"EnvoyProxy\" type of load balancing."},{"location":"configuration/#specnetworknodelocalloadbalancingenvoyproxy","title":"<code>spec.network.nodeLocalLoadBalancing.envoyProxy</code>","text":"<p>Configuration options required for using Envoy as the backing implementation for node-local load balancing.</p> <p>Note: This type of load balancing is not supported on ARMv7 workers.</p> Element Description <code>image</code> The OCI image that's being used for the Envoy Pod. <code>imagePullPolicy</code> The pull policy being used used for the Envoy Pod. Defaults to <code>spec.images.default_pull_policy</code> if omitted. <code>apiServerBindPort</code> Port number on which to bind the Envoy load balancer for the Kubernetes API server to on a worker's loopback interface. Default: <code>7443</code>. <code>konnectivityServerBindPort</code> Port number on which to bind the Envoy load balancer for the konnectivity server to on a worker's loopback interface. Default: <code>7132</code>."},{"location":"configuration/#specnetworkcontrolplaneloadbalancing","title":"<code>spec.network.controlPlaneLoadBalancing</code>","text":"<p>Configuration options related to k0s's control plane load balancing feature</p> Element Description <code>enabled</code> Indicates if control plane load balancing should be enabled. Default: <code>false</code>. <code>type</code> The type of the control plane load balancer to deploy on controller nodes. Currently, the only supported type is <code>Keepalived</code>. <code>keepalived</code> Contains the keepalived configuration."},{"location":"configuration/#specnetworkcontrolplaneloadbalancingkeepalived","title":"<code>spec.network.controlPlaneLoadBalancing.Keepalived</code>","text":"<p>Configuration options related to keepalived in control plane load balancing</p> Element Description <code>vrrpInstances</code> Configuration options related to the VRRP. This is an array which allows to configure multiple virtual IPs. <code>virtualServers</code> Configuration options related to load balancing. This is an array which allows to configure multiple load balancers. <code>userSpaceProxyBindPort</code> The port the user space proxy will bind to. This port is for internal use only, but listens on every interface. Default: <code>6444</code> <code>disableLoadBalancer</code> Disables the load balancer. Default: <code>false</code>"},{"location":"configuration/#specnetworkcontrolplaneloadbalancingkeepalivedvrrpinstances","title":"<code>spec.network.controlPlaneLoadBalancing.keepalived.vrrpInstances</code>","text":"<p>Configuration options required for using VRRP to configure VIPs in control plane load balancing.</p> Element Description <code>virtualIPs</code> List of virtual IP address used by the VRRP instance. Each virtual IP must be a CIDR as defined in RFC 4632 and RFC 4291.A list of the CIDRs handled by the VRRP instance. <code>interface</code> The NIC used by the virtual router. If not specified, k0s will use the interface that owns the default route. <code>virtualRouterID</code> The VRRP router ID. If not specified, k0s will automatically number the IDs for each VRRP instance, starting with 51. It must be in the range of 1-255, all the control plane nodes must use the same <code>virtualRouterID</code>. Other clusters in the same network must not use the same <code>virtualRouterID</code>. <code>advertIntervalSeconds</code> Advertisement interval in seconds. Defaults to 1 second. <code>authPass</code> The password for accessing VRRPD. This is not a security feature but a way to prevent accidental misconfigurations. It must be in the range of 1-8 characters <code>unicastPeers</code> A list of IP addresses to connect using unicast. If this field is specified, <code>unicastSourceIP</code> is mandatory, and this list must not contain the IP address specified in <code>unicastSourceIP</code>. <code>unicastSourceIP</code> The source IP address when using unicast. If <code>unicastPeers</code> isn't defined this field is ignored. <code>addressLabel</code> The label for the VRRP instance for IPv6 VIPs.  This value is ignored for IPv4 VIPs. This is used to set the routing preference as per RFC 6724. If set to <code>0</code>, uses default value. Default: <code>10000</code>"},{"location":"configuration/#specnetworkcontrolplaneloadbalancingkeepalivedvirtualservers","title":"<code>spec.network.controlPlaneLoadBalancing.keepalived.virtualServers</code>","text":"<p>Configuration options required for using VRRP to configure VIPs in control plane load balancing.</p> Element Description <code>ipAddress</code> The load balancer's listen address. <code>delayLoop</code> Delay timer for check polling. Accepts microsecond precision. Further precision will be truncated without warnings. Defaults to <code>1m</code>. <code>lbAlgo</code> Algorithm used by keepalived. Supported algorithms: <code>rr</code>, <code>wrr</code>, <code>lc</code>, <code>wlc</code>, <code>lblc</code>, <code>dh</code>, <code>sh</code>, <code>sed</code>, <code>nq</code>. Default: <code>rr</code>. <code>lbKind</code> Kind of IPVS load balancer. Supported values: <code>NAT</code>, <code>DR</code>, <code>TUN</code>. Default: <code>DR</code>. <code>persistenceTimeoutSeconds</code> Timeout for persistent connections in seconds. Must be in the range of 1-2678400 (31 days). If not specified, defaults to 360 (6 minutes)."},{"location":"configuration/#speccontrollermanager","title":"<code>spec.controllerManager</code>","text":"Element Description <code>extraArgs</code> Map of key-values (strings) for any extra arguments you want to pass down to the Kubernetes controller manager process. <code>extraArgs</code> are recommended over <code>rawArgs</code> if the use case allows it. Any behavior triggered by these parameters is outside k0s support. (default: empty) <code>rawArgs</code> Slice of strings for any raw arguments to pass down to the kube-controller-manager process. These are appended after <code>extraArgs</code>. If possible, it's recommended to use <code>extraArgs</code> over <code>rawArgs</code>. Any behavior triggered by these parameters is outside k0s support. (default: empty)"},{"location":"configuration/#specscheduler","title":"<code>spec.scheduler</code>","text":"Element Description <code>extraArgs</code> Map of key-values (strings) for any extra arguments you want to pass down to Kubernetes scheduler process. <code>extraArgs</code> are recommended over <code>rawArgs</code> if the use case allows it. Any behavior triggered by these parameters is outside k0s support. (default: empty) <code>rawArgs</code> Slice of strings for any raw arguments to pass down to the kube-scheduler process. These are appended after <code>extraArgs</code>. If possible, it's recommended to use <code>extraArgs</code> over <code>rawArgs</code>. Any behavior triggered by these parameters is outside k0s support. (default: empty)"},{"location":"configuration/#specworkerprofiles","title":"<code>spec.workerProfiles</code>","text":"<p>Worker profiles are used to manage worker-specific configuration in a centralized manner. A ConfigMap is generated for each worker profile. Based on the <code>--profile</code> argument given to the <code>k0s worker</code>, the configuration in the corresponding ConfigMap is picked up during start-up.</p> <p>The worker profiles are defined as an array. Each element has following properties:</p> Property Description <code>name</code> String; name to use as profile selector for the worker process <code>values</code> Object; Kubelet configuration overrides, see below for details"},{"location":"configuration/#specworkerprofilesvalues-kubelet-configuration-overrides","title":"<code>spec.workerProfiles[].values</code> (Kubelet configuration overrides)","text":"<p>The Kubelet configuration overrides of a profile override the defaults defined by k0s.</p> <p>Note that there are several fields that cannot be overridden:</p> <ul> <li><code>clusterDNS</code></li> <li><code>clusterDomain</code></li> <li><code>apiVersion</code></li> <li><code>kind</code></li> <li><code>staticPodURL</code></li> </ul>"},{"location":"configuration/#configuration-examples","title":"Configuration examples","text":""},{"location":"configuration/#custom-volumeplugindir","title":"Custom volumePluginDir","text":"<pre><code>spec:\n  workerProfiles:\n    - name: custom-pluginDir\n      values:\n         volumePluginDir: /var/libexec/k0s/kubelet-plugins/volume/exec\n</code></pre>"},{"location":"configuration/#eviction-policy","title":"Eviction Policy","text":"<pre><code>spec:\n  workerProfiles:\n    - name: custom-eviction\n      values:\n        evictionHard:\n          memory.available: \"500Mi\"\n          nodefs.available: \"1Gi\"\n          imagefs.available: \"100Gi\"\n        evictionMinimumReclaim:\n          memory.available: \"0Mi\"\n          nodefs.available: \"500Mi\"\n          imagefs.available: \"2Gi\"\n</code></pre>"},{"location":"configuration/#unsafe-sysctls","title":"Unsafe Sysctls","text":"<pre><code>spec:\n  workerProfiles:\n    - name: custom-eviction\n      values:\n        allowedUnsafeSysctls:\n          - fs.inotify.max_user_instances\n</code></pre>"},{"location":"configuration/#specfeaturegates","title":"<code>spec.featureGates</code>","text":"<p>Available components are:</p> <ul> <li><code>kube-apiserver</code></li> <li><code>kube-controller-manager</code></li> <li><code>kubelet</code></li> <li><code>kube-scheduler</code></li> <li><code>kube-proxy</code></li> </ul> <p>If <code>components</code> is omitted, propagates to all Kubernetes components.</p> <p>Modifies <code>extraArgs</code>.</p>"},{"location":"configuration/#examples","title":"Examples","text":""},{"location":"configuration/#generic-feature-gates-example","title":"Generic feature gates example","text":"<pre><code>spec:\n    featureGates:\n      - name: feature-gate-0\n        enabled: true\n        components: [\"kube-apiserver\", \"kube-controller-manager\", \"kubelet\", \"kube-scheduler\"]\n      - name: feature-gate-1\n        enabled: true\n      - name: feature-gate-2\n        enabled: false\n</code></pre>"},{"location":"configuration/#kubelet-feature-gates-example","title":"Kubelet feature gates example","text":"<p>The below is an example of a k0s config with feature gates enabled:</p> <pre><code>spec:\n    featureGates:\n      - name: DevicePlugins\n        enabled: true\n        components: [\"kubelet\"]\n      - name: Accelerators\n        enabled: true\n        components: [\"kubelet\"]\n      - name: AllowExtTrafficLocalEndpoints\n        enabled: false\n</code></pre>"},{"location":"configuration/#specimages","title":"<code>spec.images</code>","text":"<p>Nodes under the <code>images</code> key all have the same basic structure:</p> <pre><code>spec:\n  images:\n    coredns:\n      image: quay.io/k0sproject/coredns\n      version: 1.12.2-1\n</code></pre> <p>If you want the list of default images and their versions to be included, use <code>k0s config create --include-images</code>.</p>"},{"location":"configuration/#available-keys","title":"Available keys","text":"<ul> <li><code>spec.images.konnectivity</code></li> <li><code>spec.images.metricsserver</code></li> <li><code>spec.images.kubeproxy</code></li> <li><code>spec.images.coredns</code></li> <li><code>spec.images.pause</code></li> <li><code>spec.images.calico.cni</code></li> <li><code>spec.images.calico.node</code></li> <li><code>spec.images.calico.kubecontrollers</code></li> <li><code>spec.images.kuberouter.cni</code></li> <li><code>spec.images.kuberouter.cniInstaller</code></li> <li><code>spec.images.repository</code>\u00b9</li> <li><code>spec.images.default_pull_policy</code>\u00b2</li> </ul> <p>\u00b9 If <code>spec.images.repository</code> is set and not empty, every image will be pulled from there.</p> <p>\u00b2 If <code>spec.images.default_pull_policy</code> is set and not empty, it will be used as a pull policy for each bundled image.</p>"},{"location":"configuration/#image-example","title":"Image example","text":"<pre><code>images:\n  repository: airgap-repo.local\n  calico:\n    kubecontrollers:\n      image: repo.acme.corp/k0sproject/calico-kube-controllers\n      version: v3.29.6-0\n  metricsserver:\n    image: repo.acme.corp/k0sproject/metrics-server\n    version: v0.7.2-0\n</code></pre> <p>In the runtime the image names are calculated as <code>airgap-repo.local/k0sproject/calico-kube-controllers:v3.29.6-0</code> and <code>airgap-repo.local/k0sproject/metrics-server:v0.7.2-0</code>. This only affects the image pull location, and thus omitting an image specification here will not disable component deployment.</p>"},{"location":"configuration/#specextensionshelm","title":"<code>spec.extensions.helm</code>","text":"<p><code>spec.extensions.helm</code> is the config file key in which you configure the list of Helm repositories and charts to deploy during cluster bootstrap (for more information, refer to Helm Charts).</p>"},{"location":"configuration/#speckonnectivity","title":"<code>spec.konnectivity</code>","text":"<p>The <code>spec.konnectivity</code> key is the config file key in which you configure Konnectivity-related settings.</p> <ul> <li><code>agentPort</code> agent port to listen on (default 8132)</li> <li><code>adminPort</code> admin port to listen on (default 8133)</li> </ul>"},{"location":"configuration/#spectelemetry","title":"<code>spec.telemetry</code>","text":"<p>To improve the end-user experience k0s is configured by default to collect telemetry data from clusters and send it to the k0s development team. To disable the telemetry function, change the <code>enabled</code> setting to <code>false</code>.</p> <p>The telemetry interval is ten minutes.</p> <pre><code>spec:\n  telemetry:\n    enabled: true\n</code></pre>"},{"location":"configuration/#disabling-controller-components","title":"Disabling controller components","text":"<p>k0s allows to completely disable some of the system components. This allows users to build a minimal Kubernetes control plane and use what ever components they need to fulfill their need for the control plane. Disabling the system components happens through a command line flag for the controller process:</p> <pre><code>--disable-components strings                     disable components (valid items: applier-manager,autopilot,control-api,coredns,csr-approver,endpoint-reconciler,helm,konnectivity-server,kube-controller-manager,kube-proxy,kube-scheduler,metrics-server,network-provider,node-role,system-rbac,update-prober,windows-node,worker-config)\n</code></pre> <p>If you use k0sctl, just add the flag when installing the cluster for the first controller at <code>spec.hosts.installFlags</code> in the config file like e.g.:</p> <pre><code>spec:\n  hosts:\n  - role: controller\n    installFlags:\n    - --disable-components=metrics-server\n</code></pre> <p>As seen from the component list, the only always-on component is the Kubernetes API server, without that k0s serves no purpose.</p>"},{"location":"configuration/#kubelet-root-directory","title":"Kubelet root directory","text":"<p>Unlike vanilla Kubernetes, k0s by default deploys kubelet's root directory inside <code>--data-dir</code>, which defaults to <code>/var/lib/k0s/</code> and kubelet ultimately runs in <code>/var/lib/k0s/kubelet</code>. This can result in incompatibilities on external software that mounts the kubelet working directory, such as CSI plugins.</p> <p>This can be changed using the flag <code>--kubelet-root-dir</code>, for instance, to use Kubernetes' default value it can be set up as:</p> <pre><code>sudo k0s install worker --token-file /var/lib/k0s/join-token --kubelet-root-dir=/var/lib/kubelet\n</code></pre> <p>Keep in mind that changing the flag in an existing node will not remove existing directories. Equally importantly, some pods such as CSI plugins are likely to mount this directory, having inconsistent values across nodes is very likely to cause problems on Deployments and DaemonSets.</p>"},{"location":"containerd_config/","title":"Containerd config","text":"<p>See runtime.</p>"},{"location":"cplb/","title":"Control plane load balancing","text":""},{"location":"cplb/#control-plane-load-balancing","title":"Control plane load balancing","text":"<p>For clusters that don't have an externally managed load balancer for the k0s control plane, there is another option to get a highly available control plane called control plane load balancing (CPLB).</p> <p>CPLB provides clusters a highly available VIP (virtual IP) and load balancing for accessing the cluster externally. For internal traffic (nodes to control plane) k0s provides NLLB. Both features are fully compatible and it's recommended to use both together if you don't have an external load balancer.</p> <p>Load balancing means that an IP address will forward the traffic to every control plane node, Virtual IPs mean that this IP address will be present on at least one node at a time.</p> <p>CPLB relies on keepalived for highly available VIPs. Internally, Keepalived uses the VRRP protocol. Load Balancing can be done through either userspace reverse proxy implemented in k0s (recommended for simplicity), or it can use Keepalived's virtual servers feature, which ultimately relies on IPVS.</p>"},{"location":"cplb/#compatibility","title":"Compatibility","text":"<p>CPLB depends on multiple technologies to work together as a whole, making it difficult to work on every single scenario.</p>"},{"location":"cplb/#single-node","title":"Single node","text":"<p>CPLB is incompatible with running as a single node. This means k0s must not be started using the <code>--single</code> flag.</p>"},{"location":"cplb/#controller-worker","title":"Controller + worker","text":"<p>K0s only supports the userspace reverse proxy load balancer. Keepalived's VirtualServers are not supported with controller + worker.</p> <p>Both Kube-Router and Calico managed by k0s are supported with the userspace reverse proxy load balancer, however, k0s creates iptables rules in the control plane nodes which may be incompatible with custom CNI plugins.</p>"},{"location":"cplb/#external-address","title":"External address","text":"<p>If <code>spec.api.externalAddress</code> is defined, control plane load balancing implicitly disables k0s's endpoint reconciler component, just as if the <code>--disable-components=endpoint-reconciler</code> flag had been specified.</p>"},{"location":"cplb/#node-local-load-balancing","title":"Node Local load balancing","text":"<p>CPLB is fully compatible with NLLB, however NLLB is incompatible with <code>spec.api.externalAddress</code>.</p>"},{"location":"cplb/#virtual-ips-high-availability","title":"Virtual IPs - High availability","text":""},{"location":"cplb/#what-is-a-vip-virtual-ip","title":"What is a VIP (virtual IP)","text":"<p>A virtual IP is an IP address that isn't tied to a single network interface, instead it floats between multiple servers. This is a failover mechanism that grants that there is always at least a functioning server and removes a single point of failure.</p>"},{"location":"cplb/#configuring-vips","title":"Configuring VIPs","text":"<p>CPLB relies internally on Keepalived's VRRP Instances. A VRRP Instance is a server that will manage one or more VIPs. Most users will need exactly one VRRP instance with exactly one VIP, however k0s allows multiple VRRP servers with multiple VIPs for more advanced use cases such as network segmentation.</p> <p>A virtualIP requires:</p> <ol> <li>A user-defined CIDR address which must be routable in the network. For most installations, this will be in the same CIDR as the physical interface. WARNING: K0s is not aware of external IP address management and the administrator is responsible for ensuring that IP addresses aren't colliding.</li> <li>A user-defined password which should be unique for each cluster. This password is a mechanism to prevent accidental conflicts. It's not encrypted and doesn't prevent malicious attacks in any way.</li> <li>A virtual router ID, which defaults to 51. This virtual router ID must be unique in the broadcast domain.</li> <li>A network interface, if not defined, k0s will chose the network interface that owns the default route.</li> </ol> <p>Except the network interface, all the other fields must be equal on every control plane node.</p> <p>This is a minimal example:</p> <pre><code>spec:\n  network:\n    controlPlaneLoadBalancing:\n      enabled: true\n      type: Keepalived\n      keepalived:\n        vrrpInstances:\n        - virtualIPs: [\"&lt;VIP address&gt;/&lt;netmask&gt;\"] # for instance [\"172.16.0.100/16\"]\n          authPass: \"&lt;my password&gt;\"\n</code></pre> <p>By default, VRRP Instances use multicast as per RFC 3768. It's possible to configure VRRP instances to use unicast:</p> <pre><code>spec:\n  network:\n    controlPlaneLoadBalancing:\n      enabled: true\n      type: Keepalived\n      keepalived:\n        vrrpInstances:\n        - virtualIPs: [\"&lt;VIP address&gt;/&lt;netmask&gt;\"] # for instance [\"172.16.0.100/16\"]\n          authPass: \"&lt;my password&gt;\"\n          unicastSourceIP: &lt;ip address of this controller&gt;\n          unicastPeers: [&lt;ip address of other controllers&gt;, ...]\n</code></pre> <p>When using unicast, k0st does not attempt to detect <code>unicastSourceIP</code> and it must be defined explicitly and <code>unicastPeers</code> must include the IP address of the other controllers' <code>unicastSourceIP</code>.</p>"},{"location":"cplb/#ipv6-vips-egress-routing-preference","title":"IPv6 VIPs egress routing preference","text":"<p>In IPv6 there aren't primary addresses, instead the routing preference is determined by the operating system using either IP labels or IP rules. K0s Virtual Addresses uses RFC 6724 IP labels. By default, k0s sets the label to 10000 so that it still uses the main IP address as a source of egress connections.</p> <p>This value may be replaced per vrrPInstance:</p> <pre><code>spec:\n  network:\n    controlPlaneLoadBalancing:\n      enabled: true\n      type: Keepalived\n      keepalived:\n        vrrpInstances:\n        - virtualIPs: [\"&lt;VIP address&gt;/&lt;netmask&gt;\"] # for instance [\"2001:db8:2::1/64\"]\n          authPass: \"&lt;my password&gt;\"\n          addressLabel: 30000\n</code></pre> <p>The label value can be verified using iproute2:</p> <pre><code>$ ip addrlabel | grep 2001:db8:2::1\nprefix 2001:db8:2::1/128 label 30000\n</code></pre> <p>The prefix always uses netmask 128.</p> <p>K0s doesn't attempt to modify labels that do not belong to the VIP.</p>"},{"location":"cplb/#load-balancing","title":"Load Balancing","text":"<p>Currently k0s allows to chose one of two load balancing mechanism:</p> <ol> <li>A userspace reverse proxy running in the k0s process. This is the default and recommended setting.</li> <li>For users who may need extra performance or more flexible algorithms, k0s can use the keepalived virtual servers load balancer feature.</li> </ol> <p>All control plane nodes must use the same load balancing mechanism. Different Load balancing mechanism is not supported and has undefined behavior.</p>"},{"location":"cplb/#load-balancing-userspace-reverse-proxy","title":"Load Balancing - Userspace Reverse Proxy","text":"<p>This is the default behavior, in order to enable it simple configure a VIP using a VRRP instance.</p> <pre><code>spec:\n  network:\n    controlPlaneLoadBalancing:\n      enabled: true\n      type: Keepalived\n      keepalived:\n        vrrpInstances:\n        - virtualIPs: [\"&lt;VIP address&gt;/&lt;netmask&gt;\"] # for instance [\"172.16.0.100/16\"]\n          authPass: \"&lt;my password&gt;\"\n</code></pre>"},{"location":"cplb/#keepalived-virtual-servers-load-balancing","title":"Keepalived Virtual Servers Load Balancing","text":"<p>The Keepalived virtual servers Load Balancing is more performant than the userspace reverse proxy load balancer. However, it's  not recommended because it has some drawbacks:</p> <ol> <li>It's incompatible with controller+worker.</li> <li>May not work on every infrastructure.</li> <li>Troubleshooting is significantly more complex.</li> <li>When there is more than one VRRPInstance, we must do the load balancing in all the servers which in some rare circumstances can provoke temporary routing loops.</li> </ol> <pre><code>spec:\n  network:\n    controlPlaneLoadBalancing:\n      enabled: true\n      type: Keepalived\n      keepalived:\n        vrrpInstances:\n        - virtualIPs: [\"&lt;VIP address&gt;/&lt;netmask&gt;\"] # for instance [\"172.16.0.100/16\"]\n          authPass: \"&lt;my password&gt;\"\n        virtualServers:\n        - ipAddress: \"&lt;VIP address without netmask&gt;\" # for instance 172.16.0.100\n</code></pre>"},{"location":"cplb/#full-example-using-k0sctl","title":"Full example using <code>k0sctl</code>","text":"<p>The following example shows a full <code>k0sctl</code> configuration file featuring three controllers and three workers with control plane load balancing enabled.</p> <pre><code>apiVersion: k0sctl.k0sproject.io/v1beta1\nkind: Cluster\nmetadata:\n  name: k0s-cluster\nspec:\n  hosts:\n  - role: controller\n    ssh:\n      address: controller-0.k0s.lab\n      user: root\n      keyPath: ~/.ssh/id_rsa\n    k0sBinaryPath: /opt/k0s\n    uploadBinary: true\n  - role: controller\n    ssh:\n      address: controller-1.k0s.lab\n      user: root\n      keyPath: ~/.ssh/id_rsa\n    k0sBinaryPath: /opt/k0s\n    uploadBinary: true\n  - role: controller\n    ssh:\n      address: controller-2.k0s.lab\n      user: root\n      keyPath: ~/.ssh/id_rsa\n    k0sBinaryPath: /opt/k0s\n    uploadBinary: true\n  - role: worker\n    ssh:\n      address: worker-0.k0s.lab\n      user: root\n      keyPath: ~/.ssh/id_rsa\n    k0sBinaryPath: /opt/k0s\n    uploadBinary: true\n  - role: worker\n    ssh:\n      address: worker-1.k0s.lab\n      user: root\n      keyPath: ~/.ssh/id_rsa\n    k0sBinaryPath: /opt/k0s\n    uploadBinary: true\n  - role: worker\n    ssh:\n      address: worker-2.k0s.lab\n      user: root\n      keyPath: ~/.ssh/id_rsa\n    k0sBinaryPath: /opt/k0s\n    uploadBinary: true\n  k0s:\n    version: v1.34.1+head\n    config:\n      spec:\n        network:\n          controlPlaneLoadBalancing:\n            enabled: true\n            type: Keepalived\n            keepalived:\n              vrrpInstances:\n              - virtualIPs: [\"192.168.122.200/24\"]\n                authPass: Example\n          nodeLocalLoadBalancing: # optional, but CPLB will often be used with NLLB.\n            enabled: true\n            type: EnvoyProxy\n</code></pre> <p>Save the above configuration into a file called <code>k0sctl.yaml</code> and apply it in order to bootstrap the cluster:</p> <pre><code>$ k0sctl apply\n\u2800\u28ff\u28ff\u2847\u2800\u2800\u2880\u28f4\u28fe\u28ff\u281f\u2801\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281b\u2801\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\n\u2800\u28ff\u28ff\u2847\u28e0\u28f6\u28ff\u287f\u280b\u2800\u2800\u2800\u28b8\u28ff\u2847\u2800\u2800\u2800\u28e0\u2800\u2800\u2880\u28e0\u2846\u28b8\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n\u2800\u28ff\u28ff\u28ff\u28ff\u28df\u280b\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u2847\u2800\u28b0\u28fe\u28ff\u2800\u2800\u28ff\u28ff\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n\u2800\u28ff\u28ff\u284f\u283b\u28ff\u28f7\u28e4\u2840\u2800\u2800\u2800\u2838\u281b\u2801\u2800\u2838\u280b\u2801\u2800\u2800\u28ff\u28ff\u2847\u2808\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u28b9\u28ff\u28ff\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n\u2800\u28ff\u28ff\u2847\u2800\u2800\u2819\u28bf\u28ff\u28e6\u28c0\u2800\u2800\u2800\u28e0\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28ff\u28ff\u2847\u28b0\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28fe\u28ff\u28ff\u2800\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\nk0sctl v0.21.0 Copyright 2023, k0sctl authors.\nINFO ==&gt; Running phase: Connect to hosts\nINFO [ssh] worker-2.k0s.lab:22: connected\nINFO [ssh] controller-2.k0s.lab:22: connected\nINFO [ssh] worker-1.k0s.lab:22: connected\nINFO [ssh] worker-0.k0s.lab:22: connected\nINFO [ssh] controller-0.k0s.lab:22: connected\nINFO [ssh] controller-1.k0s.lab:22: connected\nINFO ==&gt; Running phase: Detect host operating systems\nINFO [ssh] worker-2.k0s.lab:22: is running Fedora Linux 38 (Cloud Edition)\nINFO [ssh] controller-2.k0s.lab:22: is running Fedora Linux 38 (Cloud Edition)\nINFO [ssh] controller-0.k0s.lab:22: is running Fedora Linux 38 (Cloud Edition)\nINFO [ssh] controller-1.k0s.lab:22: is running Fedora Linux 38 (Cloud Edition)\nINFO [ssh] worker-0.k0s.lab:22: is running Fedora Linux 38 (Cloud Edition)\nINFO [ssh] worker-1.k0s.lab:22: is running Fedora Linux 38 (Cloud Edition)\nINFO ==&gt; Running phase: Acquire exclusive host lock\nINFO ==&gt; Running phase: Prepare hosts\nINFO ==&gt; Running phase: Gather host facts\nINFO [ssh] worker-2.k0s.lab:22: using worker-2.k0s.lab as hostname\nINFO [ssh] controller-0.k0s.lab:22: using controller-0.k0s.lab as hostname\nINFO [ssh] controller-2.k0s.lab:22: using controller-2.k0s.lab as hostname\nINFO [ssh] controller-1.k0s.lab:22: using controller-1.k0s.lab as hostname\nINFO [ssh] worker-1.k0s.lab:22: using worker-1.k0s.lab as hostname\nINFO [ssh] worker-0.k0s.lab:22: using worker-0.k0s.lab as hostname\nINFO [ssh] worker-2.k0s.lab:22: discovered eth0 as private interface\nINFO [ssh] controller-0.k0s.lab:22: discovered eth0 as private interface\nINFO [ssh] controller-2.k0s.lab:22: discovered eth0 as private interface\nINFO [ssh] controller-1.k0s.lab:22: discovered eth0 as private interface\nINFO [ssh] worker-1.k0s.lab:22: discovered eth0 as private interface\nINFO [ssh] worker-0.k0s.lab:22: discovered eth0 as private interface\nINFO [ssh] worker-2.k0s.lab:22: discovered 192.168.122.210 as private address\nINFO [ssh] controller-0.k0s.lab:22: discovered 192.168.122.37 as private address\nINFO [ssh] controller-2.k0s.lab:22: discovered 192.168.122.87 as private address\nINFO [ssh] controller-1.k0s.lab:22: discovered 192.168.122.185 as private address\nINFO [ssh] worker-1.k0s.lab:22: discovered 192.168.122.81 as private address\nINFO [ssh] worker-0.k0s.lab:22: discovered 192.168.122.219 as private address\nINFO ==&gt; Running phase: Validate hosts\nINFO ==&gt; Running phase: Validate facts\nINFO ==&gt; Running phase: Download k0s binaries to local host\nINFO ==&gt; Running phase: Upload k0s binaries to hosts\nINFO [ssh] controller-0.k0s.lab:22: uploading k0s binary from /opt/k0s\nINFO [ssh] controller-2.k0s.lab:22: uploading k0s binary from /opt/k0s\nINFO [ssh] worker-0.k0s.lab:22: uploading k0s binary from /opt/k0s\nINFO [ssh] controller-1.k0s.lab:22: uploading k0s binary from /opt/k0s\nINFO [ssh] worker-1.k0s.lab:22: uploading k0s binary from /opt/k0s\nINFO [ssh] worker-2.k0s.lab:22: uploading k0s binary from /opt/k0s\nINFO ==&gt; Running phase: Install k0s binaries on hosts\nINFO [ssh] controller-0.k0s.lab:22: validating configuration\nINFO [ssh] controller-1.k0s.lab:22: validating configuration\nINFO [ssh] controller-2.k0s.lab:22: validating configuration\nINFO ==&gt; Running phase: Configure k0s\nINFO [ssh] controller-0.k0s.lab:22: installing new configuration\nINFO [ssh] controller-2.k0s.lab:22: installing new configuration\nINFO [ssh] controller-1.k0s.lab:22: installing new configuration\nINFO ==&gt; Running phase: Initialize the k0s cluster\nINFO [ssh] controller-0.k0s.lab:22: installing k0s controller\nINFO [ssh] controller-0.k0s.lab:22: waiting for the k0s service to start\nINFO [ssh] controller-0.k0s.lab:22: waiting for kubernetes api to respond\nINFO ==&gt; Running phase: Install controllers\nINFO [ssh] controller-2.k0s.lab:22: validating api connection to https://192.168.122.200:6443\nINFO [ssh] controller-1.k0s.lab:22: validating api connection to https://192.168.122.200:6443\nINFO [ssh] controller-0.k0s.lab:22: generating token\nINFO [ssh] controller-1.k0s.lab:22: writing join token\nINFO [ssh] controller-1.k0s.lab:22: installing k0s controller\nINFO [ssh] controller-1.k0s.lab:22: starting service\nINFO [ssh] controller-1.k0s.lab:22: waiting for the k0s service to start\nINFO [ssh] controller-1.k0s.lab:22: waiting for kubernetes api to respond\nINFO [ssh] controller-0.k0s.lab:22: generating token\nINFO [ssh] controller-2.k0s.lab:22: writing join token\nINFO [ssh] controller-2.k0s.lab:22: installing k0s controller\nINFO [ssh] controller-2.k0s.lab:22: starting service\nINFO [ssh] controller-2.k0s.lab:22: waiting for the k0s service to start\nINFO [ssh] controller-2.k0s.lab:22: waiting for kubernetes api to respond\nINFO ==&gt; Running phase: Install workers\nINFO [ssh] worker-2.k0s.lab:22: validating api connection to https://192.168.122.200:6443\nINFO [ssh] worker-1.k0s.lab:22: validating api connection to https://192.168.122.200:6443\nINFO [ssh] worker-0.k0s.lab:22: validating api connection to https://192.168.122.200:6443\nINFO [ssh] controller-0.k0s.lab:22: generating a join token for worker 1\nINFO [ssh] controller-0.k0s.lab:22: generating a join token for worker 2\nINFO [ssh] controller-0.k0s.lab:22: generating a join token for worker 3\nINFO [ssh] worker-2.k0s.lab:22: writing join token\nINFO [ssh] worker-0.k0s.lab:22: writing join token\nINFO [ssh] worker-1.k0s.lab:22: writing join token\nINFO [ssh] worker-2.k0s.lab:22: installing k0s worker\nINFO [ssh] worker-1.k0s.lab:22: installing k0s worker\nINFO [ssh] worker-0.k0s.lab:22: installing k0s worker\nINFO [ssh] worker-2.k0s.lab:22: starting service\nINFO [ssh] worker-1.k0s.lab:22: starting service\nINFO [ssh] worker-0.k0s.lab:22: starting service\nINFO [ssh] worker-2.k0s.lab:22: waiting for node to become ready\nINFO [ssh] worker-0.k0s.lab:22: waiting for node to become ready\nINFO [ssh] worker-1.k0s.lab:22: waiting for node to become ready\nINFO ==&gt; Running phase: Release exclusive host lock\nINFO ==&gt; Running phase: Disconnect from hosts\nINFO ==&gt; Finished in 2m20s\nINFO k0s cluster version v1.34.1+head is now installed\nINFO Tip: To access the cluster you can now fetch the admin kubeconfig using:\nINFO      k0sctl kubeconfig\n</code></pre> <p>The cluster with the two nodes should be available by now. Setup the kubeconfig file in order to interact with it:</p> <pre><code>k0sctl kubeconfig &gt; k0s-kubeconfig\nexport KUBECONFIG=$(pwd)/k0s-kubeconfig\n</code></pre> <p>All three worker nodes are ready:</p> <pre><code>$ kubectl get nodes\nNAME                   STATUS   ROLES           AGE     VERSION\nworker-0.k0s.lab       Ready    &lt;none&gt;          8m51s   v1.34.1+k0s\nworker-1.k0s.lab       Ready    &lt;none&gt;          8m51s   v1.34.1+k0s\nworker-2.k0s.lab       Ready    &lt;none&gt;          8m51s   v1.34.1+k0s\n</code></pre> <p>Only one controller has the VIP:</p> <pre><code>$ for i in controller-{0..2} ; do echo $i ; ssh $i -- ip -4 --oneline addr show | grep eth0; done\ncontroller-0\n2: eth0    inet 192.168.122.37/24 brd 192.168.122.255 scope global dynamic noprefixroute eth0\\       valid_lft 2381sec preferred_lft 2381sec\n2: eth0    inet 192.168.122.200/24 scope global secondary eth0\\       valid_lft forever preferred_lft forever\ncontroller-1\n2: eth0    inet 192.168.122.185/24 brd 192.168.122.255 scope global dynamic noprefixroute eth0\\       valid_lft 2390sec preferred_lft 2390sec\ncontroller-2\n2: eth0    inet 192.168.122.87/24 brd 192.168.122.255 scope global dynamic noprefixroute eth0\\       valid_lft 2399sec preferred_lft 2399sec\n</code></pre> <p>The cluster is using control plane load balancing and is able to tolerate the outage of one controller node. Shutdown the first controller to simulate a failure condition:</p> <pre><code>$ ssh controller-0 'sudo poweroff'\nConnection to 192.168.122.37 closed by remote host.\n</code></pre> <p>Control plane load balancing provides high availability, the VIP will have moved to a different node:</p> <pre><code>$ for i in controller-{1..2} ; do echo $i ; ssh $i -- ip -4 --oneline addr show | grep eth0; done\ncontroller-1\n2: eth0    inet 192.168.122.185/24 brd 192.168.122.255 scope global dynamic noprefixroute eth0\\       valid_lft 2173sec preferred_lft 2173sec\n2: eth0    inet 192.168.122.200/24 scope global secondary eth0\\       valid_lft forever preferred_lft forever\ncontroller-2\n2: eth0    inet 192.168.122.87/24 brd 192.168.122.255 scope global dynamic noprefixroute eth0\\       valid_lft 2182sec preferred_lft 2182sec\n````\n\nAnd the cluster will be working normally:\n\n```console\n$ kubectl get nodes\nNAME                   STATUS   ROLES           AGE     VERSION\nworker-0.k0s.lab       Ready    &lt;none&gt;          8m51s   v1.34.1+k0s\nworker-1.k0s.lab       Ready    &lt;none&gt;          8m51s   v1.34.1+k0s\nworker-2.k0s.lab       Ready    &lt;none&gt;          8m51s   v1.34.1+k0s\n</code></pre>"},{"location":"cplb/#troubleshooting","title":"Troubleshooting","text":"<p>Although Virtual IP addresses and load balancing work together and are closely related, these are two independent processes and must be troubleshooting as two independent features.</p>"},{"location":"cplb/#troubleshooting-virtual-ips","title":"Troubleshooting Virtual IPs","text":"<p>The first thing to check is that the VIP is present in exactly one node at a time, for instance if a cluster has an <code>172.17.0.102/16</code> address and the interface is <code>eth0</code>, the expected output is similar to:</p> <pre><code>controller0:/# ip a s eth0\n53: eth0@if54: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP\n    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n    inet 172.17.0.102/16 scope global secondary eth0\n       valid_lft forever preferred_lft forever\n</code></pre> <pre><code>controller1:/# ip a s eth0\n55: eth0@if56: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP\n    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n</code></pre> <p>If the <code>virtualServers</code> feature is used, there must be a dummy interface on the node called <code>dummyvip0</code> which has the VIP, but with a <code>/32</code> bits network mask. This isn't the VIP and has to be there even if the VIP is held by another node.</p> <pre><code>controller0:/# ip a s dummyvip0 | grep 172.17.0.102\n    inet 172.17.0.102/32 scope global dummyvip0\n</code></pre> <pre><code>controller1:/# ip a s dummyvip0 | grep 172.17.0.102\n    inet 172.17.0.102/32 scope global dummyvip0\n</code></pre> <p>If this isn't present in the nodes, keepalived logs can be seen in the k0s-logs, and can be filtered with <code>component=keepalived</code>.</p> <pre><code>controller0:/# journalctl -u k0scontroller | grep component=keepalived\ntime=\"2024-11-19 12:56:11\" level=info msg=\"Starting to supervise\" component=keepalived\ntime=\"2024-11-19 12:56:11\" level=info msg=\"Started successfully, go nuts pid 409\" component=keepalived\ntime=\"2024-11-19 12:56:11\" level=info msg=\"Tue Nov 19 12:56:11 2024: Starting Keepalived v2.3.4\" component=keepalived stream=stderr\n[...]\n</code></pre> <p>The Keepalived configuration is stored in a file called <code>keepalived.conf</code> in the k0s run directory, by default <code>/run/k0s/keepalived.conf</code>, in this file there should be a <code>vrrp_instance</code> section for each <code>vrrpInstance</code>.</p> <p>Finally, k0s should have two keepalived processes running.</p>"},{"location":"cplb/#troubleshooting-the-load-balancers-endpoint-list","title":"Troubleshooting the Load Balancer's Endpoint List","text":"<p>Both the user space reverse proxy load balancer and Keepalived's virtual servers need an endpoint list to do the load balancing. They share a component called <code>cplb-reconciler</code> which responsible for setting the load balancer's endpoint list. This component monitors constantly the endpoint <code>kubernetes</code> in the <code>default</code>namespace:</p> <pre><code>controller0:/# kubectl get ep kubernetes -n default\nNAME         ENDPOINTS                                         AGE\nkubernetes   172.17.0.6:6443,172.17.0.7:6443,172.17.0.8:6443   9m14s\n</code></pre> <p>You can see the <code>cplb-reconciler</code> updates by running:</p> <pre><code>controller0:/# journalctl -u k0scontroller | grep component=cplb-reconciler\ntime=\"2024-11-20 20:29:28\" level=error msg=\"Failed to watch API server endpoints, last observed version is \\\"\\\", starting over in 10s ...\" component=cplb-reconciler error=\"Get \\\"https://172.17.0.6:6443/api/v1/namespaces/default/endpoints?fieldSelector=metadata.name%3Dkubernetes&amp;timeout=30s&amp;timeoutSeconds=30\\\": dial tcp 172.17.0.6:6443: connect: connection refused\"\ntime=\"2024-11-20 20:29:38\" level=info msg=\"Updated the list of IPs: [172.17.0.6]\" component=cplb-reconciler\ntime=\"2024-11-20 20:29:55\" level=info msg=\"Updated the list of IPs: [172.17.0.6 172.17.0.7]\" component=cplb-reconciler\ntime=\"2024-11-20 20:29:59\" level=info msg=\"Updated the list of IPs: [172.17.0.6 172.17.0.7 172.17.0.8]\" component=cplb-reconciler\n</code></pre>"},{"location":"cplb/#troubleshooting-the-user-space-reverse-proxy-load-balancer","title":"Troubleshooting the user space reverse proxy load balancer","text":"<p>The user space reverse proxy load balancer runs in the k0s process. It listens a separate socket, by default on port 6444:</p> <pre><code>controller0:/# netstat -tlpn | grep 6444\ntcp        0      0 :::6444                 :::*                    LISTEN      345/k0s\n</code></pre> <p>Then the requests to the VIP on the apiserver port are forwarded to this socket using one iptables rule:</p> <pre><code>-A PREROUTING -d &lt;VIP&gt;/32 -p tcp -m tcp --dport &lt;apiserver port&gt; -j REDIRECT --to-ports &lt;userspace proxy port&gt;\n</code></pre> <p>A real life example of a cluster using the VIP <code>17.177.0.102</code> looks like:</p> <pre><code>controller0:/# /var/lib/k0s/bin/iptables-save | grep 6444\n-A PREROUTING -d 172.17.0.102/32 -p tcp -m tcp --dport 6443 -j REDIRECT --to-ports 6444\n</code></pre> <p>Keep in mind that clusters using IPv6 as a primary address family, should use ip6tables or ip6tables-save.</p> <p>It the load balancer is not load balancing for whatever reason, you can establish connections to it directly. A good way to see if it's actually load balancing is checking the serving certificate:</p> <pre><code>controller0:/# ip -o addr s eth0\n43: eth0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0\\       valid_lft forever preferred_lft forever\n43: eth0    inet 172.17.0.102/16 scope global secondary eth0\\       valid_lft forever preferred_lft forever\n\ncontroller0:/# openssl s_client -connect 172.17.0.102:6444  &lt;/dev/null 2&gt;/dev/null | openssl x509 -noout -fingerprint\nSHA1 Fingerprint=B7:90:E6:E4:E1:EE:5B:19:72:99:02:28:54:36:D9:84:D5:39:67:8B\ncontroller0:/# openssl s_client -connect 172.17.0.102:6444  &lt;/dev/null 2&gt;/dev/null | openssl x509 -noout -fingerprint\nSHA1 Fingerprint=89:94:5C:E5:50:7E:40:B2:E5:20:E7:70:E8:58:91:ED:63:B0:EC:65\ncontroller0:/# openssl s_client -connect 172.17.0.102:6444  &lt;/dev/null 2&gt;/dev/null | openssl x509 -noout -fingerprint\nSHA1 Fingerprint=49:0D:79:FD:79:6F:A0:E4:9D:BA:A1:65:9C:C5:54:CF:E5:20:BF:A8\ncontroller0:/# openssl s_client -connect 172.17.0.102:6444  &lt;/dev/null 2&gt;/dev/null | openssl x509 -noout -fingerprint\nSHA1 Fingerprint=B7:90:E6:E4:E1:EE:5B:19:72:99:02:28:54:36:D9:84:D5:39:67:8B\n</code></pre> <p>Note: You can't query the port 6444 on the localhost address, there is an iptables conflict. You are expected to be able to reach the port 6443 on any address and the port 6444 on any address except localhost.</p>"},{"location":"cplb/#troubleshooting-keepalived-virtual-servers","title":"Troubleshooting Keepalived Virtual Servers","text":"<p>You can verify the Keepalived logs and configuration file using the steps described in the section troubleshooting virtual IPs above.</p> <p>When virtual servers are enabled K0s generates two additional files:</p> <ul> <li><code>keepalived-virtualservers-generated.conf</code>: This file contains the list of control plane nodes that should be balanced to.</li> <li><code>keepalived-virtualservers-consumed.conf</code>: This is a symbolic link which points to <code>keepalived-virtualservers-generated.conf</code> if the Keepalived VRRP instance's current state is <code>master</code> or to <code>/dev/null</code> if it's <code>backup</code>. This file is only generated if there is exactly one VRRP instance.</li> </ul> <p>Additionally, you can check the actual IPVS configuration using <code>ipvsadm</code>:</p> <p><code>console controller0:/# ipvsadm --save -n IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags   -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn TCP  192.168.122.200:6443 rr persistent 360   -&gt; 192.168.122.185:6443              Route   1      0          0   -&gt; 192.168.122.87:6443               Route   1      0          0   -&gt; 192.168.122.122:6443              Route   1      0          0</code></p> <p>In this example <code>192.168.122.200</code> is the virtual IP, and <code>192.168.122.185</code>, <code>192.168.122.87</code>   and <code>192.168.122.122</code> are the control plane nodes.</p> <p>If there is only one VRRP instance, only the current master should be load balancing.</p>"},{"location":"custom-ca/","title":"Using custom CA certificate (advanced)","text":""},{"location":"custom-ca/#install-using-custom-ca-certificates-and-sa-key-pair","title":"Install using custom CA certificates and SA key pair","text":"<p>k0s generates all needed certificates automatically in the <code>&lt;data-dir&gt;/pki</code> directory (<code>/var/lib/k0s/pki</code>, by default).</p> <p>But sometimes there is a need to have the CA certificates and SA key pair in advance. To make it work, just put files to the <code>&lt;data-dir&gt;/pki</code> and <code>&lt;data-dir&gt;/pki/etcd</code>:</p> <pre><code>export LIFETIME=365\nmkdir -p /var/lib/k0s/pki/etcd\ncd /var/lib/k0s/pki\nopenssl genrsa -out ca.key 2048\nopenssl req -x509 -new -nodes -key ca.key -sha256 -days $LIFETIME -out ca.crt -subj \"/CN=Custom CA\"\nopenssl genrsa -out sa.key 2048\nopenssl rsa -in sa.key -outform PEM -pubout -out sa.pub\ncd ./etcd\nopenssl genrsa -out ca.key 2048\nopenssl req -x509 -new -nodes -key ca.key -sha256 -days $LIFETIME -out ca.crt -subj \"/CN=Custom CA\"\n</code></pre> <p>Then you can install k0s as usual.</p>"},{"location":"custom-ca/#pre-generated-tokens","title":"Pre-generated tokens","text":"<p>It's possible to get join in advance without having a running cluster.</p> <pre><code>k0s token pre-shared --role worker --cert /var/lib/k0s/pki/ca.crt --url https://&lt;controller-ip&gt;:6443/\n</code></pre> <p>The command above generates a join token and a Secret. A Secret should be deployed to the cluster to authorize the token. For example, you can put the Secret under the manifest directory and it will be deployed automatically.</p> <p>Please note that if you are generating a join token for a controller, the port number needs to be 9443 instead of 6443. Controller bootstrapping requires talking to the k0s API server instead of the Kubernetes API server. Here's an example of a command for pre-generating a token for a controller.</p> <pre><code>k0s token pre-shared --role controller --cert /var/lib/k0s/pki/ca.crt --url https://&lt;controller-ip&gt;:9443/\n</code></pre>"},{"location":"custom-ca/#see-also","title":"See also","text":"<ul> <li>Certificate Authorities</li> </ul>"},{"location":"custom-cri-runtime/","title":"Custom cri runtime","text":"<p>See runtime.</p>"},{"location":"dual-stack/","title":"IPv4/IPv6 dual-stack networking","text":""},{"location":"dual-stack/#ipv4ipv6-dual-stack-networking","title":"IPv4/IPv6 dual-stack networking","text":"<p>Enabling dual-stack networking in k0s allows your cluster to handle both IPv4 and IPv6 addresses. Follow the configuration examples below to set up dual-stack mode.</p>"},{"location":"dual-stack/#enabling-dual-stack-using-the-default-cni-kube-router","title":"Enabling dual-stack using the default CNI (Kube-router)","text":"<p>In order to enable dual-stack networking using the default CNI provider, use the following example configuration:</p> <pre><code>spec:\n  network:\n    # Kube-router is the default CNI provider\n    # provider: kube-router\n    podCIDR: 10.244.0.0/16\n    serviceCIDR: 10.96.0.0/12\n    dualStack:\n      enabled: true\n      IPv6podCIDR: fd00::/108\n      IPv6serviceCIDR: fd01::/108\n</code></pre> <p>This configuration will set up all Kubernetes components and Kube-router accordingly for dual-stack networking.</p>"},{"location":"dual-stack/#configuring-the-node-cidr-mask-size","title":"Configuring the node CIDR mask size","text":"<p>By default, k0s uses a <code>/117</code> node CIDR mask size for IPv6, which provides 2048 IP addresses per node and a <code>/24</code> for IPv4 which provides 256 addresses per node.</p> <p>For IPv6, using the example configuration <code>IPv6PodCIDR: fd00::/108</code>, there are 9 bits available for node allocation (117 - 108 = 9) and 11 bits available for pod allocation (128 - 117 = 11). This allows for 512 nodes per cluster and 2048 IPs per node.</p> <p>For IPv4, using the default <code>PodCIDR: 10.244.0.0/16</code>, there are 8 bits available for node allocation and 8 bits available for pod allocation. This allows for 256 nodes per cluster and 256 IPs per node. per cluster and 256 IPs per node.</p> <p>You can customize the node CIDR mask size using the controller manager's extra arguments:</p> <pre><code>spec:\n  controllerManager:\n    extraArgs:\n      node-cidr-mask-size-ipv6: \"120\"\n      node-cidr-mask-size-ipv4: \"21\"\n  network:\n    dualStack:\n      enabled: true\n      IPv6podCIDR: fd00::/108\n      IPv6serviceCIDR: fd01::/108\n</code></pre>"},{"location":"dual-stack/#using-calico-as-the-cni-provider","title":"Using Calico as the CNI provider","text":"<p>Calico does not support IPv6 tunneling in the default <code>vxlan</code> mode, so if you prefer to use Calico as your CNI provider, make sure to select <code>bird</code> mode. Use the following example configuration:</p> <pre><code>spec:\n  network:\n    provider: calico\n    calico:\n      mode: bird\n    podCIDR: 10.244.0.0/16\n    serviceCIDR: 10.96.0.0/12\n    dualStack:\n      enabled: true\n      IPv6podCIDR: fd00::/108\n      IPv6serviceCIDR: fd01::/108\n</code></pre>"},{"location":"dual-stack/#specifying-the-default-ip-family","title":"Specifying the default IP family","text":"<p>In Kubernetes dual stack clusters, by default all the services are single stack, including <code>kubernetes.default.svc</code>, which is used to communicate with the Kubernetes API servers.</p> <p>This is specially important when specifying explicitly <code>spec.api.externalAddress</code> or <code>spec.api.address</code>.</p> <p>To explicitly define the family which will be used by default use the following configuration:</p> <pre><code>spec:\n  network:\n    # primaryAddressFamily is optional\n    primaryAddressFamily: &lt;IPv4|IPv6&gt;\n</code></pre> <p>If not defined explicitly, k0s will determine it based on <code>spec.api.externalAddress</code>, if this field is not defined, k0s will use <code>spec.api.address</code>. If the field used is a host name or both are empty, k0s will use IPv4.</p>"},{"location":"dual-stack/#custom-cni-providers","title":"Custom CNI providers","text":"<p>While the dual-stack configuration section configures all components managed by k0s for dual-stack operation, the custom CNI provider must also be configured accordingly. Refer to the documentation for your specific CNI provider to ensure a proper dual-stack setup that matches that of k0s.</p>"},{"location":"dual-stack/#additional-resources","title":"Additional Resources","text":"<p>For more detailed information and troubleshooting, refer to the following resources:</p> <ul> <li>https://kubernetes.io/docs/concepts/services-networking/dual-stack/</li> <li>https://kubernetes.io/docs/tasks/network/validate-dual-stack/</li> <li>https://www.tigera.io/blog/dual-stack-operation-with-calico-on-kubernetes/</li> <li>https://docs.tigera.io/calico/3.27/networking/ipam/ipv6#enable-dual-stack</li> </ul>"},{"location":"dynamic-configuration/","title":"Dynamic Configuration","text":""},{"location":"dynamic-configuration/#dynamic-configuration","title":"Dynamic configuration","text":"<p>k0s comes with the option to enable dynamic configuration for cluster level components. This covers all the components other than etcd (or SQLite) and the Kubernetes API server. This option enables k0s configuration directly via Kubernetes API as opposed to using a configuration file for all cluster configuration.</p> <p>This feature has to be enabled for every controller in the cluster using the <code>--enable-dynamic-config</code> flag in <code>k0s controller</code> or <code>k0s install controller</code> commands. Having both types of controllers in the same cluster will cause a conflict.</p>"},{"location":"dynamic-configuration/#dynamic-vs-static-configuration","title":"Dynamic vs. static configuration","text":"<p>The existing and enabled-by-default method is what we call static configuration. That's the way where the k0s process reads the config from the given YAML file (or uses the default config if no config is given by user) and configures every component accordingly. This means that for any configuration change the cluster admin has to restart all controllers on the cluster and have matching configs on each controller node.</p> <p>In dynamic configuration mode the first controller to boot up when the cluster is created will use the given config YAML as a bootstrap configuration and stores it in the Kubernetes API. All the other controllers will find the config existing on the API and will use it as the source-of-truth for configuring all the components except for etcd and Kubernetes API server. After the initial cluster bootstrap the source of truth for all controllers is the configuration object in the Kubernetes API.</p>"},{"location":"dynamic-configuration/#cluster-configuration-vs-controller-node-configuration","title":"Cluster configuration vs. controller node configuration","text":"<p>In the k0s configuration options there are some options that are cluster-wide and some that are specific to each controller node in the cluster. The following list outlines which options are controller node specific and have to be configured only via the local file:</p> <ul> <li><code>spec.api</code> - these options configure how the local Kubernetes API server is setup</li> <li><code>spec.storage</code> - these options configure how the local storage (etcd or SQLite) is setup</li> <li><code>spec.network.controlPlaneLoadBalancing</code> - these options configure how to setup Control Plane Load Balancing.</li> </ul> <p>In case of an HA control plane, all the controllers will need this part of the configuration as otherwise they will not be able to get the storage and Kubernetes API server running.</p>"},{"location":"dynamic-configuration/#configuration-location","title":"Configuration location","text":"<p>The cluster wide configuration is stored in the Kubernetes API as a custom resource called <code>clusterconfig</code>. There's currently only one instance named <code>k0s</code>. You can edit the configuration with what ever means possible, for example with:</p> <pre><code>k0s config edit\n</code></pre> <p>This will open the configuration object for editing in your system's default editor.</p>"},{"location":"dynamic-configuration/#configuration-reconciliation","title":"Configuration reconciliation","text":"<p>The dynamic configuration uses the typical operator pattern for operation. k0s controller will detect when the object changes and will reconcile the configuration changes to be reflected to how different components are configured. So say you want to change the MTU setting for Kube-router CNI networking you'd change the config to contain e.g.:</p> <pre><code>    kuberouter:\n      mtu: 1350\n      autoMTU: false\n</code></pre> <p>This will change the Kube-router related ConfigMap and thus make Kube-router to use different MTU settings for new pods.</p>"},{"location":"dynamic-configuration/#configuration-options","title":"Configuration options","text":"<p>The configuration object is a 1-to-1 mapping with the existing configuration YAML. All the configuration options EXCEPT options under <code>spec.api</code> and <code>spec.storage</code> are dynamically reconciled.</p> <p>As with any Kubernetes cluster there are certain things that just cannot be changed on-the-fly, this is the list of non-changeable options:</p> <ul> <li><code>network.podCIDR</code></li> <li><code>network.serviceCIDR</code></li> <li><code>network.provider</code></li> <li><code>network.controlPlaneLoadBalancing</code></li> <li><code>network.primaryAddressFamily</code></li> </ul> <p>During the manual installation of control plane nodes with <code>k0s install</code>, all these non-changeable options must be defined in the configuration file. This is necessary because these fields can be used before the dynamic configuration reconciler is initialized. Both k0sctl and k0smotron handle this without user intervention.</p>"},{"location":"dynamic-configuration/#configuration-status","title":"Configuration status","text":"<p>The dynamic configuration reconciler operator will write status events for all the changes it detects. To see all dynamic config related events, use:</p> <pre><code>k0s config status\n</code></pre> <pre><code>LAST SEEN   TYPE      REASON                OBJECT              MESSAGE\n64s         Warning   FailedReconciling     clusterconfig/k0s   failed to validate config: [invalid pod CIDR invalid ip address]\n59s         Normal    SuccessfulReconcile   clusterconfig/k0s   Successfully reconciler cluster config\n69s         Warning   FailedReconciling     clusterconfig/k0s   cannot change CNI provider from kuberouter to calico\n</code></pre>"},{"location":"environment-variables/","title":"Configuration of Environment Variables","text":""},{"location":"environment-variables/#environment-variables","title":"Environment variables","text":"<p><code>k0s install</code> does not support environment variables.</p> <p>Setting environment variables for components used by k0s depends on the used init system. The environment variables set in <code>k0scontroller</code> or <code>k0sworker</code> service will be inherited by k0s components, such as <code>etcd</code>, <code>containerd</code>, <code>konnectivity</code>, etc.</p> <p>Component specific environment variables can be set in <code>k0scontroller</code> or <code>k0sworker</code> service. For example: for <code>CONTAINERD_HTTPS_PROXY</code>, the prefix <code>CONTAINERD_</code> will be stripped and converted to <code>HTTPS_PROXY</code> in the <code>containerd</code> process.</p> <p>For those components having environment prefix convention such as <code>ETCD_xxx</code>, they are handled specially, i.e. the prefix will not be stripped. For example, <code>ETCD_MAX_WALS</code> will still be <code>ETCD_MAX_WALS</code> in etcd process.</p> <p>The proxy environment variables <code>HTTP_PROXY</code>, <code>HTTPS_PROXY</code>, <code>NO_PROXY</code> are always overridden by component specific environment variables, so <code>ETCD_HTTPS_PROXY</code> will still be converted to <code>HTTPS_PROXY</code> in etcd process.</p>"},{"location":"environment-variables/#systemd","title":"systemd","text":"<p>Create a drop-in directory and add config file with a desired environment variable:</p> <pre><code>mkdir -p /etc/systemd/system/k0scontroller.service.d\ntee -a /etc/systemd/system/k0scontroller.service.d/http-proxy.conf &lt;&lt;EOT\n[Service]\nEnvironment=HTTP_PROXY=192.168.33.10:3128\nEOT\n</code></pre>"},{"location":"environment-variables/#openrc","title":"OpenRC","text":"<p>Export the desired environment variable overriding service configuration in the <code>/etc/conf.d</code> directory:</p> <pre><code>echo 'export HTTP_PROXY=\"192.168.33.10:3128\"' &gt; /etc/conf.d/k0scontroller\n</code></pre>"},{"location":"experimental-windows/","title":"Windows (experimental)","text":""},{"location":"experimental-windows/#run-k0s-worker-nodes-in-windows","title":"Run k0s worker nodes in Windows","text":"<p>IMPORTANT: Windows support for k0s is under active development and must be considered experimental.</p>"},{"location":"experimental-windows/#prerequisites","title":"Prerequisites","text":"<p>The cluster must be running at least one worker node and control plane on Linux. You can use Windows to run additional worker nodes.</p>"},{"location":"experimental-windows/#run-k0s","title":"Run k0s","text":"<p>Note: k0s supervises <code>kubelet.exe</code> and <code>kube-proxy.exe</code>.</p> <p>During the first run, the Calico install script is created as <code>C:\\bootstrap.ps1</code>. This bootstrap script downloads the Calico binaries, builds pause container and sets up vSwitch settings.</p> <p>Install Mirantis Container Runtime on the Windows node(s), as it is required for the initial Calico set up.</p> <pre><code>k0s worker --cri-socket=remote:npipe:////./pipe/containerd-containerd &lt;token&gt;\n</code></pre> <p>You must initiate the cluster control with the correct config.</p>"},{"location":"experimental-windows/#configuration","title":"Configuration","text":""},{"location":"experimental-windows/#strict-affinity","title":"Strict-affinity","text":"<p>You must enable strict affinity to run the windows node.</p> <p>If the <code>spec.network.Calico.withWindowsNodes</code> field is set to <code>true</code> (it is set to <code>false</code> by default) the additional Calico related manifest <code>/var/lib/k0s/manifests/calico/calico-IPAMConfig-ipamconfig.yaml</code> is created with the following values:</p> <pre><code>---\napiVersion: crd.projectcalico.org/v1\nkind: IPAMConfig\nmetadata:\n  name: default\nspec:\n  strictAffinity: true\n</code></pre> <p>Alternately, you can manually execute <code>calicoctl</code>:</p> <pre><code>calicoctl ipam configure --strictaffinity=true\n</code></pre>"},{"location":"experimental-windows/#network-connectivity-in-aws","title":"Network connectivity in AWS","text":"<p>Disable the <code>Change Source/Dest. Check</code> option for the network interface attached to your EC2 instance. In AWS, the console option for the network interface is in the Actions menu.</p>"},{"location":"experimental-windows/#useful-commands","title":"Useful commands","text":""},{"location":"experimental-windows/#run-pod-with-cmdexe-shell","title":"Run pod with cmd.exe shell","text":"<pre><code>kubectl run win --image=hello-world:nanoserver --command=true -i --attach=true -- cmd.exe\n</code></pre>"},{"location":"experimental-windows/#manifest-for-pod-with-iis-web-server","title":"Manifest for pod with IIS web-server","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: iis\nspec:\n  containers:\n  - name: iis\n    image: mcr.microsoft.com/windows/servercore/iis\n    imagePullPolicy: IfNotPresent\n</code></pre>"},{"location":"extensions/","title":"Extensions","text":""},{"location":"extensions/#cluster-extensions","title":"Cluster extensions","text":"<p>k0s allows users to use extensions to extend cluster functionality.</p> <p>At the moment the only supported type of extensions is helm based charts.</p> <p>The default configuration has no extensions.</p>"},{"location":"extensions/#helm-based-extensions","title":"Helm based extensions","text":""},{"location":"extensions/#configuration-example","title":"Configuration example","text":"<pre><code>helm:\n  repositories:\n  - name: stable\n    url: https://charts.helm.sh/stable\n  - name: prometheus-community\n    url: https://prometheus-community.github.io/helm-charts\n  - name: oci-registry-with-private-ca\n    # OCI registry URL must not include any path elements\n    url: oci://registry-with-private-ca.com:8080\n    # Currently, only caFile is supported for TLS transport\n    # Setting certFile or keyFile will result in an error\n    caFile: /path/to/ca.crt\n  charts:\n  - name: prometheus-stack\n    chartname: prometheus-community/prometheus\n    version: \"11.16.8\"\n    values: |\n      storageSpec:\n        emptyDir:\n          medium: Memory\n    namespace: default\n  # We don't need to specify the repo in the repositories section for OCI charts\n  # unless a custom TLS transport is needed\n  - name: oci-chart\n    chartname: oci://registry:8080/chart\n    version: \"0.0.1\"\n    values: \"\"\n    namespace: default\n  # OCI charts that require a custom TLS transport must add a repository entry \n  # pointing to TLS certificates on the controller node.\n  # In this case, chartname of the chart must include the same registry URL \n  # previously defined in the repository URL.\n  - name: oci-chart-with-tls\n    chartname: oci://registry-with-private-ca.com:8080/chart\n    version: \"0.0.1\"\n    values: \"\"\n    namespace: default\n  # Other way is to use local tgz file with chart\n  # the file must exist all controller nodes\n  - name: tgz-chart\n    chartname: /tmp/chart.tgz\n    version: \"0.0.1\"\n    values: \"\"\n    namespace: default\n</code></pre> <p>By using the configuration above, the cluster would:</p> <ul> <li>add stable and prometheus-community chart repositories</li> <li>install the <code>prometheus-community/prometheus</code> chart of the specified version to the <code>default</code> namespace.</li> </ul> <p>The chart installation is implemented by using CRD <code>helm.k0sproject.io/Chart</code>. For every given helm extension the cluster creates a Chart CRD instance. The cluster has a controller which monitors for the Chart CRDs, supporting the following operations:</p> <ul> <li>install</li> <li>upgrade</li> <li>delete</li> </ul> <p>For security reasons, the cluster operates only on Chart CRDs instantiated in the <code>kube-system</code> namespace, however, the target namespace could be any.</p>"},{"location":"extensions/#crd-definition","title":"CRD definition","text":"<pre><code>apiVersion: helm.k0sproject.io/v1beta1\nkind: Chart\nmetadata:\n  creationTimestamp: \"2020-11-10T14:17:53Z\"\n  generation: 2\n  labels:\n    k0s.k0sproject.io/stack: helm\n  name: k0s-addon-chart-test-addon\n  namespace: kube-system\n  resourceVersion: \"627\"\n  selfLink: /apis/helm.k0sproject.io/v1beta1/namespaces/kube-system/charts/k0s-addon-chart-test-addon\n  uid: ebe59ed4-1ff8-4d41-8e33-005b183651ed\nspec:\n  chartName: prometheus-community/prometheus\n  namespace: default\n  values: |\n    storageSpec:\n      emptyDir:\n        medium: Memory\n  version: 11.16.8\nstatus:\n  appVersion: 2.21.0\n  namespace: default\n  releaseName: prometheus-1605017878\n  revision: 2\n  updated: 2020-11-10 14:18:08.235656 +0000 UTC m=+41.871656901\n  version: 11.16.8\n</code></pre> <p>The <code>Chart.spec</code> defines the chart information.</p> <p>The <code>Chart.status</code> keeps the information about the last operation performed by the operator.</p>"},{"location":"external-runtime-deps/","title":"External runtime dependencies","text":""},{"location":"external-runtime-deps/#external-runtime-dependencies","title":"External runtime dependencies","text":"<p>k0s is packaged as a single binary, which includes all the needed components. All the binaries are statically linked which means that in typical use cases there's an absolute minimum of external runtime dependencies.</p> <p>However, depending on the node role and cluster configuration, some of the underlying components may have specific dependencies, like OS level tools, packages and libraries. This page aims to provide a comprehensive overview.</p> <p>The following command checks for known requirements on a host (currently only available on Linux):</p> <pre><code>k0s sysinfo\n</code></pre>"},{"location":"external-runtime-deps/#linux-specific","title":"Linux specific","text":""},{"location":"external-runtime-deps/#linux-kernel-configuration","title":"Linux kernel configuration","text":"<p>Needless to say, as k0s operates Kubernetes worker nodes, a certain number of Linux kernel modules and configurations are required on the host. This essentially stems from the requirement to run containers and set up networking for them.</p> <p>The needed kernel configuration items are listed below. All of them are available in Kernel versions 4.3 and above. If running on older kernels, check if the distro in use has backported some features; nevertheless, it might meet the requirements. k0s will check the Linux kernel release as part of its pre-flight checks and issue a warning if it's below 3.10.</p> <p>The list covers ONLY the k0s/Kubernetes components' needs on worker nodes. Your own workloads may require more.</p> <ul> <li><code>CONFIG_CGROUPS</code>:   Control Group support<ul> <li><code>CONFIG_CGROUP_SCHED</code>:   Group CPU scheduler<ul> <li><code>CONFIG_FAIR_GROUP_SCHED</code>:   Group scheduling for SCHED_OTHER kubernetes/kubeadm#2335 (comment)<ul> <li>(optional) <code>CONFIG_CFS_BANDWIDTH</code>:   CPU bandwidth provisioning for FAIR_GROUP_SCHED   Required if CPU CFS quota enforcement is enabled for containers that   specify CPU limits (<code>--cpu-cfs-quota</code>).</li> </ul> </li> </ul> </li> <li>(optional) <code>CONFIG_BLK_CGROUP</code>:   Block IO controller kubernetes/kubernetes#92287 (comment)</li> </ul> </li> <li><code>CONFIG_NAMESPACES</code>:   Namespaces support<ul> <li><code>CONFIG_UTS_NS</code>:   UTS namespace</li> <li><code>CONFIG_IPC_NS</code>:   IPC namespace</li> <li><code>CONFIG_PID_NS</code>:   PID namespace</li> <li><code>CONFIG_NET_NS</code>:   Network namespace</li> </ul> </li> <li><code>CONFIG_NET</code>:   Networking support<ul> <li><code>CONFIG_INET</code>:   TCP/IP networking</li> <li><code>CONFIG_NETFILTER</code>:   Network packet filtering framework (Netfilter)<ul> <li>(optional) <code>CONFIG_NETFILTER_ADVANCED</code>:   Advanced netfilter configuration</li> <li><code>CONFIG_NETFILTER_XTABLES</code>:   Netfilter Xtables support<ul> <li><code>CONFIG_NETFILTER_XT_TARGET_REDIRECT</code>:   REDIRECT target support</li> <li><code>CONFIG_NETFILTER_XT_MATCH_COMMENT</code>:   \"comment\" match support</li> </ul> </li> </ul> </li> </ul> </li> <li><code>CONFIG_EXT4_FS</code>:   The Extended 4 (ext4) filesystem</li> <li><code>CONFIG_PROC_FS</code>:   /proc file system support</li> </ul> <p>Note: As part of its pre-flight checks, k0s will try to inspect and validate the kernel configuration. In order for that to succeed, the configuration needs to be accessible at runtime. There are some typical places that k0s will check. A bullet-proof way to ensure the accessibility is to enable <code>CONFIG_IKCONFIG_PROC</code>, and, if enabled as a module, to load the <code>configs</code> module: <code>modprobe configs</code>.</p>"},{"location":"external-runtime-deps/#control-groups-cgroups","title":"Control Groups (cgroups)","text":"<p>Both cgroup v1 and cgroup v2 are supported.</p> <p>Required cgroup controllers:</p> <ul> <li><code>cpu</code></li> <li><code>cpuacct</code></li> <li><code>cpuset</code></li> <li><code>memory</code></li> <li><code>devices</code></li> <li><code>freezer</code></li> <li><code>pids</code></li> </ul> <p>Optional cgroup controllers:</p> <ul> <li>hugetlb (kubernetes/kubeadm#2335 (comment))</li> <li>blkio (kubernetes/kubernetes#92287 (comment))    containerd and cri-o will use blkio to track disk I/O and throttling in both    cgroup v1 and v2.</li> </ul>"},{"location":"external-runtime-deps/#no-integration-with-name-service-switch-nss-apis","title":"No integration with Name Service Switch (NSS) APIs","text":"<p>The k0s Linux binaries are by default statically linked against musl libc. This includes the binaries distributed on the GitHub releases pages. Static linking ensures that k0s can run seamlessly across a wide range of Linux environments by not requiring a specific standard C library to be installed on the host system. However, this design choice means that k0s cannot use glibc's NSS APIs, which require dynamic linking.</p> <p>This limitation is particularly relevant when a system uses NSS plugins, such as nss-myhostname, for resolving network names like <code>localhost</code>. Systems lacking a dedicated stub resolver capable of handling <code>localhost</code> DNS queries specifically will encounter issues running k0s. To mitigate this, users are advised to either activate a stub DNS resolver, such as <code>systemd-resolved</code>, or to manually add <code>localhost</code> entries to the <code>/etc/hosts</code> file as shown below:</p> <pre><code>127.0.0.1 localhost\n::1 localhost\n</code></pre>"},{"location":"external-runtime-deps/#external-hard-dependencies","title":"External hard dependencies","text":"<p>There are very few external tools that are needed or used.</p>"},{"location":"external-runtime-deps/#mountumount","title":"mount/umount","text":"<p>When setting up pods, kubelet will call <code>mount</code> binary on the host. Similarly when destroying pods it will call <code>umount</code>. <code>mount</code> and <code>umount</code> are only needed on worker nodes where kubelet runs.</p>"},{"location":"external-runtime-deps/#external-soft-dependencies","title":"External soft dependencies","text":"<p>There are a few external tools that may be needed or used under specific circumstances:</p>"},{"location":"external-runtime-deps/#containerd-and-apparmor","title":"containerd and AppArmor","text":"<p>In order to use containerd in conjunction with AppArmor, it must be enabled in the kernel and the <code>/sbin/apparmor_parser</code> executable must be installed on the host, otherwise containerd will disable AppArmor support.</p>"},{"location":"external-runtime-deps/#iptables","title":"iptables","text":"<p>iptables may be executed to detect if there are any existing iptables rules and if those are in legacy or nft mode. If iptables is not found, k0s will assume that there are no pre-existing iptables rules.</p>"},{"location":"external-runtime-deps/#useradd-adduser","title":"useradd / adduser","text":"<p>During <code>k0s install</code> the external tool <code>useradd</code> will be used on the controllers to create system user accounts for k0s. If this does exist it will fall-back to busybox's <code>adduser</code>.</p>"},{"location":"external-runtime-deps/#userdel-deluser","title":"userdel / deluser","text":"<p><code>k0s reset</code> will execute either <code>userdel</code> or <code>deluser</code> to clean up system user accounts.</p>"},{"location":"external-runtime-deps/#modprobe","title":"modprobe","text":"<p>On k0s worker <code>modprobe</code> will be executed to load missing kernel modules if they are not detected.</p>"},{"location":"external-runtime-deps/#id","title":"id","text":"<p>External <code>id</code> will be executed as a fallback if local user lookup fails, in case NSS is used.</p>"},{"location":"external-runtime-deps/#windows-specific","title":"Windows specific","text":"<p>TBD.</p>"},{"location":"feature-gates/","title":"Feature Gates","text":""},{"location":"feature-gates/#feature-gates","title":"Feature Gates","text":"<p>Feature gates are a mechanism to enable or disable experimental features in k0s. They allow you to control which features are active in your cluster, providing a way to safely test new functionality before it becomes generally available.</p>"},{"location":"feature-gates/#overview","title":"Overview","text":"<p>Feature gates in k0s follow a lifecycle model similar to Kubernetes:</p> <ul> <li>Alpha: Experimental features that are disabled by default and may be unstable or removed</li> <li>Beta: Features that are more stable but still being tested, enabled by default</li> <li>GA (Generally Available): Stable features that cannot be disabled. If explicitly disabled k0s will fail to start</li> </ul> <p>Once a feature reaches GA status, the feature gate cannot be disabled anymore and it will be eventually removed.</p>"},{"location":"feature-gates/#using-feature-gates","title":"Using Feature Gates","text":"<p>Feature gates can be configured using the <code>--feature-gates</code> flag when starting the k0s controllers:</p> <pre><code>k0s controller --feature-gates=\"ExampleFeature=true,AnotherFeature=false\"\n</code></pre> <p>The feature gates configuration must be consistent across all controllers in the cluster.</p> <p>Important notes:</p> <ul> <li>Currently feature gates apply only to the controllers. They may be added to workers in future releases</li> <li>Setting a GA feature gate to false will cause k0s startup to fail</li> <li>Unknown feature gates will cause k0s start up to fail</li> <li>Feature gates use case-sensitive CamelCase names</li> </ul>"},{"location":"feature-gates/#available-features","title":"Available Features","text":"<p>The following table is a summary of the feature gates that you can set. Each feature is designed for a specific stage of stability:</p> Feature Default Stage Since Until <code>IPv6SingleStack</code> <code>false</code> Alpha 1.34"},{"location":"feature-gates/#feature-details","title":"Feature Details","text":"<ul> <li><code>IPv6SingleStack</code>: Enables single-stack IPv6 support in k0s clusters.</li> </ul>"},{"location":"helm-charts/","title":"Helm Charts","text":""},{"location":"helm-charts/#helm-charts","title":"Helm Charts","text":"<p>Defining your extensions as Helm charts is one of two methods you can use to run k0s with your preferred extensions (the other being through the use of Manifest Deployer).</p> <p>k0s supports two methods for deploying applications using Helm charts:</p> <ul> <li>Use Helm command in runtime to install applications. Refer to the Helm Quickstart Guide for more information.</li> <li>Insert Helm charts directly into the k0s configuration file, <code>k0s.yaml</code>. This method does not require a separate install of <code>helm</code> tool and the charts automatically deploy at the k0s bootstrap phase.</li> </ul>"},{"location":"helm-charts/#helm-charts-in-k0s-configuration","title":"Helm charts in k0s configuration","text":"<p>Adding Helm charts into the k0s configuration file gives you a declarative way in which to configure the cluster. k0s controller manages the setup of Helm charts that are defined as extensions in the k0s configuration file.</p>"},{"location":"helm-charts/#chart-install-and-upgrade-options","title":"Chart install and upgrade options","text":"<p>Charts are processed the same way CLI tool does with following options by default:</p> <ul> <li><code>--create-namespace</code></li> <li><code>--atomic</code></li> <li><code>--force</code> (only for the <code>upgrade</code> command)</li> <li><code>--wait</code></li> <li><code>--wait-for-jobs</code></li> </ul> <p>See Chart configuration below for more details on how to configuring these options.</p>"},{"location":"helm-charts/#repository-configuration","title":"Repository configuration","text":"Field Default value Description <code>name</code> (required) The repository name <code>url</code> (required) The repository URL <code>insecure</code> <code>true</code> Whether to skip TLS certificate checks when connecting to the repository <code>caFile</code> - CA bundle file to use when verifying HTTPS-enabled servers <code>certFile</code> - The TLS certificate file to use for HTTPS client authentication (not supported by OCI registries) <code>keyfile</code> - The TLS key file to use for HTTPS client authentication (not supported by OCI registries) <code>username</code> - Username for Basic HTTP authentication <code>password</code> - Password for Basic HTTP authentication"},{"location":"helm-charts/#chart-configuration","title":"Chart configuration","text":"Field Default value Description <code>name</code> - Release name <code>chartname</code> - Chart name in form <code>repository/chartname</code> or path to tgz file <code>version</code> - Chart version to install <code>timeout</code> - Timeout to wait for release install <code>values</code> - Custom chart values as YAML formatted string <code>namespace</code> - Namespace to install the chart into <code>forceUpgrade</code> <code>true</code> When set to <code>false</code>, disables the use of the <code>--force</code> flag when upgrading the chart <code>order</code> <code>0</code> Order in which to to apply the manifest. For equal values, alphanumeric ordering is used."},{"location":"helm-charts/#example","title":"Example","text":"<p>In the example, Prometheus is configured from \"stable\" Helms chart repository. Add the following to <code>k0s.yaml</code> and restart k0s, after which Prometheus should start automatically with k0s.</p> <pre><code>spec:\n  extensions:\n    helm:\n      concurrencyLevel: 5\n      repositories:\n      - name: stable\n        url: https://charts.helm.sh/stable\n      - name: prometheus-community\n        url: https://prometheus-community.github.io/helm-charts\n      - name: helm-repo-with-auth\n        url: https://can-be-your-own-gitlab-ce-instance.org/api/v4/projects/PROJECTID/packages/helm/main\n        username: access-token-name-as-username\n        password: access-token-value-as-password\n      - name: oci-registry-with-private-ca\n        # OCI registry URL must not include any path elements\n        url: oci://registry-with-private-ca.com:8080\n        # Currently, only caFile is supported for TLS transport\n        # Setting certFile or keyFile will result in an error\n        caFile: /path/to/ca.crt\n      charts:\n      - name: prometheus-stack\n        chartname: prometheus-community/prometheus\n        version: \"14.6.1\"\n        timeout: 20m\n        order: 1\n        values: |\n          alertmanager:\n            persistentVolume:\n              enabled: false\n          server:\n            persistentVolume:\n              enabled: false\n        namespace: default\n      # We don't need to specify the repo in the repositories section for OCI charts\n      # unless a custom TLS transport is needed\n      - name: oci-chart\n        chartname: oci://registry:8080/chart\n        version: \"0.0.1\"\n        order: 2\n        values: \"\"\n        namespace: default\n      # OCI charts that require a custom TLS transport must add a repository entry \n      # pointing to TLS certificates on the controller node.\n      # In this case, chartname of the chart must include the same registry URL \n      # previously defined in the repository URL.\n      - name: oci-chart-with-tls\n        chartname: oci://registry-with-private-ca.com:8080/chart\n        version: \"0.0.1\"\n        values: \"\"\n        namespace: default\n      # Other way is to use local tgz file with chart\n      # the file must exist on all controller nodes\n      - name: tgz-chart\n        chartname: /tmp/chart.tgz\n        version: \"0.0.1\"\n        order: 2 \n        values: \"\"\n        namespace: default\n</code></pre> <p>Example extensions that you can use with Helm charts include:</p> <ul> <li>Ingress controllers: nginx ingress, Traefik ingress (refer to the k0s documentation for Installing the Traefik Ingress Controller)</li> <li>Volume storage providers: OpenEBS, Rook, Longhorn</li> <li>Monitoring: Prometheus, Grafana</li> </ul>"},{"location":"helm-charts/#helm-debug-logging","title":"Helm debug logging","text":"<p>Running k0s controller with <code>--debug=true</code> enables helm debug logging.</p>"},{"location":"high-availability/","title":"Control Plane High Availability","text":""},{"location":"high-availability/#control-plane-high-availability","title":"Control Plane High Availability","text":"<p>You can create high availability for the control plane by distributing the control plane across multiple nodes and installing a load balancer on top. Etcd can be co-located with the controller nodes (default in k0s) to achieve highly available data store at the same time.</p> <p></p> <p>Note: In this context, a two-node control plane is considered highly available, even though it is not HA from etcd's perspective. The same requirement for the load balancer still applies.</p>"},{"location":"high-availability/#network-considerations","title":"Network considerations","text":"<p>You should plan to allocate the control plane nodes into different zones. This will avoid failures in case one zone fails.</p> <p>For etcd high availability it's recommended to configure 3 or 5 controller nodes. For more information, refer to the etcd documentation.</p>"},{"location":"high-availability/#load-balancer","title":"Load Balancer","text":"<p>Control plane high availability requires a tcp load balancer, which acts as a single point of contact to access the controllers. The load balancer needs to allow and route traffic to each controller through the following ports:</p> <ul> <li>6443 (for Kubernetes API)</li> <li>8132 (for Konnectivity)</li> <li>9443 (for controller join API)</li> </ul> <p>The load balancer can be implemented in many different ways and k0s doesn't have any additional requirements. You can use for example HAProxy, nginx or your cloud provider's load balancer.</p>"},{"location":"high-availability/#example-configuration-haproxy","title":"Example configuration: HAProxy","text":"<p>Add the following lines at the end of <code>haproxy.cfg</code>:</p> <pre><code>frontend kubeAPI\n    bind :6443\n    mode tcp\n    default_backend kubeAPI_backend\nfrontend konnectivity\n    bind :8132\n    mode tcp\n    default_backend konnectivity_backend\nfrontend controllerJoinAPI\n    bind :9443\n    mode tcp\n    default_backend controllerJoinAPI_backend\n\nbackend kubeAPI_backend\n    mode tcp\n    server k0s-controller1 &lt;ip-address1&gt;:6443 check check-ssl verify none\n    server k0s-controller2 &lt;ip-address2&gt;:6443 check check-ssl verify none\n    server k0s-controller3 &lt;ip-address3&gt;:6443 check check-ssl verify none\nbackend konnectivity_backend\n    mode tcp\n    server k0s-controller1 &lt;ip-address1&gt;:8132 check check-ssl verify none\n    server k0s-controller2 &lt;ip-address2&gt;:8132 check check-ssl verify none\n    server k0s-controller3 &lt;ip-address3&gt;:8132 check check-ssl verify none\nbackend controllerJoinAPI_backend\n    mode tcp\n    server k0s-controller1 &lt;ip-address1&gt;:9443 check check-ssl verify none\n    server k0s-controller2 &lt;ip-address2&gt;:9443 check check-ssl verify none\n    server k0s-controller3 &lt;ip-address3&gt;:9443 check check-ssl verify none\n\nlisten stats\n   bind *:9000\n   mode http\n   stats enable\n   stats uri /\n</code></pre> <p>The last block \"listen stats\" is optional, but can be helpful. It enables HAProxy statistics with a separate dashboard to monitor for example the health of each backend server. You can access it using a web browser:</p> <pre><code>http://&lt;ip-addr&gt;:9000\n</code></pre> <p>Restart HAProxy to apply the configuration changes.</p>"},{"location":"high-availability/#k0s-configuration","title":"k0s configuration","text":"<p>First and foremost, all controllers should utilize the same CA certificates and SA key pair:</p> <pre><code>/var/lib/k0s/pki/ca.key\n/var/lib/k0s/pki/ca.crt\n/var/lib/k0s/pki/sa.key\n/var/lib/k0s/pki/sa.pub\n/var/lib/k0s/pki/etcd/ca.key\n/var/lib/k0s/pki/etcd/ca.crt\n</code></pre> <p>To generate these certificates, you have two options: either generate them manually using the instructions for installing custom CA certificates, and then share them between controller nodes, or use k0sctl to generate and share them automatically.</p> <p>The second important aspect is: the load balancer address must be configured to k0s either by using <code>k0s.yaml</code> or by using k0sctl to automatically deploy all controllers with the same configuration:</p>"},{"location":"high-availability/#configuration-using-k0syaml-for-each-controller","title":"Configuration using k0s.yaml (for each controller)","text":"<p>Note to update your load balancer's public IP address into two places.</p> <pre><code>spec:\n  api:\n    externalAddress: &lt;load balancer public ip address&gt;\n    sans:\n    - &lt;load balancer public ip address&gt;\n</code></pre>"},{"location":"high-availability/#configuration-using-k0sctlyaml-for-k0sctl","title":"Configuration using k0sctl.yaml (for k0sctl)","text":"<p>Add the following lines at the end of <code>k0sctl.yaml</code>. Note to update your load balancer's public IP address into two places.</p> <pre><code>  k0s:\n    config:\n      spec:\n        api:\n          externalAddress: &lt;load balancer public ip address&gt;\n          sans:\n          - &lt;load balancer public ip address&gt;\n</code></pre> <p>For greater detail about k0s configuration, refer to the Full configuration file reference.</p>"},{"location":"install/","title":"Quick Start Guide","text":""},{"location":"install/#quick-start-guide","title":"Quick Start Guide","text":"<p>Completing this Quick Start results in a single-node Kubernetes cluster that incorporates both the controller and worker roles. This setup is ideal for environments that don't require high availability or multiple nodes.</p>"},{"location":"install/#prerequisites","title":"Prerequisites","text":"<p>Note: Before proceeding, make sure to review the System Requirements.</p> <p>The following steps work on every typical Linux distribution that uses either systemd or OpenRC as its init system.</p>"},{"location":"install/#install-k0s","title":"Install k0s","text":"<ol> <li> <p>Download k0s</p> <p>Run the k0s download script to download the latest stable version of k0s and make it executable from /usr/local/bin/k0s.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://get.k0s.sh | sudo sh\n</code></pre> <p>Alternatively, download it from the k0s releases page. This approach is   required in air gapped environments.</p> </li> <li> <p>Install k0s as a service</p> <p>The <code>k0s install</code> sub-command installs k0s as a system service on a host that is running one of the supported init systems: systemd or OpenRC. You can execute the install for workers, controllers or single node (controller+worker) instances.</p> <p>Run the following command to install a single node k0s that includes the controller and worker functions with the default configuration:</p> <pre><code>sudo k0s install controller --single\n</code></pre> <p>Note: The <code>--single</code> option disables features needed for multi-node   clusters, so the cluster cannot be extended. To retain the ability to expand   the cluster in the future, use:</p> <pre><code>sudo k0s install controller --enable-worker --no-taints\n</code></pre> <p>The <code>k0s install controller</code> sub-command accepts the same flags and parameters as the <code>k0s controller</code>. Refer to manual install for a custom config file example.</p> <p>It is possible to set environment variables with the install command:</p> <pre><code>sudo k0s install controller -e ETCD_UNSUPPORTED_ARCH=arm\n</code></pre> <p>The system service can be reinstalled with the <code>--force</code> flag:</p> <pre><code>sudo k0s install controller --single --force\nsudo systemctl daemon-reload\n</code></pre> </li> <li> <p>Start k0s as a service</p> <p>To start the k0s service, run:</p> <pre><code>sudo k0s start\n</code></pre> <p>The k0s service will start automatically after the node restart.</p> <p>A minute or two typically passes before the node is ready to deploy applications.</p> </li> <li> <p>Check service, logs and k0s status</p> <p>Run the following command to check the k0s instance status:</p> <pre><code>$ sudo k0s status\nVersion: v1.34.1+head\nProcess ID: 436\nRole: controller\nWorkloads: true\nInit System: linux-systemd\n</code></pre> </li> <li> <p>Access the cluster using kubectl</p> <p>Note: k0s embeds the Kubernetes command-line tool kubectl.</p> <p>Use kubectl to deploy applications or check node status:</p> <pre><code>$ sudo k0s kubectl get nodes\nNAME   STATUS   ROLES    AGE    VERSION\nk0s    Ready    &lt;none&gt;   4m6s   v1.34.1+k0s\n</code></pre> </li> </ol>"},{"location":"install/#uninstall-k0s","title":"Uninstall k0s","text":"<p>The removal of k0s is a two-step process.</p> <ol> <li> <p>Stop the service.</p> <pre><code>sudo k0s stop\n</code></pre> </li> <li> <p>Execute the <code>k0s reset</code> command.</p> <p>The <code>k0s reset</code> command cleans up the installed system service, data directories, containers, mounts and network namespaces.</p> <pre><code>sudo k0s reset\n</code></pre> </li> <li> <p>Reboot the system.</p> <p>A few small k0s fragments persist even after the reset, such as iptables   rules. Reboot the machine after running <code>k0s reset</code>.</p> </li> </ol>"},{"location":"install/#next-steps","title":"Next Steps","text":"<ul> <li>Install using k0sctl: Deploy multi-node clusters using just one command</li> <li>Manual Install: (Advanced) Manually deploy multi-node clusters</li> <li>Control plane configuration options: Networking and data store configuration</li> <li>Worker node configuration options: Node labels and kubelet arguments</li> <li>Support for cloud providers: Load balancer or storage configuration</li> <li>Installing the Traefik Ingress Controller:   Ingress deployment information</li> <li>Air gapped/offline installation: Air gaped deployment</li> </ul>"},{"location":"k0s-in-docker/","title":"Docker","text":""},{"location":"k0s-in-docker/#run-k0s-in-docker","title":"Run k0s in Docker","text":"<p>You can create a k0s cluster on top of Docker.</p>"},{"location":"k0s-in-docker/#prerequisites","title":"Prerequisites","text":"<p>You will require a Docker environment running on a Mac, Windows, or Linux system.</p>"},{"location":"k0s-in-docker/#container-images","title":"Container images","text":"<p>The k0s OCI images are published to both Docker Hub and GitHub Container registry. For simplicity, the examples given here use Docker Hub (GitHub requires separate authentication, which is not covered here). The image names are as follows:</p> <ul> <li><code>docker.io/k0sproject/k0s:v1.34.1-head</code></li> <li><code>ghcr.io/k0sproject/k0s:v1.34.1-head</code></li> </ul> <p>Note: Due to Docker's tag validation scheme, <code>-</code> is used as the k0s version separator instead of the usual <code>+</code>. For example, k0s version <code>v1.34.1+head</code> is tagged as <code>docker.io/k0sproject/k0s:v1.34.1-head</code>.</p>"},{"location":"k0s-in-docker/#start-k0s","title":"Start k0s","text":""},{"location":"k0s-in-docker/#1-run-a-controller","title":"1. Run a controller","text":"<p>By default, running the k0s OCI image will launch a controller with workloads enabled (i.e. a controller with the <code>--enable-worker</code> flag) to provide an easy local testing \"cluster\":</p> <pre><code>docker run -d --name k0s-controller --hostname k0s-controller \\\n  -v /var/lib/k0s -v /var/log/pods `# this is where k0s stores its data` \\\n  --tmpfs /run `# this is where k0s stores runtime data` \\\n  --privileged `# this is the easiest way to enable container-in-container workloads` \\\n  -p 6443:6443 `# publish the Kubernetes API server port` \\\n  docker.io/k0sproject/k0s:v1.34.1-head\n</code></pre> <p>Explanation of command line arguments:</p> <ul> <li><code>-d</code> runs the container in detached mode, i.e. in the background.</li> <li><code>--name k0s-controller</code> names the container \"k0s-controller\".</li> <li><code>--hostname k0s-controller</code> sets the host name of the container to   \"k0s-controller\".</li> <li><code>-v /var/lib/k0s -v /var/log/pods</code> creates two Docker volumes and mounts them   to <code>/var/lib/k0s</code> and <code>/var/log/pods</code> respectively inside the container,   ensuring that cluster data persists across container restarts.</li> <li><code>--tmpfs /run</code> TODO</li> <li><code>--privileged</code> gives the container the elevated privileges that k0s needs to   function properly within Docker. See the section on adding additional   workers for a more detailed discussion of   privileges.</li> <li><code>-p 6443:6443</code> exposes the container's Kubernetes API server port 6443 to the   host, allowing you to interact with the cluster externally.</li> <li><code>docker.io/k0sproject/k0s:v1.34.1-head</code> is the name of the   k0s image to run.</li> </ul> <p>By default, the k0s image starts a k0s controller with worker components enabled within the same container, creating a cluster with a single controller-and-worker node using the following command:</p> <pre><code>CMD [\"k0s\", \"controller\", \"--enable-worker\"]\n</code></pre> <p>Alternatively, a controller-only node can be run like this:</p> <pre><code>docker run -d --name k0s-controller --hostname k0s-controller \\\n  --read-only `# k0s won't write any data outside the below paths` \\\n  -v /var/lib/k0s `# this is where k0s stores its data` \\\n  --tmpfs /run `# this is where k0s stores runtime data` \\\n  --tmpfs /tmp `# allow writing temporary files` \\\n  -p 6443:6443 `# publish the Kubernetes API server port` \\\n  docker.io/k0sproject/k0s:v1.34.1-head \\\n  k0s controller\n</code></pre> <p>Note the addition of <code>k0s controller</code> to override the image's default command. Also note that a controller-only node requires fewer privileges.</p>"},{"location":"k0s-in-docker/#2-optional-add-additional-workers","title":"2. (Optional) Add additional workers","text":"<p>You can add multiple worker nodes to the cluster and then distribute your application containers to separate workers.</p> <ol> <li> <p>Acquire a join token for the    worker:</p> <pre><code>token=$(docker exec k0s-controller k0s token create --role=worker)\n</code></pre> </li> <li> <p>Run the container to create and join the new worker:</p> <pre><code>docker run -d --name k0s-worker1 --hostname k0s-worker1 \\\n  -v /var/lib/k0s -v /var/log/pods `# this is where k0s stores its data` \\\n  --tmpfs /run `# this is where k0s stores runtime data` \\\n  --privileged `# this is the easiest way to enable container-in-container workloads` \\\n  docker.io/k0sproject/k0s:v1.34.1-head \\\n  k0s worker $token\n</code></pre> <p>Alternatively, with fine-grained privileges:   </p> <pre><code>docker run -d --name k0s-worker1 --hostname k0s-worker1 \\\n  -v /var/lib/k0s -v /var/log/pods `# this is where k0s stores its data` \\\n  --tmpfs /run `# this is where k0s stores runtime data` \\\n  --security-opt seccomp=unconfined \\\n  --device /dev/kmsg \\\n  --cap-add sys_admin \\\n  --cap-add net_admin \\\n  --cap-add sys_ptrace \\\n  --cap-add sys_resource \\\n  --cap-add syslog \\\n  docker.io/k0sproject/k0s:v1.34.1-head \\\n  k0s worker \"$token\"\n</code></pre> <p>Notes on the security-related flags:</p> <ul> <li><code>--security-opt seccomp=unconfined</code> is required for <code>runc</code> to access the    session keyring.</li> <li><code>--device /dev/kmsg</code> makes <code>/dev/kmsg</code> visible from inside the container.    The kubelet's OOM watcher uses this.    </li> </ul> <p>Notes on Linux capabilities:</p> <ul> <li><code>CAP_SYS_ADMIN</code> allows for a variety of administrative tasks, including    mounting file systems and managing namespaces, which are necessary for    creating and configuring nested containers.</li> <li><code>CAP_NET_ADMIN</code> allows manipulation of network settings such as interfaces    and routes, allowing containers to create isolated or bridged networks, and    so on.</li> <li><code>CAP_SYS_PTRACE</code> allows to inspect and modify processes, used to monitor    other containers in a nested environment.    </li> <li><code>CAP_SYS_RESOURCE</code> allows containers to override resource limits for things    like memory or file descriptors, used to manage and adjust resource    allocation in nested container environments.    </li> <li><code>CAP_SYSLOG</code> allows containers to perform privileged syslog operations.    This is required in order to read <code>/dev/kmsg</code>.</li> </ul> <p>Note that more privileges may be required depending on your cluster  configuration and workloads.</p> <p>Repeat this step for each additional worker node and adjust the container and  host names accordingly. Make sure that the workers can reach the controller  on the required ports. If you are using Docker's default bridged network,  this should be the case.</p> </li> </ol>"},{"location":"k0s-in-docker/#3-access-your-cluster","title":"3. Access your cluster","text":""},{"location":"k0s-in-docker/#a-using-kubectl-within-the-container","title":"a) Using kubectl within the container","text":"<p>To check cluster status and list nodes, use:</p> <pre><code>docker exec k0s-controller k0s kubectl get nodes\n</code></pre>"},{"location":"k0s-in-docker/#b-using-kubectl-locally","title":"b) Using kubectl locally","text":"<p>To configure local access to your k0s cluster, follow these steps:</p> <ol> <li> <p>Generate the kubeconfig:</p> <pre><code>docker exec k0s-controller k0s kubeconfig admin &gt; ~/.kube/k0s.config\n</code></pre> </li> <li> <p>Update kubeconfig with Localhost Access:</p> <p>To automatically replace the server IP with localhost dynamically in <code>~/.kube/k0s.config</code>, use the following command:</p> <pre><code>sed -i '' -e \"$(awk '/server:/ {print NR; exit}' ~/.kube/k0s.config)s|https://.*:6443|https://localhost:6443|\" ~/.kube/k0s.config\n</code></pre> <p>This command updates the kubeconfig to point to localhost, allowing access to the API server from your host machine</p> </li> <li> <p>Set the KUBECONFIG Environment Variable:</p> <pre><code>export KUBECONFIG=~/.kube/k0s.config\n</code></pre> </li> <li> <p>Verify Cluster Access:</p> <pre><code>kubectl get nodes\n</code></pre> </li> </ol>"},{"location":"k0s-in-docker/#c-use-lens","title":"c) Use Lens","text":"<p>Access the k0s cluster using Lens by following the instructions on how to add a cluster.</p>"},{"location":"k0s-in-docker/#use-docker-compose-alternative","title":"Use Docker Compose (alternative)","text":"<p>As an alternative you can run k0s using Docker Compose:</p> <pre><code>services:\n  k0s-controller:\n    image: docker.io/k0sproject/k0s:v1.34.1-head\n    container_name: k0s-controller\n    hostname: k0s-controller\n    network_mode: bridge # other modes are unsupported\n    ports:\n      - 6443:6443 # publish the Kubernetes API server port\n    volumes:\n      - /var/lib/k0s # this is where k0s stores its data\n      - /var/log/pods # this is where k0s stores pod logs\n      - /dev/kmsg:/dev/kmsg:ro # required by kubelets OOM watcher\n    tmpfs:\n      - /run # this is where k0s stores runtime data\n    devices:\n      - /dev/kmsg # required by kubelet's OOM watcher\n    cap_add:\n      - sys_admin\n      - net_admin\n      - sys_ptrace\n      - sys_resource\n      - syslog\n    security_opt:\n      - seccomp:unconfined # allow access to the session keyring\n    configs:\n      - source: k0s.yaml\n        target: /etc/k0s/k0s.yaml\n\nconfigs:\n  k0s.yaml:\n    content: |\n      apiVersion: k0s.k0sproject.io/v1beta1\n      kind: ClusterConfig\n      metadata:\n        name: k0s\n      spec:\n        storage:\n          type: kine\n      # Any additional configuration goes here ...\n</code></pre> <p>Below is a more complex example, using Traefik as a load balancer, along with three controller and three worker nodes:</p> <pre><code>name: compose-cluster\n\nx-k0s-image: &amp;k0s-image docker.io/k0sproject/k0s:v1.34.1-head\n\nx-k0s-controller: &amp;k0s-controller\n  image: *k0s-image\n  networks:\n    - k0s-net\n  tmpfs:\n    - /run # this is where k0s stores runtime data\n    - /tmp\n  configs:\n    - source: k0s.yaml\n      target: /etc/k0s/k0s.yaml\n  labels:\n    - traefik.enable=true\n    - traefik.tcp.routers.kube-api.service=kube-api\n    - traefik.tcp.routers.kube-api.rule=HostSNI(`*`)\n    - traefik.tcp.routers.kube-api.entrypoints=kube-api\n    - traefik.tcp.services.kube-api.loadbalancer.server.port=6443\n    - traefik.tcp.routers.k0s-api.service=k0s-api\n    - traefik.tcp.routers.k0s-api.rule=HostSNI(`*`)\n    - traefik.tcp.routers.k0s-api.entrypoints=k0s-api\n    - traefik.tcp.services.k0s-api.loadbalancer.server.port=9443\n    - traefik.tcp.routers.konnectivity.service=konnectivity\n    - traefik.tcp.routers.konnectivity.rule=HostSNI(`*`)\n    - traefik.tcp.routers.konnectivity.entrypoints=konnectivity\n    - traefik.tcp.services.konnectivity.loadbalancer.server.port=8132\n  restart: on-failure\n\nx-k0s-worker: &amp;k0s-worker\n  image: *k0s-image\n  networks:\n    - k0s-net\n  depends_on:\n    - k0s-controller-1\n  command: [k0s, worker, --token-file, /run/secrets/k0sproject.io/tokens/worker]\n  volumes:\n    - /var/lib/k0s # this is where k0s stores its data\n    - /var/log/pods # this is where k0s stores pod logs\n    - /dev/kmsg:/dev/kmsg:ro # required by kubelets OOM watcher\n    - k0s-worker-token:/run/secrets/k0sproject.io/tokens:ro\n  tmpfs:\n    - /run # this is where k0s stores runtime data\n    - /tmp\n  devices:\n    - /dev/kmsg # required by kubelet's OOM watcher\n  cap_add:\n    - sys_admin\n    - net_admin\n    - sys_ptrace\n    - sys_resource\n    - syslog\n  security_opt:\n    - seccomp:unconfined # allow access to the session keyring\n  restart: on-failure\n\nnetworks:\n  k0s-net:\n    driver: bridge\n\nservices:\n  k0s-lb:\n    image: docker.io/library/traefik:v3.5.3\n    container_name: k0s-lb\n    hostname: k0s-lb\n    networks:\n      - k0s-net\n    command:\n      - --api.insecure=true\n      - --providers.docker=true\n      - --providers.docker.exposedbydefault=false\n      - --entryPoints.kube-api.address=:6443\n      - --entryPoints.k0s-api.address=:9443\n      - --entryPoints.konnectivity.address=:8132\n    ports:\n      - 6443:6443 # publish the Kubernetes API server port\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n\n  k0s-controller-1:\n    &lt;&lt;: *k0s-controller\n    container_name: k0s-controller-1\n    hostname: k0s-controller-1\n    depends_on:\n      - k0s-lb\n    command: [k0s, controller]\n    post_start:\n      - command:\n          - /bin/sh\n          - -euc\n          - |\n            bootstrap() {\n              # this works even if etcd isn't up\n\n              find /run/secrets/k0sproject.io/controller-token ! -path /run/secrets/k0sproject.io/controller-token -prune -exec rm -rf {} +\n              k0s token pre-shared --role controller \\\n                --cert /var/lib/k0s/pki/ca.crt \\\n                --url https://k0s-lb:9443 \\\n                --out /run/secrets/k0sproject.io/controller-token/\n\n              find /run/secrets/k0sproject.io/worker-token ! -path /run/secrets/k0sproject.io/worker-token -prune -exec rm -rf {} +\n              k0s token pre-shared --role worker \\\n                --cert /var/lib/k0s/pki/ca.crt \\\n                --url https://k0s-lb:6443 \\\n                --out /run/secrets/k0sproject.io/worker-token/\n\n              mv /run/secrets/k0sproject.io/controller-token/*.yaml /var/lib/k0s/manifests/k0s-token-secrets/controller.yaml\n              mv /run/secrets/k0sproject.io/controller-token/token_* /run/secrets/k0sproject.io/controller-token/controller\n              mv /run/secrets/k0sproject.io/worker-token/*.yaml /var/lib/k0s/manifests/k0s-token-secrets/worker.yaml\n              mv /run/secrets/k0sproject.io/worker-token/token_* /run/secrets/k0sproject.io/worker-token/worker\n            }\n\n            while [ ! -f /var/lib/k0s/pki/ca.crt ] || ! bootstrap; do\n              sleep 1\n            done\n            sleep 10 # give this controller a bit of a head start\n\n    volumes:\n      - /var/lib/k0s # this is where k0s stores its data\n      - k0s-token-secrets:/var/lib/k0s/manifests/k0s-token-secrets\n      - k0s-controller-token:/run/secrets/k0sproject.io/controller-token\n      - k0s-worker-token:/run/secrets/k0sproject.io/worker-token\n\n  k0s-controller-2: &amp;k0s-additional-controller\n    &lt;&lt;: *k0s-controller\n    container_name: k0s-controller-2\n    hostname: k0s-controller-2\n    depends_on:\n      - k0s-controller-1\n    command:\n      [\n        k0s,\n        controller,\n        --token-file,\n        /run/secrets/k0sproject.io/tokens/controller,\n      ]\n    volumes:\n      - /var/lib/k0s # this is where k0s stores its data\n      - k0s-token-secrets:/var/lib/k0s/manifests/k0s-token-secrets:ro\n      - k0s-controller-token:/run/secrets/k0sproject.io/tokens:ro\n\n  k0s-controller-3:\n    &lt;&lt;: *k0s-additional-controller\n    container_name: k0s-controller-3\n    hostname: k0s-controller-3\n\n  k0s-worker-1:\n    &lt;&lt;: *k0s-worker\n    container_name: k0s-worker-1\n    hostname: k0s-worker-1\n\n  k0s-worker-2:\n    &lt;&lt;: *k0s-worker\n    container_name: k0s-worker-2\n    hostname: k0s-worker-2\n\n  k0s-worker-3:\n    &lt;&lt;: *k0s-worker\n    container_name: k0s-worker-3\n    hostname: k0s-worker-3\n\nvolumes:\n  k0s-token-secrets:\n    driver: local\n    driver_opts:\n      type: tmpfs\n      device: tmpfs\n  k0s-controller-token:\n    driver: local\n    driver_opts:\n      type: tmpfs\n      device: tmpfs\n  k0s-worker-token:\n    driver: local\n    driver_opts:\n      type: tmpfs\n      device: tmpfs\n\nconfigs:\n  k0s.yaml:\n    content: |\n      spec:\n        api:\n          externalAddress: k0s-lb\n</code></pre> <p>Running the above:</p> <pre><code> \u276f docker compose up -d\n[+] Running 11/11\n \u2714 Network compose-cluster_k0s-net                Created                0.1s\n \u2714 Volume \"compose-cluster_k0s-token-secrets\"     Created                0.0s\n \u2714 Volume \"compose-cluster_k0s-controller-token\"  Created                0.0s\n \u2714 Volume \"compose-cluster_k0s-worker-token\"      Created                0.0s\n \u2714 Container k0s-lb                               Started                0.5s\n \u2714 Container k0s-controller-1                     Started                11.8s\n \u2714 Container k0s-controller-2                     Started                12.2s\n \u2714 Container k0s-worker-1                         Started                12.4s\n \u2714 Container k0s-worker-2                         Started                12.3s\n \u2714 Container k0s-worker-3                         Started                12.1s\n \u2714 Container k0s-controller-3                     Started                12.5s\n</code></pre> <p>After a short while:</p> <pre><code>$ docker exec k0s-controller-1 k0s kc get node,po -A\nNAME                STATUS   ROLES    AGE     VERSION\nnode/k0s-worker-1   Ready    &lt;none&gt;   1m36s   v1.34.1+k0s\nnode/k0s-worker-2   Ready    &lt;none&gt;   1m36s   v1.34.1+k0s\nnode/k0s-worker-3   Ready    &lt;none&gt;   1m36s   v1.34.1+k0s\n\nNAMESPACE     NAME                                  READY   STATUS    RESTARTS   AGE\nkube-system   pod/coredns-7d4f7fbd5c-54lxp          1/1     Running   0          1m27s\nkube-system   pod/coredns-7d4f7fbd5c-pwbck          1/1     Running   0          1m27s\nkube-system   pod/konnectivity-agent-5g8pn          1/1     Running   0          1m22s\nkube-system   pod/konnectivity-agent-6rp7r          1/1     Running   0          1m22s\nkube-system   pod/konnectivity-agent-zx9fn          1/1     Running   0          1m22s\nkube-system   pod/kube-proxy-9m77t                  1/1     Running   0          1m36s\nkube-system   pod/kube-proxy-v5vs6                  1/1     Running   0          1m36s\nkube-system   pod/kube-proxy-xfw2h                  1/1     Running   0          1m36s\nkube-system   pod/kube-router-6c62v                 1/1     Running   0          1m36s\nkube-system   pod/kube-router-98ss8                 1/1     Running   0          1m36s\nkube-system   pod/kube-router-lr46f                 1/1     Running   0          1m36s\nkube-system   pod/metrics-server-7778865875-fzhx6   1/1     Running   0          1m37s\n</code></pre>"},{"location":"k0s-in-docker/#known-limitations","title":"Known limitations","text":""},{"location":"k0s-in-docker/#no-custom-docker-networks","title":"No custom Docker networks","text":"<p>Currently, k0s nodes cannot be run if the containers are configured to use custom networks (for example, with <code>--net my-net</code>). This is because Docker sets up a custom DNS service within the network which creates issues with CoreDNS. No completely reliable workarounds are available, however no issues should arise from running k0s cluster(s) on a bridge network.</p>"},{"location":"k0s-in-docker/#next-steps","title":"Next Steps","text":"<ul> <li>Install using k0sctl: Deploy multi-node clusters using just one command</li> <li>Control plane configuration options: Networking and data store configuration</li> <li>Worker node configuration options: Node labels and kubelet arguments</li> <li>Support for cloud providers: Load balancer or storage configuration</li> <li>Installing the Traefik Ingress Controller: Ingress deployment information</li> </ul>"},{"location":"k0s-multi-node/","title":"Manual (advanced)","text":""},{"location":"k0s-multi-node/#manual-install-advanced","title":"Manual Install (Advanced)","text":"<p>You can manually set up k0s nodes by creating a multi-node cluster that is locally managed on each node. This involves several steps, to first install each node separately, and to then connect the node together using access tokens.</p>"},{"location":"k0s-multi-node/#prerequisites","title":"Prerequisites","text":"<p>Note: Before proceeding, make sure to review the System Requirements.</p> <p>The following steps work on every typical Linux distribution that uses either systemd or OpenRC as its init system.</p> <p>You can speed up the use of the <code>k0s</code> command by enabling shell completion.</p>"},{"location":"k0s-multi-node/#install-k0s","title":"Install k0s","text":""},{"location":"k0s-multi-node/#1-download-k0s","title":"1. Download k0s","text":"<p>Run the k0s download script to download the latest stable version of k0s and make it executable from <code>/usr/bin/k0s</code>.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://get.k0s.sh | sudo sh\n</code></pre> <p>The download script accepts the following environment variables:</p> Variable Purpose <code>K0S_VERSION=v1.34.1+head</code> Select the version of k0s to be installed <code>DEBUG=true</code> Output commands and their arguments at execution. <p>Note: If you require environment variables and use sudo, you can do:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://get.k0s.sh | sudo K0S_VERSION=v1.34.1+head sh\n</code></pre>"},{"location":"k0s-multi-node/#2-bootstrap-a-controller-node","title":"2. Bootstrap a controller node","text":"<p>Create a configuration file:</p> <pre><code>mkdir -p /etc/k0s\nk0s config create &gt; /etc/k0s/k0s.yaml\n</code></pre> <p>Note: For information on settings modification, refer to the configuration documentation.</p> <pre><code>sudo k0s install controller -c /etc/k0s/k0s.yaml\n</code></pre> <pre><code>sudo k0s start\n</code></pre> <p>k0s process acts as a \"supervisor\" for the control plane components. In moments the control plane will be up and running.</p>"},{"location":"k0s-multi-node/#3-create-a-join-token","title":"3. Create a join token","text":"<p>You need a token to join workers to the cluster. The token embeds information that enables mutual trust between the worker and controller(s) and which allows the node to join the cluster as worker.</p> <p>To get a token, run the following command on one of the existing controller nodes:</p> <pre><code>sudo k0s token create --role=worker\n</code></pre> <p>The resulting output is a long token string, which you can use to add a worker to the cluster.</p> <p>For enhanced security, run the following command to set an expiration time for the token:</p> <pre><code>sudo k0s token create --role=worker --expiry=100h &gt; token-file\n</code></pre>"},{"location":"k0s-multi-node/#4-add-workers-to-the-cluster","title":"4. Add workers to the cluster","text":"<p>To join the worker, run k0s in the worker mode with the join token you created:</p> <pre><code>sudo k0s install worker --token-file /path/to/token/file\n</code></pre> <pre><code>sudo k0s start\n</code></pre>"},{"location":"k0s-multi-node/#about-join-tokens","title":"About join tokens","text":"<p>The join tokens are base64-encoded kubeconfigs for several reasons:</p> <ul> <li>Well-defined structure</li> <li>Capable of direct use as bootstrap auth configs for kubelet</li> <li>Embedding of CA info for mutual trust</li> </ul> <p>The bearer token embedded in the kubeconfig is a bootstrap token. For controller join tokens and worker join tokens k0s uses different usage attributes to ensure that k0s can validate the token role on the controller side.</p>"},{"location":"k0s-multi-node/#5-add-controllers-to-the-cluster","title":"5. Add controllers to the cluster","text":"<p>Note: Either etcd or an external data store (MySQL or PostgreSQL) via kine must be in use to add new controller nodes to the cluster. Pay strict attention to the high availability configuration and make sure the configuration is identical for all controller nodes.</p> <p>To create a join token for the new controller, run the following command on an existing controller:</p> <pre><code>sudo k0s token create --role=controller --expiry=1h &gt; token-file\n</code></pre> <p>On the new controller, run:</p> <pre><code>sudo k0s install controller --token-file /path/to/token/file -c /etc/k0s/k0s.yaml\n</code></pre> <p>Important notice here is that each controller in the cluster must have k0s.yaml otherwise some cluster nodes will use default config values which will lead to inconsistency behavior. If your configuration file includes IP addresses (node address, SANs, etcd peer address), remember to update them accordingly for this specific controller node.</p> <pre><code>sudo k0s start\n</code></pre>"},{"location":"k0s-multi-node/#6-check-k0s-status","title":"6. Check k0s status","text":"<p>Run the following command to check the k0s instance status:</p> <pre><code> sudo k0s status\n</code></pre> <pre><code>Version: v1.34.1+head\nProcess ID: 2769\nParent Process ID: 1\nRole: controller\nInit System: linux-systemd\nService file: /etc/systemd/system/k0scontroller.service\n</code></pre>"},{"location":"k0s-multi-node/#7-access-your-cluster","title":"7. Access your cluster","text":"<p>Use the Kubernetes 'kubectl' command-line tool that comes with k0s binary to deploy your application or check your node status:</p> <pre><code>sudo k0s kubectl get nodes\n</code></pre> <pre><code>NAME   STATUS   ROLES    AGE    VERSION\nk0s    Ready    &lt;none&gt;   4m6s   v1.34.1+k0s\n</code></pre> <p>You can also access your cluster easily with Lens, simply by copying the kubeconfig and pasting it to Lens:</p> <pre><code>sudo cat /var/lib/k0s/pki/admin.conf\n</code></pre> <p>Note: To access the cluster from an external network you must replace <code>localhost</code> in the kubeconfig with the host ip address for your controller.</p>"},{"location":"k0s-multi-node/#next-steps","title":"Next Steps","text":"<ul> <li>Install using k0sctl: Deploy multi-node clusters using just one command</li> <li>Control plane configuration options: Networking and data store configuration</li> <li>Worker node configuration options: Node labels and kubelet arguments</li> <li>Support for cloud providers: Load balancer or storage configuration</li> <li>Installing the Traefik Ingress Controller: Ingress deployment information</li> </ul>"},{"location":"k0s-single-node/","title":"K0s single node","text":"<p>See the Quick Start Guide.</p>"},{"location":"k0sctl-install/","title":"Using k0sctl","text":""},{"location":"k0sctl-install/#install-using-k0sctl","title":"Install using k0sctl","text":"<p>k0sctl is a command-line tool for bootstrapping and managing k0s clusters. k0sctl connects to the provided hosts using SSH and gathers information on the hosts, with which it forms a cluster by configuring the hosts, deploying k0s, and then connecting the k0s nodes together.</p> <p></p> <p>With k0sctl, you can create multi-node clusters in a manner that is automatic and easily repeatable. This method is recommended for production cluster installation.</p> <p>Note: The k0sctl install method is necessary for automatic upgrade.</p>"},{"location":"k0sctl-install/#prerequisites","title":"Prerequisites","text":"<p>You can execute k0sctl on any system that supports the Go language. Pre-compiled k0sctl binaries are available on the k0sctl releases page).</p> <p>Note: For target host prerequisites information, refer to the k0s System Requirements.</p>"},{"location":"k0sctl-install/#install-k0s","title":"Install k0s","text":""},{"location":"k0sctl-install/#1-install-k0sctl-tool","title":"1. Install k0sctl tool","text":"<p>k0sctl is a single binary, the instructions for downloading and installing of which are available in the k0sctl github repository.</p>"},{"location":"k0sctl-install/#2-configure-the-cluster","title":"2. Configure the cluster","text":"<ol> <li> <p>Run the following command to create a k0sctl configuration file:</p> <pre><code>k0sctl init &gt; k0sctl.yaml\n</code></pre> <p>This action creates a <code>k0sctl.yaml</code> file in the current directory:</p> <pre><code>apiVersion: k0sctl.k0sproject.io/v1beta1\nkind: Cluster\nmetadata:\n  name: k0s-cluster\nspec:\n  hosts:\n  - role: controller\n    ssh:\n      address: 10.0.0.1 # replace with the controller's IP address\n      user: root\n      keyPath: ~/.ssh/id_rsa\n  - role: worker\n    ssh:\n      address: 10.0.0.2 # replace with the worker's IP address\n      user: root\n      keyPath: ~/.ssh/id_rsa\n</code></pre> </li> <li> <p>Provide each host with a valid IP address that is reachable by k0sctl, and the connection details for an SSH connection.</p> </li> </ol> <p>Note: Refer to the k0sctl documentation for k0sctl configuration specifications.</p>"},{"location":"k0sctl-install/#3-deploy-the-cluster","title":"3. Deploy the cluster","text":"<p>Run <code>k0sctl apply</code> to perform the cluster deployment:</p> <pre><code>$ k0sctl apply --config k0sctl.yaml\n\n\u2800\u28ff\u28ff\u2847\u2800\u2800\u2880\u28f4\u28fe\u28ff\u281f\u2801\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281b\u2801\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\n\u2800\u28ff\u28ff\u2847\u28e0\u28f6\u28ff\u287f\u280b\u2800\u2800\u2800\u28b8\u28ff\u2847\u2800\u2800\u2800\u28e0\u2800\u2800\u2880\u28e0\u2846\u28b8\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n\u2800\u28ff\u28ff\u28ff\u28ff\u28df\u280b\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u2847\u2800\u28b0\u28fe\u28ff\u2800\u2800\u28ff\u28ff\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n\u2800\u28ff\u28ff\u284f\u283b\u28ff\u28f7\u28e4\u2840\u2800\u2800\u2800\u2838\u281b\u2801\u2800\u2838\u280b\u2801\u2800\u2800\u28ff\u28ff\u2847\u2808\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u28b9\u28ff\u28ff\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n\u2800\u28ff\u28ff\u2847\u2800\u2800\u2819\u28bf\u28ff\u28e6\u28c0\u2800\u2800\u2800\u28e0\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28ff\u28ff\u2847\u28b0\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28fe\u28ff\u28ff\u2800\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\nk0sctl v0.21.0 Copyright 2023, k0sctl authors.\nINFO ==&gt; Running phase: Connect to hosts\nINFO [ssh] 10.0.0.1:22: connected\nINFO [ssh] 10.0.0.2:22: connected\nINFO ==&gt; Running phase: Detect host operating systems\nINFO [ssh] 10.0.0.1:22: is running Ubuntu 20.10\nINFO [ssh] 10.0.0.2:22: is running Ubuntu 20.10\nINFO ==&gt; Running phase: Prepare hosts\nINFO [ssh] 10.0.0.1:22: installing kubectl\nINFO ==&gt; Running phase: Gather host facts\nINFO [ssh] 10.0.0.1:22: discovered 10.12.18.133 as private address\nINFO ==&gt; Running phase: Validate hosts\nINFO ==&gt; Running phase: Gather k0s facts\nINFO ==&gt; Running phase: Download K0s on the hosts\nINFO [ssh] 10.0.0.2:22: downloading k0s v1.34.1+head\nINFO [ssh] 10.0.0.1:22: downloading k0s v1.34.1+head\nINFO ==&gt; Running phase: Configure K0s\nWARN [ssh] 10.0.0.1:22: generating default configuration\nINFO [ssh] 10.0.0.1:22: validating configuration\nINFO [ssh] 10.0.0.1:22: configuration was changed\nINFO ==&gt; Running phase: Initialize K0s Cluster\nINFO [ssh] 10.0.0.1:22: installing k0s controller\nINFO [ssh] 10.0.0.1:22: waiting for the k0s service to start\nINFO [ssh] 10.0.0.1:22: waiting for kubernetes api to respond\nINFO ==&gt; Running phase: Install workers\nINFO [ssh] 10.0.0.1:22: generating token\nINFO [ssh] 10.0.0.2:22: writing join token\nINFO [ssh] 10.0.0.2:22: installing k0s worker\nINFO [ssh] 10.0.0.2:22: starting service\nINFO [ssh] 10.0.0.2:22: waiting for node to become ready\nINFO ==&gt; Running phase: Disconnect from hosts\nINFO ==&gt; Finished in 2m2s\nINFO k0s cluster version v1.34.1+head is now installed\nINFO Tip: To access the cluster you can now fetch the admin kubeconfig using:\nINFO      k0sctl kubeconfig\n</code></pre>"},{"location":"k0sctl-install/#4-access-the-cluster","title":"4. Access the cluster","text":"<p>To access your k0s cluster, use k0sctl to generate a <code>kubeconfig</code> for the purpose.</p> <pre><code>k0sctl kubeconfig &gt; kubeconfig\n</code></pre> <p>With the <code>kubeconfig</code>, you can access your cluster using either kubectl or Lens.</p> <pre><code>kubectl get pods --kubeconfig kubeconfig -A\n</code></pre> <pre><code>NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE\nkube-system   calico-kube-controllers-5f6546844f-w8x27   1/1     Running   0          3m50s\nkube-system   calico-node-vd7lx                          1/1     Running   0          3m44s\nkube-system   coredns-5c98d7d4d8-tmrwv                   1/1     Running   0          4m10s\nkube-system   konnectivity-agent-d9xv2                   1/1     Running   0          3m31s\nkube-system   kube-proxy-xp9r9                           1/1     Running   0          4m4s\nkube-system   metrics-server-6fbcd86f7b-5frtn            1/1     Running   0          3m51s\n</code></pre>"},{"location":"k0sctl-install/#known-limitations","title":"Known limitations","text":"<ul> <li>k0sctl does not perform any discovery of hosts, and thus it only operates on the hosts listed in the provided configuration.</li> <li>k0sctl can only add more nodes to the cluster. It cannot remove existing nodes.</li> </ul>"},{"location":"k0sctl-install/#next-steps","title":"Next Steps","text":"<ul> <li>Control plane configuration options: Networking and datastore configuration</li> <li>Worker node configuration options: Node labels and kubelet arguments</li> <li>Support for cloud providers: Load balancer or storage configuration</li> <li>Installing the Traefik Ingress Controller: Ingress deployment information</li> </ul>"},{"location":"manifests/","title":"Manifest Deployer","text":""},{"location":"manifests/#manifest-deployer","title":"Manifest Deployer","text":"<p>Included with k0s, Manifest Deployer is one of two methods you can use to run k0s with your preferred extensions (the other being by defining your extensions as Helm charts).</p>"},{"location":"manifests/#overview","title":"Overview","text":"<p>Manifest Deployer runs on the controller nodes and provides an easy way to automatically deploy manifests at runtime.</p> <p>By default, k0s reads all manifests under <code>/var/lib/k0s/manifests</code> that end with <code>.yaml</code> and ensures that their state matches the cluster state. It does not read files with other extensions, such as <code>.yml</code>. Moreover, on removal of a manifest file, k0s will automatically prune all of its associated resources.</p> <p>The use of Manifest Deployer is quite similar to the use the <code>kubectl apply</code> command. The main difference between the two is that Manifest Deployer constantly monitors the directory for changes, and thus you do not need to manually apply changes that are made to the manifest files.</p>"},{"location":"manifests/#note","title":"Note","text":"<ul> <li>Each directory that is a direct descendant of <code>/var/lib/k0s/manifests</code> is considered to be its own \"stack\". Nested directories (further subfolders), however, are excluded from the stack mechanism and thus are not automatically deployed by the Manifest Deployer.</li> </ul> <ul> <li>k0s uses the independent stack mechanism for some of its internal in-cluster components, as well as for other resources. Be sure to only touch the manifests that are not managed by k0s.</li> </ul> <ul> <li>Explicitly define the namespace in the manifests (Manifest Deployer does not have a default namespace).</li> </ul>"},{"location":"manifests/#example","title":"Example","text":"<p>To try Manifest Deployer, create a new folder under <code>/var/lib/k0s/manifests</code> and then create a manifest file (such as <code>nginx.yaml</code>) with the following content:</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\n  name: nginx\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  namespace: nginx\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n</code></pre> <p>New pods will appear soon thereafter.</p> <pre><code>sudo k0s kubectl get pods --namespace nginx\n</code></pre> <pre><code>NAME                                READY   STATUS    RESTARTS   AGE\nnginx-deployment-66b6c48dd5-8zq7d   1/1     Running   0          10m\nnginx-deployment-66b6c48dd5-br4jv   1/1     Running   0          10m\nnginx-deployment-66b6c48dd5-sqvhb   1/1     Running   0          10m\n</code></pre>"},{"location":"networking/","title":"Networking (CNI)","text":""},{"location":"networking/#networking","title":"Networking","text":""},{"location":"networking/#in-cluster-networking","title":"In-cluster networking","text":"<p>k0s supports any standard CNI network provider. For convenience, k0s does come bundled with two built-in providers, Kube-router and Calico.</p>"},{"location":"networking/#custom-cni-configuration","title":"Custom CNI configuration","text":"<p>You can opt-out of having k0s manage the network setup and choose instead to use any network plugin that adheres to the CNI specification. To do so, configure <code>custom</code> as the network provider in the k0s configuration file (<code>k0s.yaml</code>). You can deploy the CNI provider you want to use, either with Helm, plain Kubernetes manifests or any other way.</p>"},{"location":"networking/#notes","title":"Notes","text":"<ul> <li>When deploying k0s with the default settings, all pods on a node can communicate with all pods on all nodes. No configuration changes are needed to get started.</li> <li>Once you initialize the cluster with a network provider the only way to change providers is through a full cluster redeployment.</li> </ul>"},{"location":"networking/#kube-router","title":"Kube-router","text":"<p>Kube-router is built into k0s, and so by default the distribution uses it for network provisioning. Kube-router uses the standard Linux networking stack and tools, and you can set up CNI networking without any overlays by using BGP as the main mechanism for in-cluster networking.</p> <ul> <li>Uses a bit less resources (~15%)</li> <li>Does NOT support Windows nodes</li> </ul>"},{"location":"networking/#calico","title":"Calico","text":"<p>In addition to Kube-router, k0s also offers Calico as an alternative, integrated network provider. Calico is a layer 3 container networking solution that routes packets to pods. For example, it supports pod-specific network policies that help secure Kubernetes clusters in demanding use cases. Calico in k0s uses VXLAN by default. However, IP in IP is also supported via the <code>bird</code> mode.</p> <ul> <li>Uses a bit more resources</li> <li>Supports Windows nodes</li> </ul>"},{"location":"networking/#controller-worker-communication","title":"Controller-Worker communication","text":"<p>One goal of k0s is to allow for the deployment of an isolated control plane, which may prevent the establishment of an IP route between controller nodes and the pod network. Thus, to enable this communication path (which is mandated by conformance tests), k0s deploys Konnectivity service to proxy traffic from the API server (control plane) into the worker nodes. This ensures that we can always fulfill all the Kubernetes API functionalities, but still operate the control plane in total isolation from the workers.</p> <p>Note: To allow Konnectivity agents running on the worker nodes to establish the connection, configure your firewalls for outbound access, port 8132. Moreover, configure your firewalls for outbound access, port 6443, in order to access Kube-API from the worker nodes.</p> <p></p>"},{"location":"networking/#required-ports-and-protocols","title":"Required ports and protocols","text":"Protocol Port Service Direction Notes TCP 2380 etcd controller \u27f7 controller TCP 6443 kube-apiserver worker, CLI \u27f6 controller Authenticated Kubernetes API using mTLS, ServiceAccount tokens with RBAC TCP 179 kube-router worker \u27f7 worker BGP routing sessions between peers UDP 4789 calico worker \u27f7 worker Calico VXLAN overlay TCP 10250 kubelet controller, worker \u27f6 host <code>*</code> Authenticated kubelet API for the controller node <code>kube-apiserver</code> (and <code>metrics-server</code> add-ons) using mTLS TCP 9443 k0s api controller \u27f7 controller k0s controller join API, TLS with token auth TCP 8132 konnectivity worker \u27f7 controller Konnectivity is used as \"reverse\" tunnel between kube-apiserver and worker kubelets TCP 112 keepalived controller \u27f7 controller Only required for control plane load balancing VRRPInstances. Unless unicast is explicitly enabled, port 122 works on the ip address 224.0.0.18. 224.0.0.18 is a multicast IP address defined in RFC 3768. <p>You also need enable all traffic to and from the podCIDR and serviceCIDR subnets on nodes with a worker role.</p>"},{"location":"networking/#iptables","title":"iptables","text":"<p><code>iptables</code> can work in two distinct modes, <code>legacy</code> and <code>nftables</code>. k0s auto-detects the mode and prefers <code>nftables</code>. To check which mode k0s is configured with check <code>ls -lah /var/lib/k0s/bin/</code>. The target of the symbolic link <code>iptables</code> reveals the mode which k0s selected. k0s has the same logic as other k8s components, but to ensure all component have picked up the same mode you can check via:</p> <ul> <li>kube-proxy: <code>nsenter -t $(pidof kube-proxy) -m iptables -V</code></li> <li>kube-router: <code>nsenter -t $(pidof kube-router) -m /sbin/iptables -V</code></li> <li>calico: <code>nsenter -t $(pidof -s calico-node) -m iptables -V</code></li> </ul> <p>There are known version incompatibility issues in iptables versions. k0s ships (in <code>/var/lib/k0s/bin</code>) a version of iptables that is tested to interoperate with all other Kubernetes components it ships with. However if you have other tooling (firewalls etc.) on your hosts that uses iptables and the host iptables version is different from the one that k0s (and other Kubernetes components) ship, it may cause networking issues. This is due to the fact that iptables, being user-space tooling, does not provide any strong version compatibility guarantees.</p>"},{"location":"networking/#firewalld-k0s","title":"Firewalld &amp; k0s","text":"<p>If you are using <code>firewalld</code> on your hosts you need to ensure it is configured to use the same <code>FirewallBackend</code> as k0s and other Kubernetes components use. Otherwise networking will be broken in various ways.</p> <p>Here's an example configuration for a tested working networking setup:</p> <pre><code>[root@rhel-test ~]# firewall-cmd --list-all\npublic (active)\n  target: default\n  icmp-block-inversion: no\n  interfaces: eth0\n  sources: 10.244.0.0/16 10.96.0.0/12\n  services: cockpit dhcpv6-client ssh\n  ports: 80/tcp 6443/tcp 8132/tcp 10250/tcp 179/tcp 179/udp\n  protocols:\n  forward: no\n  masquerade: yes\n  forward-ports:\n  source-ports:\n  icmp-blocks:\n  rich rules:\n</code></pre> <p>Basic single node firewalld setup:</p> <pre><code># Allow traffic from podCIDR\n$ firewall-cmd --add-source=10.244.0.0/16 --permanent\n# Allow kubelet API traffic\n$ firewall-cmd --add-port=10250/tcp --permanent\n# Apply firewall changes\n$ firewall-cmd --reload\n</code></pre>"},{"location":"nllb/","title":"Node-local load balancing","text":""},{"location":"nllb/#node-local-load-balancing","title":"Node-local load balancing","text":"<p>For clusters that don't have an externally managed load balancer for the k0s control plane, there is another option to get a highly available control plane, at least from within the cluster. K0s calls this \"node-local load balancing\". In contrast to an externally managed load balancer, node-local load balancing takes place exclusively on the worker nodes. It does not contribute to making the control plane highly available to the outside world (e.g. humans interacting with the cluster using management tools such as Lens or <code>kubectl</code>), but rather makes the cluster itself internally resilient to controller node outages.</p>"},{"location":"nllb/#technical-functionality","title":"Technical functionality","text":"<p>The k0s worker process manages a load balancer on each worker node's loopback interface and configures the relevant components to use that load balancer. This allows for requests from worker components to the control plane to be distributed among all currently available controller nodes, rather than being directed to the controller node that has been used to join a particular worker into the cluster. This improves the reliability and fault tolerance of the cluster in case a controller node becomes unhealthy.</p> <p>Envoy is the only load balancer that is supported so far. Please note that Envoy is not available on ARMv7, so node-local load balancing is currently unavailable on that platform.</p>"},{"location":"nllb/#enabling-in-a-cluster","title":"Enabling in a cluster","text":"<p>In order to use node-local load balancing, the cluster needs to comply with the following:</p> <ul> <li>The cluster doesn't use an externally managed load balancer, i.e. the cluster   configuration doesn't specify a non-empty   <code>spec.api.externalAddress</code>.</li> <li>K0s isn't running as a single node, i.e. it isn't   started using the <code>--single</code> flag.</li> <li>The cluster should have multiple controller nodes. Node-local load balancing   also works with a single controller node, but is only useful in conjunction   with a highly available control plane.</li> </ul> <p>Add the following to the cluster configuration (<code>k0s.yaml</code>):</p> <pre><code>spec:\n  network:\n    nodeLocalLoadBalancing:\n      enabled: true\n      type: EnvoyProxy\n</code></pre> <p>Or alternatively, if using <code>k0sctl</code>, add the following to the k0sctl configuration (<code>k0sctl.yaml</code>):</p> <pre><code>spec:\n  k0s:\n    config:\n      spec:\n        network:\n          nodeLocalLoadBalancing:\n            enabled: true\n            type: EnvoyProxy\n</code></pre> <p>All newly added worker nodes will then use node-local load balancing. The k0s worker process on worker nodes that are already running must be restarted for the new configuration to take effect.</p>"},{"location":"nllb/#full-example-using-k0sctl","title":"Full example using <code>k0sctl</code>","text":"<p>The following example shows a full <code>k0sctl</code> configuration file featuring three controllers and two workers with node-local load balancing enabled:</p> <pre><code>apiVersion: k0sctl.k0sproject.io/v1beta1\nkind: Cluster\nmetadata:\n  name: k0s-cluster\nspec:\n  k0s:\n    version: v1.34.1+head\n    config:\n      spec:\n        network:\n          nodeLocalLoadBalancing:\n            enabled: true\n            type: EnvoyProxy\n  hosts:\n    - role: controller\n      ssh:\n        address: 10.81.146.254\n        keyPath: k0s-ssh-private-key.pem\n        port: 22\n        user: k0s\n    - role: controller\n      ssh:\n        address: 10.81.146.184\n        keyPath: k0s-ssh-private-key.pem\n        port: 22\n        user: k0s\n    - role: controller\n      ssh:\n        address: 10.81.146.113\n        keyPath: k0s-ssh-private-key.pem\n        port: 22\n        user: k0s\n    - role: worker\n      ssh:\n        address: 10.81.146.198\n        keyPath: k0s-ssh-private-key.pem\n        port: 22\n        user: k0s\n    - role: worker\n      ssh:\n        address: 10.81.146.51\n        keyPath: k0s-ssh-private-key.pem\n        port: 22\n        user: k0s\n</code></pre> <p>Save the above configuration into a file called <code>k0sctl.yaml</code> and apply it in order to bootstrap the cluster:</p> <pre><code>$ k0sctl apply\n\u28ff\u28ff\u2847\u2800\u2800\u2880\u28f4\u28fe\u28ff\u281f\u2801\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281b\u2801\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\n\u28ff\u28ff\u2847\u28e0\u28f6\u28ff\u287f\u280b\u2800\u2800\u2800\u28b8\u28ff\u2847\u2800\u2800\u2800\u28e0\u2800\u2800\u2880\u28e0\u2846\u28b8\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n\u28ff\u28ff\u28ff\u28ff\u28df\u280b\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u2847\u2800\u28b0\u28fe\u28ff\u2800\u2800\u28ff\u28ff\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n\u28ff\u28ff\u284f\u283b\u28ff\u28f7\u28e4\u2840\u2800\u2800\u2800\u2838\u281b\u2801\u2800\u2838\u280b\u2801\u2800\u2800\u28ff\u28ff\u2847\u2808\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u28b9\u28ff\u28ff\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n\u28ff\u28ff\u2847\u2800\u2800\u2819\u28bf\u28ff\u28e6\u28c0\u2800\u2800\u2800\u28e0\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28ff\u28ff\u2847\u28b0\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28fe\u28ff\u28ff\u2800\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\nk0sctl v0.21.0 Copyright 2023, k0sctl authors.\nINFO ==&gt; Running phase: Connect to hosts\nINFO [ssh] 10.81.146.254:22: connected\nINFO [ssh] 10.81.146.184:22: connected\nINFO [ssh] 10.81.146.113:22: connected\nINFO [ssh] 10.81.146.51:22: connected\nINFO [ssh] 10.81.146.198:22: connected\nINFO ==&gt; Running phase: Detect host operating systems\nINFO [ssh] 10.81.146.254:22: is running Alpine Linux v3.17\nINFO [ssh] 10.81.146.113:22: is running Alpine Linux v3.17\nINFO [ssh] 10.81.146.184:22: is running Alpine Linux v3.17\nINFO [ssh] 10.81.146.198:22: is running Alpine Linux v3.17\nINFO [ssh] 10.81.146.51:22: is running Alpine Linux v3.17\nINFO ==&gt; Running phase: Acquire exclusive host lock\nINFO ==&gt; Running phase: Prepare hosts\nINFO [ssh] 10.81.146.113:22: installing packages (curl)\nINFO [ssh] 10.81.146.198:22: installing packages (curl, iptables)\nINFO [ssh] 10.81.146.254:22: installing packages (curl)\nINFO [ssh] 10.81.146.51:22: installing packages (curl, iptables)\nINFO [ssh] 10.81.146.184:22: installing packages (curl)\nINFO ==&gt; Running phase: Gather host facts\nINFO [ssh] 10.81.146.184:22: using k0s-controller-1 as hostname\nINFO [ssh] 10.81.146.51:22: using k0s-worker-1 as hostname\nINFO [ssh] 10.81.146.198:22: using k0s-worker-0 as hostname\nINFO [ssh] 10.81.146.113:22: using k0s-controller-2 as hostname\nINFO [ssh] 10.81.146.254:22: using k0s-controller-0 as hostname\nINFO [ssh] 10.81.146.184:22: discovered eth0 as private interface\nINFO [ssh] 10.81.146.51:22: discovered eth0 as private interface\nINFO [ssh] 10.81.146.198:22: discovered eth0 as private interface\nINFO [ssh] 10.81.146.113:22: discovered eth0 as private interface\nINFO [ssh] 10.81.146.254:22: discovered eth0 as private interface\nINFO ==&gt; Running phase: Download k0s binaries to local host\nINFO ==&gt; Running phase: Validate hosts\nINFO ==&gt; Running phase: Gather k0s facts\nINFO ==&gt; Running phase: Validate facts\nINFO ==&gt; Running phase: Upload k0s binaries to hosts\nINFO [ssh] 10.81.146.254:22: uploading k0s binary from /home/k0sctl/.cache/k0sctl/k0s/linux/amd64/k0s-v1.34.1+head\nINFO [ssh] 10.81.146.113:22: uploading k0s binary from /home/k0sctl/.cache/k0sctl/k0s/linux/amd64/k0s-v1.34.1+head\nINFO [ssh] 10.81.146.51:22: uploading k0s binary from /home/k0sctl/.cache/k0sctl/k0s/linux/amd64/k0s-v1.34.1+head\nINFO [ssh] 10.81.146.198:22: uploading k0s binary from /home/k0sctl/.cache/k0sctl/k0s/linux/amd64/k0s-v1.34.1+head\nINFO [ssh] 10.81.146.184:22: uploading k0s binary from /home/k0sctl/.cache/k0sctl/k0s/linux/amd64/k0s-v1.34.1+head\nINFO ==&gt; Running phase: Configure k0s\nINFO [ssh] 10.81.146.254:22: validating configuration\nINFO [ssh] 10.81.146.184:22: validating configuration\nINFO [ssh] 10.81.146.113:22: validating configuration\nINFO [ssh] 10.81.146.113:22: configuration was changed\nINFO [ssh] 10.81.146.184:22: configuration was changed\nINFO [ssh] 10.81.146.254:22: configuration was changed\nINFO ==&gt; Running phase: Initialize the k0s cluster\nINFO [ssh] 10.81.146.254:22: installing k0s controller\nINFO [ssh] 10.81.146.254:22: waiting for the k0s service to start\nINFO [ssh] 10.81.146.254:22: waiting for kubernetes api to respond\nINFO ==&gt; Running phase: Install controllers\nINFO [ssh] 10.81.146.254:22: generating token\nINFO [ssh] 10.81.146.184:22: writing join token\nINFO [ssh] 10.81.146.184:22: installing k0s controller\nINFO [ssh] 10.81.146.184:22: starting service\nINFO [ssh] 10.81.146.184:22: waiting for the k0s service to start\nINFO [ssh] 10.81.146.184:22: waiting for kubernetes api to respond\nINFO [ssh] 10.81.146.254:22: generating token\nINFO [ssh] 10.81.146.113:22: writing join token\nINFO [ssh] 10.81.146.113:22: installing k0s controller\nINFO [ssh] 10.81.146.113:22: starting service\nINFO [ssh] 10.81.146.113:22: waiting for the k0s service to start\nINFO [ssh] 10.81.146.113:22: waiting for kubernetes api to respond\nINFO ==&gt; Running phase: Install workers\nINFO [ssh] 10.81.146.51:22: validating api connection to https://10.81.146.254:6443\nINFO [ssh] 10.81.146.198:22: validating api connection to https://10.81.146.254:6443\nINFO [ssh] 10.81.146.254:22: generating token\nINFO [ssh] 10.81.146.198:22: writing join token\nINFO [ssh] 10.81.146.51:22: writing join token\nINFO [ssh] 10.81.146.198:22: installing k0s worker\nINFO [ssh] 10.81.146.51:22: installing k0s worker\nINFO [ssh] 10.81.146.198:22: starting service\nINFO [ssh] 10.81.146.51:22: starting service\nINFO [ssh] 10.81.146.198:22: waiting for node to become ready\nINFO [ssh] 10.81.146.51:22: waiting for node to become ready\nINFO ==&gt; Running phase: Release exclusive host lock\nINFO ==&gt; Running phase: Disconnect from hosts\nINFO ==&gt; Finished in 3m30s\nINFO k0s cluster version v1.34.1+head is now installed\nINFO Tip: To access the cluster you can now fetch the admin kubeconfig using:\nINFO      k0sctl kubeconfig\n</code></pre> <p>The cluster with the two nodes should be available by now. Setup the kubeconfig file in order to interact with it:</p> <pre><code>k0sctl kubeconfig &gt; k0s-kubeconfig\nexport KUBECONFIG=$(pwd)/k0s-kubeconfig\n</code></pre> <p>The three controllers are available and provide API Server endpoints:</p> <pre><code>$ kubectl -n kube-node-lease get \\\n    lease/k0s-ctrl-k0s-controller-0 \\\n    lease/k0s-ctrl-k0s-controller-1 \\\n    lease/k0s-ctrl-k0s-controller-2 \\\n    lease/k0s-endpoint-reconciler\nNAME                        HOLDER                                                             AGE\nk0s-ctrl-k0s-controller-0   9ec2b221890e5ed6f4cc70377bfe809fef5be541a2774dc5de81db7acb2786f1   2m37s\nk0s-ctrl-k0s-controller-1   fe45284924abb1bfce674e5a9aa8d647f17c81e53bbab17cf28288f13d5e8f97   2m18s\nk0s-ctrl-k0s-controller-2   5ab43278e63fc863b2a7f0fe1aab37316a6db40c5a3d8a17b9d35b5346e23b3d   2m9s\nk0s-endpoint-reconciler     9ec2b221890e5ed6f4cc70377bfe809fef5be541a2774dc5de81db7acb2786f1   2m37s\n\n$ kubectl -n default get endpoints\nNAME         ENDPOINTS                                                  AGE\nkubernetes   10.81.146.113:6443,10.81.146.184:6443,10.81.146.254:6443   2m49s\n</code></pre> <p>The first controller is the current k0s leader. The two worker nodes can be listed, too:</p> <pre><code>$ kubectl get nodes -owide\nNAME           STATUS   ROLES    AGE     VERSION       INTERNAL-IP     EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION   CONTAINER-RUNTIME\nk0s-worker-0   Ready    &lt;none&gt;   2m16s   v1.34.1+k0s   10.81.146.198   &lt;none&gt;        Alpine Linux v3.17   5.15.83-0-virt   containerd://1.7.27\nk0s-worker-1   Ready    &lt;none&gt;   2m15s   v1.34.1+k0s   10.81.146.51    &lt;none&gt;        Alpine Linux v3.17   5.15.83-0-virt   containerd://1.7.27\n</code></pre> <p>There is one node-local load balancer pod running for each worker node:</p> <pre><code>$ kubectl -n kube-system get pod -owide -l app.kubernetes.io/managed-by=k0s,app.kubernetes.io/component=nllb\nNAME                READY   STATUS    RESTARTS   AGE   IP              NODE           NOMINATED NODE   READINESS GATES\nnllb-k0s-worker-0   1/1     Running   0          81s   10.81.146.198   k0s-worker-0   &lt;none&gt;           &lt;none&gt;\nnllb-k0s-worker-1   1/1     Running   0          85s   10.81.146.51    k0s-worker-1   &lt;none&gt;           &lt;none&gt;\n</code></pre> <p>The cluster is using node-local load balancing and is able to tolerate the outage of one controller node. Shutdown the first controller to simulate a failure condition:</p> <pre><code>$ ssh -i k0s-ssh-private-key.pem k0s@10.81.146.254 'echo \"Powering off $(hostname) ...\" &amp;&amp; sudo poweroff'\nPowering off k0s-controller-0 ...\n</code></pre> <p>Node-local load balancing provides high availability from within the cluster, not from the outside. The generated kubeconfig file lists the first controller's IP as the Kubernetes API server address by default. As this controller is gone by now, a subsequent call to <code>kubectl</code> will fail:</p> <pre><code>$ kubectl get nodes\nUnable to connect to the server: dial tcp 10.81.146.254:6443: connect: no route to host\n</code></pre> <p>Changing the server address in <code>k0s-kubeconfig</code> from the first controller to another one makes the cluster accessible again. Pick one of the other controller IP addresses and put that into the kubeconfig file. The addresses are listed both in <code>k0sctl.yaml</code> as well as in the output of <code>kubectl -n default get endpoints</code> above.</p> <pre><code>$ ssh -i k0s-ssh-private-key.pem k0s@10.81.146.184 hostname\nk0s-controller-1\n\n$ sed -i s#https://10\\\\.81\\\\.146\\\\.254:6443#https://10.81.146.184:6443#g k0s-kubeconfig\n\n$ kubectl get nodes -owide\nNAME           STATUS   ROLES    AGE     VERSION       INTERNAL-IP     EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION   CONTAINER-RUNTIME\nk0s-worker-0   Ready    &lt;none&gt;   3m35s   v1.34.1+k0s   10.81.146.198   &lt;none&gt;        Alpine Linux v3.17   5.15.83-0-virt   containerd://1.7.27\nk0s-worker-1   Ready    &lt;none&gt;   3m34s   v1.34.1+k0s   10.81.146.51    &lt;none&gt;        Alpine Linux v3.17   5.15.83-0-virt   containerd://1.7.27\n\n$ kubectl -n kube-system get pods -owide -l app.kubernetes.io/managed-by=k0s,app.kubernetes.io/component=nllb\nNAME                READY   STATUS    RESTARTS   AGE     IP              NODE           NOMINATED NODE   READINESS GATES\nnllb-k0s-worker-0   1/1     Running   0          2m31s   10.81.146.198   k0s-worker-0   &lt;none&gt;           &lt;none&gt;\nnllb-k0s-worker-1   1/1     Running   0          2m35s   10.81.146.51    k0s-worker-1   &lt;none&gt;           &lt;none&gt;\n</code></pre> <p>The first controller is no longer active. Its IP address is not listed in the <code>default/kubernetes</code> Endpoints resource and its k0s controller lease is orphaned:</p> <pre><code>$ kubectl -n default get endpoints\nNAME         ENDPOINTS                               AGE\nkubernetes   10.81.146.113:6443,10.81.146.184:6443   3m56s\n\n$ kubectl -n kube-node-lease get \\\n    lease/k0s-ctrl-k0s-controller-0 \\\n    lease/k0s-ctrl-k0s-controller-1 \\\n    lease/k0s-ctrl-k0s-controller-2 \\\n    lease/k0s-endpoint-reconciler\nNAME                        HOLDER                                                             AGE\nk0s-ctrl-k0s-controller-0                                                                      4m47s\nk0s-ctrl-k0s-controller-1   fe45284924abb1bfce674e5a9aa8d647f17c81e53bbab17cf28288f13d5e8f97   4m28s\nk0s-ctrl-k0s-controller-2   5ab43278e63fc863b2a7f0fe1aab37316a6db40c5a3d8a17b9d35b5346e23b3d   4m19s\nk0s-endpoint-reconciler     5ab43278e63fc863b2a7f0fe1aab37316a6db40c5a3d8a17b9d35b5346e23b3d   4m47s\n</code></pre> <p>Despite that controller being unavailable, the cluster remains operational. The third controller has become the new k0s leader. Workloads will run just fine:</p> <pre><code>$ kubectl -n default run nginx --image=nginx\npod/nginx created\n\n$ kubectl -n default get pods -owide\nNAME    READY   STATUS    RESTARTS   AGE   IP           NODE           NOMINATED NODE   READINESS GATES\nnginx   1/1     Running   0          16s   10.244.0.5   k0s-worker-1   &lt;none&gt;           &lt;none&gt;\n\n$ kubectl -n default logs nginx\n/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration\n/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh\n10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf\n10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh\n/docker-entrypoint.sh: Configuration complete; ready for start up\n[notice] 1#1: using the \"epoll\" event method\n[notice] 1#1: nginx/1.23.3\n[notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)\n[notice] 1#1: OS: Linux 5.15.83-0-virt\n[notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576\n[notice] 1#1: start worker processes\n[notice] 1#1: start worker process 28\n</code></pre>"},{"location":"podsecurity/","title":"Pod Security Standards","text":""},{"location":"podsecurity/#pod-security-standards","title":"Pod Security Standards","text":"<p>Since Pod Security Policies have been removed in Kubernetes v1.25, Kubernetes offers Pod Security Standards \u2013 a new way to enhance cluster security.</p> <p>To enable Pod Security Standards in k0s, create an admission controller configuration file:</p> <pre><code>```yaml\napiVersion: apiserver.config.k8s.io/v1\nkind: AdmissionConfiguration\nplugins:\n- name: PodSecurity\n  configuration:\n    apiVersion: pod-security.admission.config.k8s.io/v1beta1\n    kind: PodSecurityConfiguration\n    # Defaults applied when a mode label is not set.\n    defaults:\n      enforce: \"privileged\"\n      enforce-version: \"latest\"\n    exemptions:\n      # Don't forget to exempt namespaces or users that are responsible for deploying\n      # cluster components, because they need to run privileged containers\n      usernames: [\"admin\"]\n      namespaces: [\"kube-system\"]\n```\n</code></pre> <p>Add these extra arguments to the k0s configuration:</p> <pre><code>```yaml\napiVersion: k0s.k0sproject.io/v1beta1\nkind: ClusterConfig\nspec:\n  api:\n    extraArgs:\n      admission-control-config-file: /path/to/admission/control/config.yaml\n```\n</code></pre>"},{"location":"raspberry-pi4/","title":"Raspberry Pi 4","text":""},{"location":"raspberry-pi4/#create-a-raspberry-pi-4-cluster","title":"Create a Raspberry Pi 4 cluster","text":""},{"location":"raspberry-pi4/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes that you use a Raspberry Pi 4 Model B computer and a sufficiently large SD card of at least 32 GB. We will be using Ubuntu Linux for this guide, although k0s should run quite fine on other 64-bit Linux distributions for the Raspberry Pi as well. Please file a Bug if you encounter any obstacles.</p>"},{"location":"raspberry-pi4/#set-up-the-system","title":"Set up the system","text":""},{"location":"raspberry-pi4/#prepare-sd-card-and-boot-up-the-raspberry-pi","title":"Prepare SD card and boot up the Raspberry Pi","text":"<p>Install Ubuntu Server 22.04.1 LTS 64-bit for Raspberry Pi. Ubuntu provides a step by step guide for the installation process. They use Raspberry Pi Imager, a specialized imaging utility that you can use to write the Ubuntu image, amongst others, to your SD cards. Follow that guide to get a working installation. (You can skip part 5 of the guide, since we won't need a Desktop Environment to run k0s.)</p> <p>Alternatively, you can also opt to download the Ubuntu server image for Raspberry Pi manually and write it to an SD card using a tool like <code>dd</code>:</p> <pre><code>wget https://cdimage.ubuntu.com/releases/22.04.1/release/ubuntu-22.04.1-preinstalled-server-arm64+raspi.img.xz\nunxz ubuntu-22.04.1-preinstalled-server-arm64+raspi.img.xz\ndd if=ubuntu-22.04.1-preinstalled-server-arm64+raspi.img of=/dev/mmcblk0 bs=4M status=progress\n</code></pre> <p>Note: The manual process is more prone to accidental data loss than the guided one via Raspberry Pi Imager. Be sure to choose the correct device names. The previous content of the SD card will be wiped. Moreover, the partition written to the SD card needs to be resized to make the full capacity of the card available to Ubuntu. This can be achieved, for example, in this way:</p> <pre><code>growpart /dev/mmcblk0 2\nresize2fs /dev/mmcblk0p2\n</code></pre> <p>Ubuntu uses cloud-init to allow for automated customizations of the system configuration. The cloud-init configuration files are located on the boot partition of the SD card. You can mount that partition and modify those, e.g. to provision network configuration, users, authorized SSH keys, additional packages and also an automatic installation of k0s.</p> <p>After you have prepared the SD card, plug it into the Raspberry Pi and boot it up. Once cloud-init finished bootstrapping the system, the default login credentials are set to user <code>ubuntu</code> with password <code>ubuntu</code> (which you will be prompted to change on first login).</p>"},{"location":"raspberry-pi4/#review-network-configurations","title":"Review network configurations","text":"<p>Note: For network configuration purposes, this documentation assumes that all of your computers are connected on the same subnet.</p> <p>Review k0s's required ports and protocols to ensure that your network and firewall configurations allow necessary traffic for the cluster.</p> <p>Review the Ubuntu Server Networking Configuration documentation to ensure that all systems have a static IP address on the network, or that the network is providing a static DHCP lease for the nodes. If the network should be managed via cloud-init, please refer to their documentation.</p>"},{"location":"raspberry-pi4/#optional-provision-ssh-keys","title":"(Optional) Provision SSH keys","text":"<p>Ubuntu Server deploys and enables OpenSSH via cloud-init by default. Confirm, though, that for whichever user you will deploy the cluster with on the build system, their SSH Key is copied to each node's root user. Before you start, the configuration should be such that the current user can run:</p> <pre><code>ssh root@${HOST}\n</code></pre> <p>Where <code>${HOST}</code> is any node and the login can succeed with no further prompts.</p>"},{"location":"raspberry-pi4/#optional-create-a-swap-file","title":"(Optional) Create a swap file","text":"<p>While having a swap file is technically optional, it can help to ease memory pressure when running memory intensive workloads or on Raspberry Pis with less than 8 GB of RAM.</p> <ol> <li> <p>To create a swap file:</p> <pre><code>fallocate -l 2G /swapfile &amp;&amp; \\\nchmod 0600 /swapfile &amp;&amp; \\\nmkswap /swapfile &amp;&amp; \\\nswapon -a\n</code></pre> </li> <li> <p>Ensure that the usage of swap is not too aggressive by setting the <code>sudo    sysctl vm.swappiness=10</code> (the default is generally higher) and configuring it    to be persistent in <code>/etc/sysctl.d/*</code>.</p> </li> <li> <p>Ensure that your swap is mounted after reboots by confirming that the    following line exists in your <code>/etc/fstab</code> configuration:</p> <pre><code>/swapfile         none           swap sw       0 0\n</code></pre> </li> </ol>"},{"location":"raspberry-pi4/#download-k0s","title":"Download k0s","text":"<p>Download a k0s release. For example:</p> <pre><code>wget -O /tmp/k0s https://github.com/k0sproject/k0s/releases/download/v1.34.1+head/k0s-v1.34.1+head-arm64 # replace version number!\nsudo install /tmp/k0s /usr/local/bin/k0s\n</code></pre> <p>\u2015 or \u2015</p> <p>Use the k0s download script (as one command) to download the latest stable k0s and make it executable in <code>/usr/bin/k0s</code>.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://get.k0s.sh | sudo sh\n</code></pre> <p>At this point you can run <code>k0s</code>:</p> <pre><code>ubuntu@ubuntu:~$ k0s version\nv1.34.1+head\n</code></pre> <p>To check if k0s's system requirements and external runtime dependencies are fulfilled by your current setup, you can invoke <code>k0s sysinfo</code>:</p> <pre><code>ubuntu@ubuntu:~$ k0s sysinfo\nTotal memory: 3.7 GiB (pass)\nFile system of /var/lib: ext4 (pass)\nDisk space available for /var/lib/k0s: 83.6 GiB (pass)\nRelative disk space available for /var/lib/k0s: 20% (pass)\nOperating system: Linux (pass)\n  Linux kernel release: 5.15.0-1013-raspi (pass)\n  Max. file descriptors per process: current: 1024 / max: 1048576 (warning: &lt; 65536)\n  AppArmor: unavailable (pass)\n  Executable in PATH: modprobe: /usr/sbin/modprobe (pass)\n  Executable in PATH: mount: /usr/bin/mount (pass)\n  Executable in PATH: umount: /usr/bin/umount (pass)\n  /proc file system: mounted (0x9fa0) (pass)\n  Control Groups: version 2 (pass)\n    cgroup controller \"cpu\": available (pass)\n    cgroup controller \"cpuacct\": available (via cpu in version 2) (pass)\n    cgroup controller \"cpuset\": available (pass)\n    cgroup controller \"memory\": available (pass)\n    cgroup controller \"devices\": unknown (warning: insufficient permissions, try with elevated permissions)\n    cgroup controller \"freezer\": available (cgroup.freeze exists) (pass)\n    cgroup controller \"pids\": available (pass)\n    cgroup controller \"hugetlb\": available (pass)\n    cgroup controller \"blkio\": available (via io in version 2) (pass)\n  CONFIG_CGROUPS: Control Group support: built-in (pass)\n    CONFIG_CGROUP_SCHED: Group CPU scheduler: built-in (pass)\n      CONFIG_FAIR_GROUP_SCHED: Group scheduling for SCHED_OTHER: built-in (pass)\n        CONFIG_CFS_BANDWIDTH: CPU bandwidth provisioning for FAIR_GROUP_SCHED: built-in (pass)\n    CONFIG_BLK_CGROUP: Block IO controller: built-in (pass)\n  CONFIG_NAMESPACES: Namespaces support: built-in (pass)\n    CONFIG_UTS_NS: UTS namespace: built-in (pass)\n    CONFIG_IPC_NS: IPC namespace: built-in (pass)\n    CONFIG_PID_NS: PID namespace: built-in (pass)\n    CONFIG_NET_NS: Network namespace: built-in (pass)\n  CONFIG_NET: Networking support: built-in (pass)\n    CONFIG_INET: TCP/IP networking: built-in (pass)\n      CONFIG_IPV6: The IPv6 protocol: built-in (pass)\n    CONFIG_NETFILTER: Network packet filtering framework (Netfilter): built-in (pass)\n      CONFIG_NETFILTER_ADVANCED: Advanced netfilter configuration: built-in (pass)\n      CONFIG_NF_CONNTRACK: Netfilter connection tracking support: module (pass)\n      CONFIG_NETFILTER_XTABLES: Netfilter Xtables support: module (pass)\n        CONFIG_NETFILTER_XT_TARGET_REDIRECT: REDIRECT target support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_COMMENT: \"comment\" match support: module (pass)\n        CONFIG_NETFILTER_XT_MARK: nfmark target and match support: module (pass)\n        CONFIG_NETFILTER_XT_SET: set target and match support: module (pass)\n        CONFIG_NETFILTER_XT_TARGET_MASQUERADE: MASQUERADE target support: module (pass)\n        CONFIG_NETFILTER_XT_NAT: \"SNAT and DNAT\" targets support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_ADDRTYPE: \"addrtype\" address type match support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_CONNTRACK: \"conntrack\" connection tracking match support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_MULTIPORT: \"multiport\" Multiple port match support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_RECENT: \"recent\" match support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_STATISTIC: \"statistic\" match support: module (pass)\n      CONFIG_NETFILTER_NETLINK: module (pass)\n      CONFIG_NF_NAT: module (pass)\n      CONFIG_IP_SET: IP set support: module (pass)\n        CONFIG_IP_SET_HASH_IP: hash:ip set support: module (pass)\n        CONFIG_IP_SET_HASH_NET: hash:net set support: module (pass)\n      CONFIG_IP_VS: IP virtual server support: module (pass)\n        CONFIG_IP_VS_NFCT: Netfilter connection tracking: built-in (pass)\n        CONFIG_IP_VS_SH: Source hashing scheduling: module (pass)\n        CONFIG_IP_VS_RR: Round-robin scheduling: module (pass)\n        CONFIG_IP_VS_WRR: Weighted round-robin scheduling: module (pass)\n      CONFIG_NF_CONNTRACK_IPV4: IPv4 connection tracking support (required for NAT): unknown (warning)\n      CONFIG_NF_REJECT_IPV4: IPv4 packet rejection: module (pass)\n      CONFIG_NF_NAT_IPV4: IPv4 NAT: unknown (warning)\n      CONFIG_IP_NF_IPTABLES: IP tables support: module (pass)\n        CONFIG_IP_NF_FILTER: Packet filtering: module (pass)\n          CONFIG_IP_NF_TARGET_REJECT: REJECT target support: module (pass)\n        CONFIG_IP_NF_NAT: iptables NAT support: module (pass)\n        CONFIG_IP_NF_MANGLE: Packet mangling: module (pass)\n      CONFIG_NF_DEFRAG_IPV4: module (pass)\n      CONFIG_NF_CONNTRACK_IPV6: IPv6 connection tracking support (required for NAT): unknown (warning)\n      CONFIG_NF_NAT_IPV6: IPv6 NAT: unknown (warning)\n      CONFIG_IP6_NF_IPTABLES: IP6 tables support: module (pass)\n        CONFIG_IP6_NF_FILTER: Packet filtering: module (pass)\n        CONFIG_IP6_NF_MANGLE: Packet mangling: module (pass)\n        CONFIG_IP6_NF_NAT: ip6tables NAT support: module (pass)\n      CONFIG_NF_DEFRAG_IPV6: module (pass)\n    CONFIG_BRIDGE: 802.1d Ethernet Bridging: module (pass)\n      CONFIG_LLC: module (pass)\n      CONFIG_STP: module (pass)\n  CONFIG_EXT4_FS: The Extended 4 (ext4) filesystem: built-in (pass)\n  CONFIG_PROC_FS: /proc file system support: built-in (pass)\n</code></pre>"},{"location":"raspberry-pi4/#deploy-a-node","title":"Deploy a node","text":"<p>Each node can now serve as a control plane node or worker node or both.</p>"},{"location":"raspberry-pi4/#as-single-node","title":"As single node","text":"<p>This is a self-contained single node setup which runs both control plane components and worker components. If you don't plan join any more nodes into the cluster, this is for you.</p> <p>Install the <code>k0scontroller</code> service:</p> <pre><code>ubuntu@ubuntu:~$ sudo k0s install controller --single\nubuntu@ubuntu:~$ sudo systemctl status k0scontroller.service\n\u25cb k0scontroller.service - k0s - Zero Friction Kubernetes\n     Loaded: loaded (/etc/systemd/system/k0scontroller.service; enabled; vendor preset: enabled)\n     Active: inactive (dead)\n       Docs: https://docs.k0sproject.io\n</code></pre> <p>Start it:</p> <pre><code>ubuntu@ubuntu:~$ sudo systemctl start k0scontroller.service\nubuntu@ubuntu:~$ systemctl status k0scontroller.service\n\u25cf k0scontroller.service - k0s - Zero Friction Kubernetes\n     Loaded: loaded (/etc/systemd/system/k0scontroller.service; enabled; vendor preset: enabled)\n     Active: active (running) since Thu 2022-08-18 09:56:02 UTC; 2s ago\n       Docs: https://docs.k0sproject.io\n   Main PID: 2720 (k0s)\n      Tasks: 10\n     Memory: 24.7M\n        CPU: 4.654s\n     CGroup: /system.slice/k0scontroller.service\n             \u2514\u25002720 /usr/local/bin/k0s controller --single=true\n\nAug 18 09:56:04 ubuntu k0s[2720]: 2022/08/18 09:56:04 [INFO] received CSR\nAug 18 09:56:04 ubuntu k0s[2720]: 2022/08/18 09:56:04 [INFO] generating key: rsa-2048\nAug 18 09:56:04 ubuntu k0s[2720]: 2022/08/18 09:56:04 [INFO] received CSR\nAug 18 09:56:04 ubuntu k0s[2720]: 2022/08/18 09:56:04 [INFO] generating key: rsa-2048\nAug 18 09:56:04 ubuntu k0s[2720]: 2022/08/18 09:56:04 [INFO] received CSR\nAug 18 09:56:04 ubuntu k0s[2720]: 2022/08/18 09:56:04 [INFO] generating key: rsa-2048\nAug 18 09:56:04 ubuntu k0s[2720]: 2022/08/18 09:56:04 [INFO] encoded CSR\nAug 18 09:56:04 ubuntu k0s[2720]: 2022/08/18 09:56:04 [INFO] signed certificate with serial number 6275509116227039894094374442676315636193163621\nAug 18 09:56:04 ubuntu k0s[2720]: 2022/08/18 09:56:04 [INFO] encoded CSR\nAug 18 09:56:04 ubuntu k0s[2720]: 2022/08/18 09:56:04 [INFO] signed certificate with serial number 336800507542010809697469355930007636411790073226\n</code></pre> <p>When the cluster is up, try to have a look:</p> <pre><code>ubuntu@ubuntu:~$ sudo k0s kc get nodes -owide\nNAME     STATUS   ROLES           AGE     VERSION       INTERNAL-IP    EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME\nubuntu   Ready    control-plane   4m41s   v1.34.1+k0s   10.152.56.54   &lt;none&gt;        Ubuntu 22.04.1 LTS   5.15.0-1013-raspi   containerd://1.7.27\nubuntu@ubuntu:~$ sudo k0s kc get pod -owide -A\nNAMESPACE     NAME                              READY   STATUS    RESTARTS   AGE     IP             NODE     NOMINATED NODE   READINESS GATES\nkube-system   kube-proxy-kkv2l                  1/1     Running   0          4m44s   10.152.56.54   ubuntu   &lt;none&gt;           &lt;none&gt;\nkube-system   kube-router-vf2pv                 1/1     Running   0          4m44s   10.152.56.54   ubuntu   &lt;none&gt;           &lt;none&gt;\nkube-system   coredns-88b745646-wd4mp           1/1     Running   0          5m10s   10.244.0.2     ubuntu   &lt;none&gt;           &lt;none&gt;\nkube-system   metrics-server-7d7c4887f4-ssk49   1/1     Running   0          5m6s    10.244.0.3     ubuntu   &lt;none&gt;           &lt;none&gt;\n</code></pre> <p>Overall, the single k0s node uses less than 1 GiB of RAM:</p> <pre><code>ubuntu@ubuntu:~$ free -h\n               total        used        free      shared  buff/cache   available\nMem:           3.7Gi       715Mi       1.3Gi       3.0Mi       1.7Gi       2.8Gi\nSwap:             0B          0B          0B\n</code></pre>"},{"location":"raspberry-pi4/#as-a-controller-node","title":"As a controller node","text":"<p>This will install k0s as a single non-HA controller. It won't be able to run any workloads, so you need to connect more workers to it.</p> <p>Install the <code>k0scontroller</code> service. Note that we're not specifying any flags:</p> <pre><code>ubuntu@ubuntu:~$ sudo k0s install controller\nubuntu@ubuntu:~$ systemctl status k0scontroller.service\n\u25cb k0scontroller.service - k0s - Zero Friction Kubernetes\n     Loaded: loaded (/etc/systemd/system/k0scontroller.service; enabled; vendor preset: enabled)\n     Active: inactive (dead)\n       Docs: https://docs.k0sproject.io\n</code></pre> <p>Start it:</p> <pre><code>ubuntu@ubuntu:~$ sudo systemctl start k0scontroller.service\nubuntu@ubuntu:~$ systemctl status k0scontroller.service\n\u25cf k0scontroller.service - k0s - Zero Friction Kubernetes\n     Loaded: loaded (/etc/systemd/system/k0scontroller.service; enabled; vendor preset: enabled)\n     Active: active (running) since Thu 2022-08-18 10:31:07 UTC; 3s ago\n       Docs: https://docs.k0sproject.io\n   Main PID: 1176 (k0s)\n      Tasks: 10\n     Memory: 30.2M\n        CPU: 8.936s\n     CGroup: /system.slice/k0scontroller.service\n             \u2514\u25001176 /usr/local/bin/k0s controller\n\nAug 18 10:31:09 ubuntu k0s[1176]: 2022/08/18 10:31:09 [INFO] signed certificate with serial number 723202396395786987172578079268287418983457689579\nAug 18 10:31:09 ubuntu k0s[1176]: 2022/08/18 10:31:09 [INFO] encoded CSR\nAug 18 10:31:09 ubuntu k0s[1176]: 2022/08/18 10:31:09 [INFO] signed certificate with serial number 36297085497443583023060005045470362249819432477\nAug 18 10:31:09 ubuntu k0s[1176]: 2022/08/18 10:31:09 [INFO] encoded CSR\nAug 18 10:31:09 ubuntu k0s[1176]: 2022/08/18 10:31:09 [INFO] encoded CSR\nAug 18 10:31:09 ubuntu k0s[1176]: 2022/08/18 10:31:09 [INFO] signed certificate with serial number 728910847354665355109188021924183608444435075827\nAug 18 10:31:09 ubuntu k0s[1176]: 2022/08/18 10:31:09 [INFO] generate received request\nAug 18 10:31:09 ubuntu k0s[1176]: 2022/08/18 10:31:09 [INFO] received CSR\nAug 18 10:31:09 ubuntu k0s[1176]: 2022/08/18 10:31:09 [INFO] generating key: rsa-2048\nAug 18 10:31:09 ubuntu k0s[1176]: 2022/08/18 10:31:09 [INFO] signed certificate with serial number 718948898553094584370065610752227487244528071083\n</code></pre> <p>As soon as the controller is up, we can try to inspect the API as we did for the single node:</p> <pre><code>ubuntu@ubuntu:~$ sudo k0s kc get nodes -owide\nNo resources found\nubuntu@ubuntu:~$ sudo k0s kc get pod -owide -A\nNAMESPACE     NAME                              READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES\nkube-system   coredns-88b745646-6tpwm           0/1     Pending   0          29s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           &lt;none&gt;\nkube-system   metrics-server-7d7c4887f4-9k5k5   0/1     Pending   0          24s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           &lt;none&gt;\n</code></pre> <p>As we see, there are no nodes and two pending pods. A control plane without workers. The memory consumption is below the single node controller, but not much:</p> <pre><code>ubuntu@ubuntu:~$ free -h\n               total        used        free      shared  buff/cache   available\nMem:           3.7Gi       678Mi       2.3Gi       3.0Mi       758Mi       2.9Gi\nSwap:             0B          0B          0B\n</code></pre> <p>This controller runs a full-fledged control plane, backed by etcd, as opposed to the lightweight kine based one from the single node example. For the latter, k0s doesn't support joining new nodes.</p> <p>More nodes can be added by creating join tokens. To add a worker node, create a token for it:</p> <pre><code>ubuntu@ubuntu:~$ sudo k0s token create --role worker\nH4sIAAAAAAAC/2yV0Y6jPBKF7/MUeYGZ30DonUTai5+Ak5DgbhuXHXwHmAnBhtAJHdKs9t1XnZmRdqW9K1cdfceyrDqzvD+L6no7X7rV/O7MSvtxG6rrbTX7Nv9dr2bz+Xx+q6736rqa18PQ31Z//eWg747vfvdfvvuL1cti4T1VZXUdzj/PZT5U3/KPob5cz8PnN50P+Wp+SNFwSJ01Ax3zcxAyEUMKKqYIA3vO0LA2TpwCC1hEQipFrxD2UogDhawQobWJY297jxHBCdbS70hIvWKTOMWGBcwhgUaMSegPhdPH+VY13GDGYNxTiwONdMSEJtTiLeVYMMALDn6dOKqXtt5r0WfQPpqK43cpWKBAecnWktxEiAvWVZEDghPCorhmXTlWp/7PTPz3jEPcVZF6p0KsFfIlNZiIiB11iFUhlJ+1jkxwn/EjU4kRnnI1zsEJkkiH4OHt2pI4a0gEINZUYEEhQinEkUb4qU0Rvn+9CQD5UKJ0dKfG1NVZ2dWCcfCkHFDKycjbYZuGIsk5DngY7Svcn3N5mdIGm1yylkU+Srcxyiy7l50ZRUTvGqtcNuK9QAvEjcihu4yJh/sipC5xy4nBssut9UrcB6nENz72JnfxKLBmxAseZftgyhHvfLIjaeK+PNYX2tmwkKQrGjPlSFAI2VRKmyZmidjnsGCefRfe6Vp4p6veBk0FCtaN/uBu7JAp9kS6nFKDCQvxVUXYsGPiFji+VU05UtFvdLt8oVK8JRE+5m6fZfbvBcGa8QhH0pzG6vxjLEOSEJvtZdRvhNSywNmCejEihiRMYp/IH34utZc6GpdwWwgbc9Hhh5Q+4ushLeXJEZ6t85YBCLxTTfwmGhyWW+HC2B+AE1DnYdK4l9pYJ/P0jhn1mrsq1MbHKYqcRO6cyuAQQG/kRlsq2aOK/HVp2FZKDVRqQg0OmNuz3MTB2jgBiXSQCGHYVmN6XnoAItDIrmnbBxDFHbdqB8ZZU5ktGMRAgQUApzuH3chQ9BCSRcrBR2riVCHxBt5ln3kYlXKxKKI6JEizV4wn3tWyMMk1N/iVtvpayvqaQ+nrKfj6gxMzOOCIBF/+cBQv4JG4AnATe0GZjUNy6gcWkkG5CJGpntKGTnzb472XfeqtekuQzqsWua+bpaw2j9d0ih02YZauh5y4/v7gqZzY2lYmVuWkahFqzF0cri1jbPu3n4d6nVp10G4fVw3OZbp8VabfaQfvtWN9zYNOdfVYmIWjz4PMzOOFmv5Nb3u39CgqXdUCth4xyxrwaQ8Oc3On9xIet3mHmewCj7kJgmP/pr3os5i0oLx+1+4yyj1mcwuTmDIko50DpndhWwNxHwcQQSuEGFljI0Z7lYJ1EhgnguJ3PukPYXr3VbJYOCdE5ECSFpBqgrDEpzFzRSfFxSUgIrJhUQZxW5jazxpCk445CfK3RMbHdcOGtL2N0O7uAuyCId8A0izZ4B2EseQb55EgwVX7+CyjmB9c1eSTVQXeLWiDj4CjUW7ZXXl9nR7pqDYKUXnZqyZ4r46x98bR/vduxtzQE0UiFZHdpEACEcFzLx/o5Z+z+bzL22o1N+g2Ky/dUD2GXznxq/6VE39C46n6anzcnqePorLV8K24XIbbcM37/6V9XK9VN3z7Q3o2zbnTq/n60v08n2b9tfpZXauurG6r+b/+PfuiPs1/Q/4P/mn8vMJwMVW3mrvL84/lj+8N8ia/uZ/Lf2izWFb57D8BAAD//zANvmsEBwAA\n</code></pre> <p>Save the join token for subsequent steps.</p>"},{"location":"raspberry-pi4/#as-a-worker-node","title":"As a worker node","text":"<p>To join an existing k0s cluster, create the join token file for the worker (where <code>$TOKEN_CONTENT</code> is one of the join tokens created in the control plane setup):</p> <pre><code>sudo sh -c 'mkdir -p /var/lib/k0s/ &amp;&amp; umask 077 &amp;&amp; echo \"$TOKEN_CONTENT\" &gt; /var/lib/k0s/join-token'\n</code></pre> <p>After that, install the <code>k0sworker</code> service:</p> <pre><code>ubuntu@ubuntu:~$ sudo k0s install worker --token-file /var/lib/k0s/join-token\nubuntu@ubuntu:~$ systemctl status k0sworker.service\n\u25cb k0sworker.service - k0s - Zero Friction Kubernetes\n     Loaded: loaded (/etc/systemd/system/k0sworker.service; enabled; vendor preset: enabled)\n     Active: inactive (dead)\n       Docs: https://docs.k0sproject.io\n</code></pre> <p>Start the service:</p> <pre><code>ubuntu@ubuntu:~$ sudo systemctl start k0sworker.service\nubuntu@ubuntu:~$ systemctl status k0sworker.service\n\u25cf k0sworker.service - k0s - Zero Friction Kubernetes\n     Loaded: loaded (/etc/systemd/system/k0sworker.service; enabled; vendor preset: enabled)\n     Active: active (running) since Thu 2022-08-18 13:48:58 UTC; 2s ago\n       Docs: https://docs.k0sproject.io\n   Main PID: 1631 (k0s)\n      Tasks: 22\n     Memory: 181.7M\n        CPU: 4.010s\n     CGroup: /system.slice/k0sworker.service\n             \u251c\u25001631 /usr/local/bin/k0s worker --token-file=/var/lib/k0s/join-token\n             \u2514\u25001643 /var/lib/k0s/bin/containerd --root=/var/lib/k0s/containerd --state=/run/k0s/containerd --address=/run/k0s/containerd.sock --log-level=info --config=/etc/k0s/containerd.toml\n\nAug 18 13:49:00 ubuntu k0s[1631]: time=\"2022-08-18 13:49:00\" level=info msg=\"Starting to supervise\" component=containerd\nAug 18 13:49:00 ubuntu k0s[1631]: time=\"2022-08-18 13:49:00\" level=info msg=\"Started successfully, go nuts pid 1643\" component=containerd\nAug 18 13:49:00 ubuntu k0s[1631]: time=\"2022-08-18 13:49:00\" level=info msg=\"starting OCIBundleReconciler\"\nAug 18 13:49:00 ubuntu k0s[1631]: time=\"2022-08-18 13:49:00\" level=info msg=\"starting Kubelet\"\nAug 18 13:49:00 ubuntu k0s[1631]: time=\"2022-08-18 13:49:00\" level=info msg=\"Starting kubelet\"\nAug 18 13:49:00 ubuntu k0s[1631]: time=\"2022-08-18 13:49:00\" level=info msg=\"detected 127.0.0.53 nameserver, assuming systemd-resolved, so using resolv.conf: /run/systemd/resolve/resolv.conf\"\nAug 18 13:49:00 ubuntu k0s[1631]: time=\"2022-08-18 13:49:00\" level=info msg=\"Starting to supervise\" component=kubelet\nAug 18 13:49:00 ubuntu k0s[1631]: time=\"2022-08-18 13:49:00\" level=info msg=\"Started successfully, go nuts pid 1648\" component=kubelet\nAug 18 13:49:00 ubuntu k0s[1631]: time=\"2022-08-18 13:49:00\" level=info msg=\"starting Status\"\nAug 18 13:49:00 ubuntu k0s[1631]: time=\"2022-08-18 13:49:00\" level=info msg=\"starting Autopilot\"\n</code></pre> <p>As this is a worker node, we cannot access the Kubernetes API via the builtin <code>k0s kc</code> subcommand, but we can check the k0s API instead:</p> <pre><code>ubuntu@ubuntu:~$ sudo k0s status\nVersion: v1.34.1+head\nProcess ID: 1631\nRole: worker\nWorkloads: true\nSingleNode: false\n</code></pre> <p>The memory requirements are also pretty low:</p> <pre><code>ubuntu@ubuntu:~$ free -h\n               total        used        free      shared  buff/cache   available\nMem:           3.7Gi       336Mi       2.1Gi       3.0Mi       1.2Gi       3.2Gi\nSwap:             0B          0B          0B\n</code></pre>"},{"location":"raspberry-pi4/#connect-to-the-cluster","title":"Connect to the cluster","text":"<p>On a controller node, generate a new <code>raspi-cluster-master</code> user with admin rights and get a kubeconfig for it:</p> <pre><code>ubuntu@ubuntu:~$ sudo k0s kc create clusterrolebinding raspi-cluster-master-admin --clusterrole=admin --user=raspi-cluster-master\nclusterrolebinding.rbac.authorization.k8s.io/raspi-cluster-master-admin created\nubuntu@ubuntu:~$ sudo k0s kubeconfig create --groups system:masters raspi-cluster-master\n\napiVersion: v1\nclusters:\n- cluster:\n    server: https://10.152.56.54:6443\n    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURBRENDQWVpZ0F3SUJBZ0lVT2RSVzdWdm83UWR5dmdFZHRUK1V3WDN2YXdvd0RRWUpLb1pJaHZjTkFRRUwKQlFBd0dERVdNQlFHQTFVRUF4TU5hM1ZpWlhKdVpYUmxjeTFqWVRBZUZ3MHlNakE0TVRneE5EQTFNREJhRncwegpNakE0TVRVeE5EQTFNREJhTUJneEZqQVVCZ05WQkFNVERXdDFZbVZ5Ym1WMFpYTXRZMkV3Z2dFaU1BMEdDU3FHClNJYjNEUUVCQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUURsdy8wRFJtcG1xRjVnVElmN1o5bElRN0RFdUp6WDJLN1MKcWNvYk5oallFanBqbnBDaXFYOSt5T1R2cGgyUlRKN2tvaGkvUGxrYm5oM2pkeVQ3NWxSMGowSkV1elRMaUdJcApoR2pqc3htek5RRWVwb210R0JwZXNGeUE3NmxTNVp6WVJtT0lFQVgwb0liWjBZazhuU3pQaXBsWDMwcTFETEhGCkVIcSsyZG9vVXRIb09EaEdmWFRJTUJsclZCV3dCV3cxbmdnN0dKb01TN2tHblpYaUw2NFBiRDg5NmtjYXo0a28KTXhhZGc1ZmZQNStBV3JIVHhKV1d2YjNCMjEyOWx3R3FiOHhMTCt1cnVISHVjNEh4em9OVUt1WUlXc2lvQWp4YgphdDh6M1QwV2RnSit2VithWWlRNFlLeEVFdFB4cEMvUHk0czU0UHF4RzVZa0hiMDczMEUxQWdNQkFBR2pRakJBCk1BNEdBMVVkRHdFQi93UUVBd0lCQmpBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUIwR0ExVWREZ1FXQkJTd2p4STIKRUxVNCtNZUtwT0JNQUNnZDdKU1QxVEFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBQ3k3dHFFMk5WT3E0Z0I1Ngp2clVZMFU0SWp1c0dUN0UzQ2xqSUtQODk2Mm9xdlpvU0NWb2U5YS9UQTR6ZXYrSXJwaTZ1QXFxc3RmT3JFcDJ4CmVwMWdYZHQrbG5nV0xlbXdWdEVOZ0xvSnBTM09Vc3N1ai9XcmJwSVU4M04xWVJTRzdzU21KdXhpa3pnVUhiUk8KZ01SLzIxSDFESzJFdmdQY2pHWXlGbUQzSXQzSjVNcnNiUHZTRG4rUzdWWWF0eWhIMUo4dmwxVDFpbzRWWjRTNgpJRFlaV05JOU10TUpqcGxXL01pRnlwTUhFU1E3UEhHeHpGVExoWFplS0pKSlRPYXFha1AxM3J1WFByVHVDQkl4CkFCSWQraU9qdGhSU3ZxbTFocGtHcmY4Rm9PdG1PYXZmazdDdnNJTWdUV2pqd2JJZWZIRU8zUmVBMzZWZWV3bXoKOFJHVUtBPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\n  name: k0s\ncontexts:\n- context:\n    cluster: k0s\n    user: raspi-cluster-master\n  name: k0s\ncurrent-context: k0s\nkind: Config\npreferences: {}\nusers:\n- name: raspi-cluster-master\n  user:\n    client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURYVENDQWtXZ0F3SUJBZ0lVV0ZZNkZ4cCtUYnhxQUxTVjM0REVMb0dEc3Q0d0RRWUpLb1pJaHZjTkFRRUwKQlFBd0dERVdNQlFHQTFVRUF4TU5hM1ZpWlhKdVpYUmxjeTFqWVRBZUZ3MHlNakE0TVRneE5ERTRNREJhRncweQpNekE0TVRneE5ERTRNREJhTURneEZ6QVZCZ05WQkFvVERuTjVjM1JsYlRwdFlYTjBaWEp6TVIwd0d3WURWUVFECkV4UnlZWE53YVMxamJIVnpkR1Z5TFcxaGMzUmxjakNDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0MKQVFvQ2dnRUJBTGJNalI5eHA1dDJzank1S0dEQnQ2dWl3QU4vaEhwZkFUNXJrZTFRblc2eFlZeDYzR2JBTXYrRQpjWmEyUEdPempQeVVTZThVdWp4ZnR0L1JWSTJRVkVIRGlJZ1ZDNk1tUUFmTm1WVlpKOHBFaTM2dGJZYUVxN3dxClhxYmJBQ0F0ZGtwNTJ0Y0RLVU9sRS9SV0tUSjN4bXUvRmh0OTIrRDdtM1RrZTE0TkJ5a1hvakk1a2xVWU9ySEMKVTN3V210eXlIUFpDMFBPdWpXSE5yeS9wOXFjZzRreWNDN0NzUVZqMWoxY2JwdXRpWllvRHNHV3piS0RTbExRZApyYnUwRnRVZVpUQzVPN2NuTk5tMU1EZldubXhlekw4L2N5dkJCYnRmMjhmcERFeEhMT2dTY2ZZUlZwUllPMzdvCk5yUjljMGNaZE9oZW5YVnlQcU1WVVlSNkQxMlRrY0VDQXdFQUFhTi9NSDB3RGdZRFZSMFBBUUgvQkFRREFnV2cKTUIwR0ExVWRKUVFXTUJRR0NDc0dBUVVGQndNQkJnZ3JCZ0VGQlFjREFqQU1CZ05WSFJNQkFmOEVBakFBTUIwRwpBMVVkRGdRV0JCUitqQTlGNm1jc25ob2NtMnd0dFNYY2tCaUpoakFmQmdOVkhTTUVHREFXZ0JTd2p4STJFTFU0CitNZUtwT0JNQUNnZDdKU1QxVEFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBY2RRV3N4OUpHOUIxckxVc2Y1QzgKd1BzTkhkZURYeG1idm4zbXN3aFdVMEZHU1pjWjlkMTYzeXhEWnA4QlNzNWFjNnZqcU1lWlFyRThDUXdXYTlxVAowZVJXcTlFODYzcS9VcFVNN3lPM1BnMHd4RWtQSTVuSjRkM0o3MHA3Zk4zenpzMUJzU0h6Q2hzOWR4dE5XaVp5CnNINzdhbG9NanA0cXBEVWRyVWcyT0d4RWhRdzJIaXE3ZEprQm80a3hoWmhBc3lWTDdZRng0SDY3WkIzSjY4V3QKdTdiWnRmUVJZV3ZPUE9oS0pFdmlLVXptNDJBUlZXTDdhZHVESTBBNmpxbXhkTGNxKzlNWVlaNm1CT0NWakx1WgoybDlJSVI2NkdjOUdpdC9kSFdwbTVZbmozeW8xcUU0UVg4ZmVUQTczUlU5cmFIdkNpTGdVbFRaVUNGa3JNL0NtCndBPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\n    client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBdHN5TkgzR25tM2F5UExrb1lNRzNxNkxBQTMrRWVsOEJQbXVSN1ZDZGJyRmhqSHJjClpzQXkvNFJ4bHJZOFk3T00vSlJKN3hTNlBGKzIzOUZValpCVVFjT0lpQlVMb3laQUI4MlpWVmtueWtTTGZxMXQKaG9TcnZDcGVwdHNBSUMxMlNubmExd01wUTZVVDlGWXBNbmZHYTc4V0czM2I0UHViZE9SN1hnMEhLUmVpTWptUwpWUmc2c2NKVGZCYWEzTEljOWtMUTg2Nk5ZYzJ2TCtuMnB5RGlUSndMc0t4QldQV1BWeHVtNjJKbGlnT3daYk5zCm9OS1V0QjJ0dTdRVzFSNWxNTGs3dHljMDJiVXdOOWFlYkY3TXZ6OXpLOEVGdTEvYngra01URWNzNkJKeDloRlcKbEZnN2Z1ZzJ0SDF6UnhsMDZGNmRkWEkrb3hWUmhIb1BYWk9Sd1FJREFRQUJBb0lCQUFpYytzbFFnYVZCb29SWgo5UjBhQTUyQ3ZhbHNpTUY3V0lPb2JlZlF0SnBTb1ZZTk0vVmplUU94S2VrQURUaGxiVzg1VFlLR1o0QVF3bjBwClQrS2J1bHllNmYvL2ZkemlJSUk5bmN2M3QzaEFZcEpGZWJPczdLcWhGSFNvUFFsSEd4dkhRaGgvZmFKQ1ZQNWUKVVBLZjBpbWhoMWtrUlFnRTB2NWZCYkVZekEyVGl4bThJSGtQUkdmZWN4WmF1VHpBS2VLR0hjTFpDem8xRHhlSgp3bHpEUW9YWDdHQnY5MGxqR1pndENXcFEyRUxaZ1NwdW0rZ0crekg1WFNXZXgwMzJ4d0NhbkdDdGcyRmxHd2V2Ck9PaG8zSjNrRWVJR1MzSzFJY24rcU9hMjRGZmgvcmRsWXFSdStWeEZ4ZkZqWGxaUjdjZkF4Mnc1Z3NmWm9CRXIKUE1oMTdVRUNnWUVBejZiTDc4RWsvZU1jczF6aWdaVVpZcE5qa2FuWHlsS3NUUWM1dU1pRmNORFdObFkxdlQzVQprOHE5cHVLbnBZRVlTTGVVTS9tSWk5TVp6bmZjSmJSL0hJSG9YVjFMQVJ2blQ0djN3T0JsaDc5ajdKUjBpOW1OClYrR0Q1SlNPUmZCVmYxVlJHRXN6d3ZhOVJsS2lMZ0JVM2tKeWN2Q09jYm5aeFltSXRrbDhDbXNDZ1lFQTRWeG4KZTY2QURIYmR3T0plbEFSKytkVHh5eVYyRjY1SEZDNldPQVh2RVRucGRudnRRUUprWWhNYzM1Y2gvMldmZDBWYQpZb3lGZE9kRThKZSsvcWxuS1pBc3BHRC9yZHp2VmFteHQ4WXdrQXU5Q1diZWw2VENPYkZOQ2hjK1NUbmRqN0duCmlSUHprM1JYMnBEVi9OaW5FVFA0TEJnTHJQYkxlSVAwSzZ4bjk0TUNnWUVBeXZGMmNVendUVjRRNTgrSTVDS0gKVzhzMnpkOFRzbjVZUFRRcG1zb0hlTG55RWNyeDNKRTRXSFVXSTZ0ek01TFczQUxuU21DL3JnQlVRWER0Yk1CYQpWczh6L1VPM2tVN25JOXhrK0ZHWGlUTnBnb2VZM0RGMExZYVBNL0JvbUR3S0kxZUwyVlZ1TWthWnQ4ZjlEejV0CnM0ZDNlWlJYY3hpem1KY1JVUzdDbHg4Q2dZQk45Vmc2K2RlRCtFNm4zZWNYenlKWnJHZGtmZllISlJ1amlLWWcKaFRUNVFZNVlsWEF5Yi9CbjJQTEJDaGdSc0lia2pKSkN5eGVUcERrOS9WQnQ2ZzRzMjVvRjF5UTdjZFU5VGZHVApnRFRtYjVrYU9vSy85SmZYdTFUS0s5WTVJSkpibGZvOXVqQWxqemFnL2o5NE16NC8vamxZajR6aWJaRmZoRTRnCkdZanhud0tCZ0U1cFIwMlVCa1hYL3IvdjRqck52enNDSjR5V3U2aWtpem00UmJKUXJVdEVNd1Y3a2JjNEs0VFIKM2s1blo1M1J4OGhjYTlMbXREcDJIRWo2MlBpL2pMR0JTN0NhOCtQcStxNjZwWWFZTDAwWnc4UGI3OVMrUmpzQQpONkNuQWg1dDFYeDhVMTIvWm9JcjBpOWZDaERuNlBqVEM0MVh5M1EwWWd6TW5jYXMyNVBiCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==\n</code></pre> <p>Using the above kubeconfig, you can now access and use the cluster:</p> <pre><code>ubuntu@ubuntu:~$ KUBECONFIG=/path/to/kubeconfig kubectl get nodes,deployments,pods -owide -A\nNAME          STATUS   ROLES    AGE    VERSION       INTERNAL-IP    EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME\nnode/ubuntu   Ready    &lt;none&gt;   5m1s   v1.34.1+k0s   10.152.56.54   &lt;none&gt;        Ubuntu 22.04.1 LTS   5.15.0-1013-raspi   containerd://1.7.27\n\nNAMESPACE     NAME                             READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS       IMAGES                                       SELECTOR\nkube-system   deployment.apps/coredns          1/1     1            1           33m   coredns          quay.io/k0sproject/coredns:1.12.2-1          k8s-app=kube-dns\nkube-system   deployment.apps/metrics-server   1/1     1            1           33m   metrics-server   quay.io/k0sproject/metrics-server:v0.7.2-0   k8s-app=metrics-server\n\nNAMESPACE     NAME                                  READY   STATUS    RESTARTS   AGE    IP             NODE     NOMINATED NODE   READINESS GATES\nkube-system   pod/coredns-88b745646-pkk5w           1/1     Running   0          33m    10.244.0.5     ubuntu   &lt;none&gt;           &lt;none&gt;\nkube-system   pod/konnectivity-agent-h4nfj          1/1     Running   0          5m1s   10.244.0.6     ubuntu   &lt;none&gt;           &lt;none&gt;\nkube-system   pod/kube-proxy-qcgzs                  1/1     Running   0          5m1s   10.152.56.54   ubuntu   &lt;none&gt;           &lt;none&gt;\nkube-system   pod/kube-router-6lrht                 1/1     Running   0          5m1s   10.152.56.54   ubuntu   &lt;none&gt;           &lt;none&gt;\nkube-system   pod/metrics-server-7d7c4887f4-wwbkk   1/1     Running   0          33m    10.244.0.4     ubuntu   &lt;none&gt;           &lt;none&gt;\n</code></pre>"},{"location":"raspberry-pi5/","title":"Raspberry Pi 5","text":""},{"location":"raspberry-pi5/#create-a-raspberry-pi-5-cluster","title":"Create a Raspberry Pi 5 cluster","text":""},{"location":"raspberry-pi5/#prerequisites","title":"Prerequisites","text":"<p>This guide assumes that you have a Raspberry Pi 5 and a sufficiently large SD card of at least 32 GB. We will be using Raspberry Pi OS for this guide, though k0s should run just fine on other 64-bit Linux distributions for the Raspberry Pi 5 as well. Please file a Bug if you encounter any issues.</p>"},{"location":"raspberry-pi5/#set-up-the-system","title":"Set up the system","text":"<p>Follow the official Raspberry Pi instructions on booting Pi OS from the USB drive or another method depending on your needs.</p>"},{"location":"raspberry-pi5/#ssh-access","title":"SSH Access","text":"<ol> <li> <p>Typically, you can enable SSH while creating the bootable drive for Raspberry Pi OS. If not, you can enable it later</p> </li> <li> <p>Add your public key to the server.     From your host machine, run ssh-copy-id to copy your public SSH key to your Pi 5:</p> <pre><code>ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;YOUR_USER_NAME&gt;@&lt;IP_ADDRESS_OF_THE_SERVER&gt;\n</code></pre> <p>When prompted, enter the password for your user account for the Pi. Your public key should be copied at the appropriate folder on the remote Pi automatically.</p> <p>Note: <code>~/.ssh/id_rsa.pub</code> is the default location for the public ssh key. If your key is elsewhere, adjust accordingly.</p> </li> <li> <p>Verify SSH access</p> <pre><code>ssh &lt;YOUR_USER_NAME&gt;@&lt;IP_ADDRESS_OF_THE_SERVER&gt;\n</code></pre> <p>If your key has a paraphrase, you\u2019ll be prompted for it.</p> </li> </ol>"},{"location":"raspberry-pi5/#enable-the-memory-cgroup-controller","title":"Enable the memory cgroup controller","text":"<p>Raspberry Pi OS does not enable the memory cgroup controller by default. However, it is required to run containerized workloads, so enable it:</p> <ol> <li> <p>Edit /boot/cmdline.txt:</p> <pre><code>sudo nano /boot/cmdline.txt\n</code></pre> <p>Append (on the same single line):</p> <pre><code>cgroup_enable=memory cgroup_memory=1\n</code></pre> </li> <li> <p>Reboot</p> <pre><code>sudo reboot\n</code></pre> </li> </ol>"},{"location":"raspberry-pi5/#install-k0s","title":"Install k0s","text":""},{"location":"raspberry-pi5/#download-k0s","title":"Download k0s","text":"<p>Download a k0s release. For example:</p> <pre><code>wget -O /tmp/k0s https://github.com/k0sproject/k0s/releases/download/v1.34.1+head/k0s-v1.34.1+head-arm64 # replace version number!\nsudo install /tmp/k0s /usr/local/bin/k0s\n</code></pre> <p>\u2015 or \u2015</p> <p>Use the k0s download script (as one command) to download the latest stable k0s and make it executable in <code>/usr/bin/k0s</code>.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://get.k0s.sh | sudo sh\n</code></pre> <p>At this point you can run <code>k0s</code>:</p> <pre><code>$ sudo k0s version\nv1.34.1+head\n</code></pre> <p>To check if k0s's system requirements and external runtime dependencies are fulfilled by your current setup, you can invoke <code>k0s sysinfo</code>:</p> <pre><code>ramesses-pi5@pi:~ $ sudo k0s sysinfo\nTotal memory: 7.9 GiB (pass)\nFile system of /var/lib/k0s: ext4 (pass)\nDisk space available for /var/lib/k0s: 44.3 GiB (pass)\nRelative disk space available for /var/lib/k0s: 79% (pass)\nName resolution: localhost: [::1 127.0.0.1] (pass)\nOperating system: Linux (pass)\n  Linux kernel release: 6.6.51+rpt-rpi-2712 (pass)\n  Max. file descriptors per process: current: 1048576 / max: 1048576 (pass)\n  AppArmor: unavailable (pass)\n  Executable in PATH: modprobe: /usr/sbin/modprobe (pass)\n  Executable in PATH: mount: /usr/bin/mount (pass)\n  Executable in PATH: umount: /usr/bin/umount (pass)\n  /proc file system: mounted (0x9fa0) (pass)\n  Control Groups: version 2 (pass)\n    cgroup controller \"cpu\": available (is a listed root controller) (pass)\n    cgroup controller \"cpuacct\": available (via cpu in version 2) (pass)\n    cgroup controller \"cpuset\": available (is a listed root controller) (pass)\n    cgroup controller \"memory\": available (is a listed root controller) (pass)\n    cgroup controller \"devices\": available (device filters attachable) (pass)\n    cgroup controller \"freezer\": available (cgroup.freeze exists) (pass)\n    cgroup controller \"pids\": available (is a listed root controller) (pass)\n    cgroup controller \"hugetlb\": unavailable (warning)\n    cgroup controller \"blkio\": available (via io in version 2) (pass)\n  CONFIG_CGROUPS: Control Group support: built-in (pass)\n    CONFIG_CGROUP_SCHED: Group CPU scheduler: built-in (pass)\n      CONFIG_FAIR_GROUP_SCHED: Group scheduling for SCHED_OTHER: built-in (pass)\n        CONFIG_CFS_BANDWIDTH: CPU bandwidth provisioning for FAIR_GROUP_SCHED: built-in (pass)\n    CONFIG_BLK_CGROUP: Block IO controller: built-in (pass)\n  CONFIG_NAMESPACES: Namespaces support: built-in (pass)\n    CONFIG_UTS_NS: UTS namespace: built-in (pass)\n    CONFIG_IPC_NS: IPC namespace: built-in (pass)\n    CONFIG_PID_NS: PID namespace: built-in (pass)\n    CONFIG_NET_NS: Network namespace: built-in (pass)\n  CONFIG_NET: Networking support: built-in (pass)\n    CONFIG_INET: TCP/IP networking: built-in (pass)\n      CONFIG_IPV6: The IPv6 protocol: module (pass)\n    CONFIG_NETFILTER: Network packet filtering framework (Netfilter): built-in (pass)\n      CONFIG_NETFILTER_ADVANCED: Advanced netfilter configuration: built-in (pass)\n      CONFIG_NF_CONNTRACK: Netfilter connection tracking support: module (pass)\n      CONFIG_NETFILTER_XTABLES: Netfilter Xtables support: module (pass)\n        CONFIG_NETFILTER_XT_TARGET_REDIRECT: REDIRECT target support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_COMMENT: \"comment\" match support: module (pass)\n        CONFIG_NETFILTER_XT_MARK: nfmark target and match support: module (pass)\n        CONFIG_NETFILTER_XT_SET: set target and match support: module (pass)\n        CONFIG_NETFILTER_XT_TARGET_MASQUERADE: MASQUERADE target support: module (pass)\n        CONFIG_NETFILTER_XT_NAT: \"SNAT and DNAT\" targets support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_ADDRTYPE: \"addrtype\" address type match support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_CONNTRACK: \"conntrack\" connection tracking match support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_MULTIPORT: \"multiport\" Multiple port match support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_RECENT: \"recent\" match support: module (pass)\n        CONFIG_NETFILTER_XT_MATCH_STATISTIC: \"statistic\" match support: module (pass)\n      CONFIG_NETFILTER_NETLINK: module (pass)\n      CONFIG_NF_NAT: module (pass)\n      CONFIG_IP_SET: IP set support: module (pass)\n        CONFIG_IP_SET_HASH_IP: hash:ip set support: module (pass)\n        CONFIG_IP_SET_HASH_NET: hash:net set support: module (pass)\n      CONFIG_IP_VS: IP virtual server support: module (pass)\n        CONFIG_IP_VS_NFCT: Netfilter connection tracking: built-in (pass)\n        CONFIG_IP_VS_SH: Source hashing scheduling: module (pass)\n        CONFIG_IP_VS_RR: Round-robin scheduling: module (pass)\n        CONFIG_IP_VS_WRR: Weighted round-robin scheduling: module (pass)\n      CONFIG_NF_CONNTRACK_IPV4: IPv4 connection tracking support (required for NAT): unknown (warning)\n      CONFIG_NF_REJECT_IPV4: IPv4 packet rejection: module (pass)\n      CONFIG_NF_NAT_IPV4: IPv4 NAT: unknown (warning)\n      CONFIG_IP_NF_IPTABLES: IP tables support: module (pass)\n        CONFIG_IP_NF_FILTER: Packet filtering: module (pass)\n          CONFIG_IP_NF_TARGET_REJECT: REJECT target support: module (pass)\n        CONFIG_IP_NF_NAT: iptables NAT support: module (pass)\n        CONFIG_IP_NF_MANGLE: Packet mangling: module (pass)\n      CONFIG_NF_DEFRAG_IPV4: module (pass)\n      CONFIG_NF_CONNTRACK_IPV6: IPv6 connection tracking support (required for NAT): unknown (warning)\n      CONFIG_NF_NAT_IPV6: IPv6 NAT: unknown (warning)\n      CONFIG_IP6_NF_IPTABLES: IP6 tables support: module (pass)\n        CONFIG_IP6_NF_FILTER: Packet filtering: module (pass)\n        CONFIG_IP6_NF_MANGLE: Packet mangling: module (pass)\n        CONFIG_IP6_NF_NAT: ip6tables NAT support: module (pass)\n      CONFIG_NF_DEFRAG_IPV6: module (pass)\n    CONFIG_BRIDGE: 802.1d Ethernet Bridging: module (pass)\n      CONFIG_LLC: module (pass)\n      CONFIG_STP: module (pass)\n  CONFIG_EXT4_FS: The Extended 4 (ext4) filesystem: built-in (pass)\n  CONFIG_PROC_FS: /proc file system support: built-in (pass)\n</code></pre>"},{"location":"raspberry-pi5/#deploy-a-node-using-k0s","title":"Deploy a Node using k0s","text":"<p>If you want a more hands-on process for setting up your Pi 5 devices as Kubernetes nodes with the k0s binary, refer to the guide for Pi devices.</p>"},{"location":"raspberry-pi5/#deploy-a-node-using-k0sctl","title":"Deploy a Node using k0sctl","text":""},{"location":"raspberry-pi5/#install-k0sctl-on-your-host","title":"Install k0sctl on Your Host","text":"<p>Follow the k0sctl installation guide and install k0sctl on your host machine.</p>"},{"location":"raspberry-pi5/#single-node-k0s-cluster","title":"Single node K0s cluster","text":"<p>For this example, we'll create a cluster.yaml that describes your known Pi 5 device and use it as a single node (controller &amp; worker) cluster, for example:</p> <pre><code>apiVersion: k0sctl.k0sproject.io/v1beta1\nkind: Cluster\nmetadata:\n  name: k0s-cluster\n  user: admin\nspec:\n  hosts:\n  - ssh:\n      address: &lt;IP_ADDRESS_OF_THE_SERVER&gt;\n      user: &lt;YOUR_USER_NAME&gt;\n      port: 22\n      keyPath: ~/.ssh/id_rsa\n    role: controller+worker\n</code></pre>"},{"location":"raspberry-pi5/#ssh-agent","title":"SSH agent","text":"<p>By default, k0sctl doesn\u2019t prompt you for passphrases, so the easiest solution is to load your key into an SSH agent before running k0sctl. Here\u2019s how you can do it:</p> <p>1. Start the SSH agent (if not already running)</p> <pre><code>  ```bash\n  eval \"$(ssh-agent -s)\"\n  ```\n</code></pre> <p>2. \u200b\u200bAdd your private key (you\u2019ll be prompted for the passphrase)</p> <pre><code>  ```bash\n  ssh-add ~/.ssh/id_rsa\n  ```\n</code></pre> <p>3. Verify the key is loaded</p> <pre><code>  ```bash\n  ssh-add -l\n  ```\n</code></pre>"},{"location":"raspberry-pi5/#deploy-cluster","title":"Deploy cluster","text":"<p>1. Apply the cluster.yaml using k0sctl on your local machine.</p> <pre><code>  ```console\n  $ k0sctl apply --config cluster.yaml\n\n  \u2800\u28ff\u28ff\u2847\u2800\u2800\u2880\u28f4\u28fe\u28ff\u281f\u2801\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281b\u2801\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\n  \u2800\u28ff\u28ff\u2847\u28e0\u28f6\u28ff\u287f\u280b\u2800\u2800\u2800\u28b8\u28ff\u2847\u2800\u2800\u2800\u28e0\u2800\u2800\u2880\u28e0\u2846\u28b8\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n  \u2800\u28ff\u28ff\u28ff\u28ff\u28df\u280b\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u2847\u2800\u28b0\u28fe\u28ff\u2800\u2800\u28ff\u28ff\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n  \u2800\u28ff\u28ff\u284f\u283b\u28ff\u28f7\u28e4\u2840\u2800\u2800\u2800\u2838\u281b\u2801\u2800\u2838\u280b\u2801\u2800\u2800\u28ff\u28ff\u2847\u2808\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u28b9\u28ff\u28ff\u2800\u2588\u2588\u2588          \u2588\u2588\u2588    \u2588\u2588\u2588\n  \u2800\u28ff\u28ff\u2847\u2800\u2800\u2819\u28bf\u28ff\u28e6\u28c0\u2800\u2800\u2800\u28e0\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28ff\u28ff\u2847\u28b0\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28f6\u28fe\u28ff\u28ff\u2800\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  k0sctl v0.21.0 Copyright 2023, k0sctl authors.\n  INFO ==&gt; Running phase: Set k0s version\n  INFO Looking up latest stable k0s version\n  INFO Using k0s version v1.34.1+head\n  INFO ==&gt; Running phase: Connect to hosts\n  INFO [ssh] 192.168.31.93:22: connected\n  INFO ==&gt; Running phase: Detect host operating systems\n  INFO [ssh] 192.168.31.93:22: is running Debian GNU/Linux 12 (bookworm)\n  INFO ==&gt; Running phase: Acquire exclusive host lock\n  INFO ==&gt; Running phase: Prepare hosts\n  INFO ==&gt; Running phase: Gather host facts\n  INFO [ssh] 192.168.31.93:22: using pi as hostname\n  INFO [ssh] 192.168.31.93:22: discovered wlan0 as private interface\n  INFO ==&gt; Running phase: Validate hosts\n  INFO ==&gt; Running phase: Validate facts\n  INFO ==&gt; Running phase: Download k0s on hosts\n  INFO [ssh] 192.168.31.93:22: downloading k0s v1.34.1+head\n  INFO ==&gt; Running phase: Install k0s binaries on hosts\n  INFO [ssh] 192.168.31.93:22: validating configuration\n  INFO ==&gt; Running phase: Configure k0s\n  INFO [ssh] 192.168.31.93:22: installing new configuration\n  INFO ==&gt; Running phase: Initialize the k0s cluster\n  INFO [ssh] 192.168.31.93:22: installing k0s controller\n  INFO [ssh] 192.168.31.93:22: waiting for the k0s service to start\n  INFO [ssh] 192.168.31.93:22: wait for kubernetes to reach ready state\n  INFO ==&gt; Running phase: Release exclusive host lock\n  INFO ==&gt; Running phase: Disconnect from hosts\n  INFO ==&gt; Finished in 4m14s\n  INFO k0s cluster version v1.34.1+head is now installed\n  INFO Tip: To access the cluster you can now fetch the admin kubeconfig using:\n  INFO      k0sctl kubeconfig --config cluster.yaml\n  ```\n</code></pre> <p>2. Fetch the kubeconfig use k0sctl.</p> <pre><code>  ```bash\n    k0sctl kubeconfig --config cluster.yaml &gt; pi_cluster.kubeconfig\n  ```\n</code></pre> <p>3. Export KUBECONFIG and verify</p> <pre><code>  ```console\n  $ export KUBECONFIG=pi_cluster.kubeconfig\n  $ kubectl get nodes\n  NAME   STATUS   ROLES           AGE     VERSION\n  pi     Ready    control-plane   2m54s   v1.34.1+k0s\n  ```\n</code></pre>"},{"location":"raspberry-pi5/#tear-down-k0s-on-pi-5","title":"Tear down k0s on Pi 5","text":"<p>If you need to remove k0s entirely (for example, if you run into conflicts or just want a clean slate):</p> <p>1. Stop existing processes</p> <pre><code>  ```bash\n  sudo k0s stop\n  ```\n</code></pre> <p>2. Reset k0s</p> <pre><code>  ```bash\n  sudo k0s reset\n  ```\n</code></pre> <p>3. Remove k0s binaries</p> <pre><code>  ```bash\n  sudo rm -rf /usr/local/bin/k0s\n  ```\n</code></pre> <p>4. Reboot Pi 5.</p> <pre><code>  ```bash\n  sudo reboot\n  ```\n</code></pre>"},{"location":"reinstall-k0sctl/","title":"Re-install","text":""},{"location":"reinstall-k0sctl/#reinstall-a-node","title":"Reinstall a node","text":"<p><code>k0sctl</code> currently does not support changing all the configuration of containerd (<code>state</code>, <code>root</code>) on the fly.</p> <p>For example, in order to move containerd's <code>root</code> directory to a new partition/drive, you have to provide <code>--data-dir /new/drive</code> in your k0sctl <code>installFlags</code> for each (worker) node. <code>--data-dir</code> is an option of <code>k0s</code> and then added to the service unit.</p> <p>The following is an example of that:</p> <pre><code># spec.hosts[*].installFlags\n  - role: worker\n    installFlags:\n      - --profile flatcar\n      - --enable-cloud-provider\n      - --data-dir /new/drive\n      - --kubelet-extra-args=\"--cloud-provider=external\"\n</code></pre> <p>However, the <code>installFlags</code> are only used when the node is installed.</p>"},{"location":"reinstall-k0sctl/#steps","title":"Steps","text":"<p>Drain the node:</p> <pre><code>kubectl drain node.hostname\n</code></pre> <p>Access your node (e.g. via ssh) to stop and reset k0s:</p> <pre><code>sudo k0s stop\nsudo k0s reset\n</code></pre> <p>Reboot the node (for good measure):</p> <pre><code>sudo systemctl reboot\n</code></pre> <p>Once the node is available again, run <code>k0sctl apply</code> to integrate it into your cluster and uncordon the node to allow pods to be scheduled:</p> <pre><code>k0sctl apply -c config.yaml\nkubectl uncordon node.hostname\n</code></pre>"},{"location":"releases/","title":"Releases & support model","text":""},{"location":"releases/#releases","title":"Releases","text":"<p>This page describes how we release and support the k0s project. Mirantis Inc. can also provide commercial support for k0s.</p>"},{"location":"releases/#upstream-kubernetes-release-support-cycle","title":"Upstream Kubernetes release &amp; support cycle","text":"<p>This release and support cycle is followed for ALL new minor releases. A minor release can be e.g. v1.33, v1.34 and so on. What this means in practice is that every 4 months there is a new minor release published.</p> <p>After a minor release is published, the upstream community is maintaining it for 14 months. Maintenance in this case means that upstream Kubernetes provides bug fixes, CVE mitigations and such for 14 months per minor release.</p> <p></p>"},{"location":"releases/#k0s-release-and-support-model","title":"k0s release and support model","text":"<p>Starting from the k0s 1.21, k0s started following the Kubernetes project's release and support model.</p> <p>k0s project follows closely the upstream Kubernetes release cycle. The only difference to upstream Kubernetes release / maintenance schedule is that our initial release date is always a few weeks behind the upstream Kubernetes version release date as we are building our version of k0s from the officially released version of Kubernetes and need time for testing the final version before shipping.</p> <p></p> <p>Given the fact that upstream Kubernetes provides support and patch releases for a minor version for roughly 14 months, it means that k0s will follow this same model. Each minor release is maintained for roughly 14 months since its initial release.</p> <p>k0s project will typically include patches and fixes included in a Kubernetes upstream patch release for the fixes needed in k0s own codebase. For example, if a bug is identified in v1.34 series k0s project will create and ship a fix for it with the next upstream Kubernetes v1.34.x release. In rare cases where a critical bug is identified we may also ship \"out of band\" patches. Such out-of-band release would be identified in the version string suffix. For example a normal release following Kubernetes upstream would be v1.34.0+k0s.0 whereas a critical out-of-band patch would be identified as v1.34.0+k0s.1.</p>"},{"location":"releases/#new-features-and-enhancements","title":"New features and enhancements","text":"<p>The biggest new k0s features will typically only be delivered on top of the latest Kubernetes version, but smaller enhancements can be included in older release tracks as well.</p>"},{"location":"releases/#version-string","title":"Version string","text":"<p>The k0s version string consists of the Kubernetes version and the k0s version. For example:</p> <pre><code>v1.34.1+head\n</code></pre> <p>The Kubernetes version (<code>v1.34.1</code>) is the first part, and the last part (<code>head</code>) reflects the k0s version, which is built on top of the certain Kubernetes version.</p>"},{"location":"remove_controller/","title":"Remove/Replace a controller","text":""},{"location":"remove_controller/#remove-or-replace-a-controller","title":"Remove or replace a controller","text":"<p>You can manually remove or replace a controller from a multi-node k0s cluster (&gt;=3 controllers) without downtime. However, you have to maintain quorum on Etcd while doing so.</p>"},{"location":"remove_controller/#remove-a-controller","title":"Remove a controller","text":"<p>If your controller is also a worker (<code>k0s controller --enable-worker</code>), you first have to delete the controller from Kubernetes itself. To do so, run the following commands from the controller:</p> <pre><code># Remove the containers from the node and cordon it\nk0s kubectl drain --ignore-daemonsets --delete-emptydir-data &lt;controller&gt;\n# Delete the node from the cluster\nk0s kubectl delete node &lt;controller&gt;\n</code></pre> <p>Delete Autopilot's <code>ControlNode</code> object for the controller node:</p> <pre><code>k0s kubectl delete controlnode.autopilot.k0sproject.io &lt;controller&gt;\n</code></pre> <p>Then you need to remove it from the Etcd cluster. For example, if you want to remove <code>controller01</code> from a cluster with 3 controllers:</p> <pre><code># First, list the Etcd members\nk0s etcd member-list\n{\"members\":{\"controller01\":\"&lt;PEER_ADDRESS1&gt;\", \"controller02\": \"&lt;PEER_ADDRESS2&gt;\", \"controller03\": \"&lt;PEER_ADDRESS3&gt;\"}}\n# Then, remove the controller01 using its peer address\nk0s etcd leave --peer-address \"&lt;PEER_ADDRESS1&gt;\"\n</code></pre> <p>The controller is now removed from the cluster. To reset k0s on the machine, run the following commands:</p> <pre><code>k0s stop\nk0s reset\nreboot\n</code></pre>"},{"location":"remove_controller/#declarative-etcd-member-management","title":"Declarative Etcd member management","text":"<p>Starting from version 1.30, k0s also supports a declarative way to remove an etcd member. Since in k0s the etcd cluster is set up so that the etcd API is NOT exposed outside the nodes, it makes it difficult for external automation like Cluster API, Terraform, etc. to handle controller node replacements.</p> <p>Each controller manages their own <code>EtcdMember</code> object.</p> <pre><code>k0s kubectl get etcdmember\nNAME          PEER ADDRESS   MEMBER ID           JOINED   RECONCILE STATUS\ncontroller0   172.17.0.2     b8e14bda2255bc24    True\ncontroller1   172.17.0.3     cb242476916c8a58    True\ncontroller2   172.17.0.4     9c90504b1bc867bb    True\n</code></pre> <p>By marking an <code>EtcdMember</code> object to leave the etcd cluster, k0s will handle the interaction with etcd. For example, in a 3 controller HA setup, you can remove a member by flagging it to leave:</p> <pre><code>$ kubectl patch etcdmember controller2 -p '{\"spec\":{\"leave\":true}}' --type merge\netcdmember.etcd.k0sproject.io/controller2 patched\n</code></pre> <p>The join/leave status is tracked in the object's conditions. This allows you to wait for the leave to actually happen:</p> <pre><code>$ kubectl wait etcdmember controller2 --for condition=Joined=False\netcdmember.etcd.k0sproject.io/controller2 condition met\n</code></pre> <p>You'll see the node left etcd cluster:</p> <pre><code>$ k0s kc get etcdmember\nNAME          PEER ADDRESS   MEMBER ID           JOINED   RECONCILE STATUS\ncontroller0   172.17.0.2     b8e14bda2255bc24    True\ncontroller1   172.17.0.3     cb242476916c8a58    True\ncontroller2   172.17.0.4     9c90504b1bc867bb    False    Success\n</code></pre> <pre><code>$ k0s etcd member-list\n{\"members\":{\"controller0\":\"https://172.17.0.2:2380\",\"controller1\":\"https://172.17.0.3:2380\"}}\n</code></pre> <p>The objects for members that have already left the etcd cluster are kept available for tracking purposes. Once the member has left the cluster, the object status will reflect that it is safe to remove it.</p> <p>Note: If you re-join same node without removing the corresponding <code>etcdmember</code> object the desired state will be updated back to <code>spec.leave: false</code> automatically. This is since currently in k0s there's no easy way to prevent a node joining etcd cluster.</p>"},{"location":"remove_controller/#replace-a-controller","title":"Replace a controller","text":"<p>To replace a controller, you first remove the old controller (like described above) then follow the manual installation procedure to add the new one.</p>"},{"location":"reset/","title":"Reset (Uninstall)","text":""},{"location":"reset/#reset-uninstall","title":"Reset (Uninstall)","text":"<p>Resetting k0s nodes essentially reverts them to a pre-k0s state. This operation is particularly useful in scenarios where you need to cleanly remove k0s from nodes, either for troubleshooting purposes or as a precursor to a fresh installation. It is designed to remove all components, configurations, and data associated with k0s from a node. This includes, but is not limited to, the following:</p> <ul> <li>Processes and containers: Terminates all running k0s processes to ensure that   there are no active components left. This includes all container processes   managed by the Container Runtime.</li> <li>Mounts under k0s data directory: In order to prevent persistent data to be   deleted, all mount points under k0s' data directory will be unmounted. If an   unmount fails, it will be unmounted lazy.</li> <li>Data stored on the node: Deletes the whole k0s data directory, which includes<ul> <li>all k0s-related configuration files, including those used for cluster setup   and node-specific settings,</li> <li>all data stores managed by k0s, including etcd or kine data for cluster   state and any temporary files created during operation,</li> <li>and all certificates and other key material generated by k0s for node   authentication and communication within the cluster.</li> </ul> </li> <li>Network settings: Reverts any network configurations made by k0s, such as   network interfaces or iptables rules set up specifically for cluster   communication. This is done on a best effort basis. It's recommended that you   reboot the host after a reset to ensure that there are no k0s remnants in the   host's network configuration. Custom CNI plugins are not cleaned up.</li> <li>Registration with the host's init system: Reverts the registration done by   <code>k0s install</code>. After a reset, k0s won't be automatically started when the   host boots.</li> </ul> <p>After a successful reset, the k0s binary itself remains. It can then be used to join another cluster or create a new one.</p> <p>It's important to understand that performing a reset is a destructive operation that will result in the loss of all data and configurations related to k0s on the affected nodes. Therefore, it should be performed with care, ideally after ensuring that all necessary data has been backed up or that the cluster can be safely disassembled without data loss.</p> <p>K0s can be reset locally on a host using the <code>k0s reset</code> command. Whole clusters can be reset remotely with the <code>k0sctl reset</code> command.</p>"},{"location":"reset/#reset-a-k0s-node-locally","title":"Reset a k0s node locally","text":"<p>To ensure operational safety, <code>k0s reset</code> includes a safeguard that prevents it from being executed while k0s is running, so it must be stopped first:</p> <ol> <li> <p>Stop the service:</p> <pre><code>sudo k0s stop\n</code></pre> </li> <li> <p>Invoke the <code>reset</code> command:</p> <pre><code>$ sudo k0s reset\nWARN[2024-03-28 09:15:36] To ensure a full reset, a node reboot is recommended.\n</code></pre> </li> </ol>"},{"location":"reset/#reset-a-k0s-cluster-remotely-using-k0sctl","title":"Reset a k0s cluster remotely using k0sctl","text":"<p>K0sctl can be used to connect and reset all cluster nodes in a single command.</p> <ol> <li>Invoke <code>k0sctl reset</code> command:<pre><code>$ k0sctl reset --config k0sctl.yaml\nk0sctl v0.21.0 Copyright 2023, k0sctl authors.\n? Going to reset all of the hosts, which will destroy all configuration and data, Are you sure? Yes\nINFO ==&gt; Running phase: Connect to hosts\nINFO [ssh] 13.53.43.63:22: connected\nINFO [ssh] 13.53.218.149:22: connected\nINFO ==&gt; Running phase: Detect host operating systems\nINFO [ssh] 13.53.43.63:22: is running Ubuntu 22.04.4 LTS\nINFO [ssh] 13.53.218.149:22: is running Ubuntu 22.04.4 LTS\nINFO ==&gt; Running phase: Acquire exclusive host lock\nINFO ==&gt; Running phase: Prepare hosts\nINFO ==&gt; Running phase: Gather k0s facts\nINFO [ssh] 13.53.43.63:22: found existing configuration\nINFO [ssh] 13.53.43.63:22: is running k0s controller version v1.34.1+head\nINFO [ssh] 13.53.218.149:22: is running k0s worker version v1.34.1+head\nINFO [ssh] 13.53.43.63:22: checking if worker  has joined\nINFO ==&gt; Running phase: Reset workers\nINFO [ssh] 13.53.218.149:22: reset\nINFO ==&gt; Running phase: Reset controllers\nINFO [ssh] 13.53.43.63:22: reset\nINFO ==&gt; Running phase: Reset leader\nINFO [ssh] 13.53.43.63:22: reset\nINFO ==&gt; Running phase: Release exclusive host lock\nINFO ==&gt; Running phase: Disconnect from hosts\nINFO ==&gt; Finished in 8s\n</code></pre> </li> </ol>"},{"location":"runtime/","title":"Runtime (CRI)","text":""},{"location":"runtime/#runtime","title":"Runtime","text":"<p>k0s supports any container runtime that implements the CRI specification.</p> <p>k0s comes bundled with containerd as the default Container Runtime Interface (CRI) and runc as the default low-level runtime. In most cases they don't require any configuration changes. However, if custom configuration is needed, this page provides some examples.</p> <p></p>"},{"location":"runtime/#containerd-configuration","title":"containerd configuration","text":"<p>By default k0s manages the full containerd configuration. You have the option of fully overriding, and thus also managing, the configuration yourself.</p>"},{"location":"runtime/#user-managed-containerd-configuration","title":"User managed containerd configuration","text":"<p>In the default k0s generated configuration there's a \"magic\" comment telling containerd it is managed by k0s:</p> <pre><code># k0s_managed=true\n</code></pre> <p>If you wish to take over the configuration management, remove this line.</p> <p>To make changes to the containerd configuration you must first generate a default containerd configuration, with the default values set to <code>/etc/k0s/containerd.toml</code>:</p> <pre><code>containerd config default &gt; /etc/k0s/containerd.toml\n</code></pre> <p><code>k0s</code> runs containerd with the following default values:</p> <pre><code>/var/lib/k0s/bin/containerd \\\n    --root=/var/lib/k0s/containerd \\\n    --state=/run/k0s/containerd \\\n    --address=/run/k0s/containerd.sock \\\n    --config=/etc/k0s/containerd.toml\n</code></pre> <p>Next, add the following default values to the configuration file:</p> <pre><code>version = 2\nroot = \"/var/lib/k0s/containerd\"\nstate = \"/run/k0s/containerd\"\n...\n\n[grpc]\n  address = \"/run/k0s/containerd.sock\"\n</code></pre>"},{"location":"runtime/#k0s-managed-dynamic-runtime-configuration","title":"k0s managed dynamic runtime configuration","text":"<p>As of 1.27.1, k0s allows dynamic configuration of containerd CRI runtimes. This works by k0s creating a special directory in <code>/etc/k0s/containerd.d/</code>, where users can place partial containerd configuration TOML files (i.e. files with a <code>.toml</code> extension).</p> <p>K0s will automatically pick up these files and add them as containerd configuration <code>imports</code>. If a partial configuration file contains a CRI plugin configuration section, k0s will instead treat such a file as a merge patch to k0s's default containerd configuration. This is to mitigate containerd's decision to replace rather than merge individual plugin configuration sections from imported configuration files. However, this behavior may change in future releases of containerd.</p> <p>Please note, that in order for drop-ins in <code>/etc/k0s/containerd.d</code> to take effect on running configuration, <code>/etc/k0s/containerd.toml</code> needs to be k0s managed.</p> <p>If you change the first magic line (<code># k0s_managed=true</code>) in the <code>/etc/k0s/containerd.toml</code> (by accident or on purpose), it automatically becomes \"not k0s managed\". To make it \"k0s managed\" again, remove <code>/etc/k0s/containerd.toml</code> and restart k0s service on the node, it'll be recreated by k0s.</p> <p>To confirm that drop-ins are being applied to the running configuration, you can check the contents of <code>/run/k0s/containerd-cri.toml</code>; drop-in specific configuration should be present in this file.</p>"},{"location":"runtime/#examples","title":"Examples","text":"<p>The following sections provide some examples of how to use k0s managed drop-in configurations for common configuration tasks.</p>"},{"location":"runtime/#configuring-oci-registry-mirrors","title":"Configuring OCI registry mirrors","text":"<p>Say you host an internal registry mirror of Docker Hub as <code>docker-mirror.internal.acme.corp</code>. Then you could use the following drop-in configuration:</p> <p><code>/etc/k0s/containerd.d/cri-registry.toml</code>:</p> <pre><code>version = 2\n\n[plugins.\"io.containerd.grpc.v1.cri\".registry]\nconfig_path = \"/etc/k0s/containerd.d/certs.d\"\n</code></pre> <p>Create the file <code>/etc/k0s/containerd.d/certs.d/docker.io/hosts.toml</code> with the following content:</p> <pre><code># Always resolve tags against Docker Hub as the \"server\"\nserver = \"https://registry-1.docker.io\"\n\n[host.\"https://docker-mirror.internal.acme.corp:5000\"]\ncapabilities = [\"pull\", \"resolve\"]\n# Trust the internal mirror's certificate. Paths will be resolved relative to\n# the containing file's directory, e.g. the below path will be resolved to\n# /etc/k0s/containerd.d/certs.d/docker.io/internal-mirror.crt\nca = \"internal-mirror.crt\"\n# Or, alternatively, disable TLS verification, if you know what you're doing:\n# skip_verify = true\n\n# Use Google's public pull-through cache\n[host.\"https://mirror.gcr.io\"]\ncapabilities = [\"pull\", \"resolve\"]\n</code></pre> <p>For more details on how to configure registry hosts, please refer to the official containerd configuration.</p>"},{"location":"runtime/#using-gvisor","title":"Using gVisor","text":"<p>gVisor is an application kernel, written in Go, that implements a substantial portion of the Linux system call interface. It provides an additional layer of isolation between running applications and the host operating system.</p> <ol> <li> <p>Install the needed gVisor binaries into the host.</p> <pre><code>(\n  set -e\n  ARCH=$(uname -m)\n  URL=https://storage.googleapis.com/gvisor/releases/release/latest/${ARCH}\n  wget ${URL}/runsc ${URL}/runsc.sha512 \\\n    ${URL}/containerd-shim-runsc-v1 ${URL}/containerd-shim-runsc-v1.sha512\n  sha512sum -c runsc.sha512 \\\n    -c containerd-shim-runsc-v1.sha512\n  rm -f *.sha512\n  chmod a+rx runsc containerd-shim-runsc-v1\n  sudo mv runsc containerd-shim-runsc-v1 /usr/local/bin\n)\n</code></pre> <p>Refer to the gVisor install docs for more information.</p> </li> <li> <p>Prepare the config for <code>k0s</code> managed containerd, to utilize gVisor as additional runtime:</p> <pre><code>cat &lt;&lt;EOF | sudo tee /etc/k0s/containerd.d/gvisor.toml\nversion = 2\n\n[plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runsc]\n  runtime_type = \"io.containerd.runsc.v1\"\nEOF\n</code></pre> </li> <li> <p>Start and join the worker into the cluster, as normal:</p> <pre><code>k0s worker $token\n</code></pre> </li> <li> <p>Register containerd to the Kubernetes side to make gVisor runtime usable for workloads (by default, containerd uses normal runc as the runtime):</p> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: node.k8s.io/v1\nkind: RuntimeClass\nmetadata:\n  name: gvisor\nhandler: runsc\nEOF\n</code></pre> <p>At this point, you can use gVisor runtime for your workloads:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-gvisor\nspec:\n  runtimeClassName: gvisor\n  containers:\n  - name: nginx\n    image: nginx\n</code></pre> </li> <li> <p>(Optional) Verify that the created nginx pod is running under gVisor runtime:</p> <pre><code># kubectl exec nginx-gvisor -- dmesg | grep -i gvisor\n[    0.000000] Starting gVisor...\n</code></pre> </li> </ol>"},{"location":"runtime/#using-nvidia-container-runtime","title":"Using nvidia-container-runtime","text":"<p>First, deploy the NVIDIA GPU operator Helm chart with the following commands on top of your k0s cluster:</p> <pre><code>helm repo add nvidia https://helm.ngc.nvidia.com/nvidia\nhelm repo update\nhelm install nvidia-gpu-operator -n nvidia-gpu-operator \\\n  --create-namespace \\\n  --set operator.defaultRuntime=containerd \\\n  --set toolkit.env[0].name=CONTAINERD_CONFIG \\\n  --set toolkit.env[0].value=/etc/k0s/containerd.d/nvidia.toml \\\n  --set toolkit.env[1].name=CONTAINERD_SOCKET \\\n  --set toolkit.env[1].value=/run/k0s/containerd.sock \\\n  --set toolkit.env[2].name=CONTAINERD_RUNTIME_CLASS \\\n  --set toolkit.env[2].value=nvidia \\\n  nvidia/gpu-operator\n</code></pre> <p>With this Helm chart values, NVIDIA GPU operator will deploy both driver and toolkit to the GPU nodes and additionally will configure containerd with NVIDIA specific runtime.</p> <p>Note: Detailed installation instructions can be found in the official NVIDIA GPU Operator documentation.</p>"},{"location":"runtime/#using-custom-cri-runtimes","title":"Using custom CRI runtimes","text":"<p>Warning: You can use your own CRI runtime with k0s (for example, <code>docker</code>). However, k0s will not start or manage the runtime, and configuration is solely your responsibility.</p> <p>Use the option <code>--cri-socket</code> to run a k0s worker with a custom CRI runtime. The option takes input in the form of <code>&lt;type&gt;:&lt;url&gt;</code> (the only supported type is <code>remote</code>).</p>"},{"location":"runtime/#using-docker-as-the-container-runtime","title":"Using Docker as the container runtime","text":"<p>As of Kubernetes 1.24, the use of Docker as a container runtime is no longer supported out of the box. However, Mirantis provides cri-dockerd, a shim that allows Docker to be controlled via CRI. It's based on the dockershim that was previously part of upstream Kubernetes.</p>"},{"location":"runtime/#configuration","title":"Configuration","text":"<p>In order to use Docker as the container runtime for k0s, the following steps need to be taken:</p> <ol> <li> <p>Manually install required components.   On each <code>k0s worker</code> and <code>k0s controller --enable-worker</code> node, both   Docker Engine and cri-dockerd need to be installed manually. Follow the   official Docker Engine installation guide and cri-dockerd   installation instructions.</p> </li> <li> <p>Configure and restart affected k0s nodes.   Once installations are complete, the nodes needs to be restarted with the   <code>--cri-socket</code> flag pointing to cri-dockerd's socket, which is typically   located at <code>/var/run/cri-dockerd.sock</code>. For instance, the commands to start a   node would be as follows:</p> <pre><code>k0s worker --cri-socket=remote:unix:///var/run/cri-dockerd.sock\n</code></pre> <p>or, respectively</p> <pre><code>k0s controller --enable-worker --cri-socket=remote:unix:///var/run/cri-dockerd.sock\n</code></pre> <p>When running k0s as a service, consider reinstalling the service with the appropriate flags:</p> <pre><code>sudo k0s install --force worker --cri-socket=remote:unix:///var/run/cri-dockerd.sock\n</code></pre> <p>or, respectively</p> <pre><code>sudo k0s install --force controller --enable-worker --cri-socket=remote:unix:///var/run/cri-dockerd.sock\n</code></pre> </li> </ol> <p>In scenarios where Docker is managed via systemd, it is crucial that the <code>cgroupDriver: systemd</code> setting is included in the Kubelet configuration. It can be added to the <code>workerProfiles</code> section of the k0s configuration. An example of how the k0s configuration might look:</p> <pre><code>apiVersion: k0s.k0sproject.io/v1beta1\nkind: ClusterConfig\nmetadata:\n  name: k0s\nspec:\n  workerProfiles:\n    - name: systemd-docker-cri\n      values:\n        cgroupDriver: systemd\n</code></pre> <p>Note that this is a cluster-wide configuration setting that must be added to the k0s controller's configuration rather than directly to the workers, or to the cluster configuration if using dynamic configuration. See the worker profiles section of the documentation for more details. When starting workers, both the <code>--profile=systemd-docker-cri</code> and <code>--cri-socket</code> flags are required. The profile name, such as <code>systemd-docker-cri</code>, is flexible. Alternatively, this setting can be applied to the <code>default</code> profile, which will apply to all nodes started without a specific profile. In this case, the <code>--profile</code> flag is not needed.</p> <p>Please note that there are currently some pitfalls around container metrics when using cri-dockerd.</p>"},{"location":"runtime/#verification","title":"Verification","text":"<p>The successful configuration can be verified by executing the following command:</p> <pre><code>$ kubectl get nodes -o wide\nNAME              STATUS   ROLES    AGE   VERSION       INTERNAL-IP     EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME\ndocker-worker-0   Ready    &lt;none&gt;   15m   v1.34.1+k0s   172.27.77.155   &lt;none&gt;        Ubuntu 22.04.3 LTS   5.15.0-82-generic   docker://24.0.7\n</code></pre> <p>On the worker nodes, the Kubernetes containers should be listed as regular Docker containers:</p> <pre><code>$ docker ps --format \"table {{.ID}}\\t{{.Names}}\\t{{.State}}\\t{{.Status}}\"\nCONTAINER ID   NAMES                                                                                                   STATE     STATUS\n9167a937af28   k8s_konnectivity-agent_konnectivity-agent-9rnj7_kube-system_430027b4-75c3-487c-b94d-efeb7204616d_1      running   Up 14 minutes\nb6978162a05d   k8s_metrics-server_metrics-server-7556957bb7-wfg8k_kube-system_5f642105-78c8-450a-bfd2-2021b680b932_1   running   Up 14 minutes\nd576abe86c92   k8s_coredns_coredns-85df575cdb-vmdq5_kube-system_6f26626e-d241-4f15-889a-bcae20d04e2c_1                 running   Up 14 minutes\n8f268b180c59   k8s_kube-proxy_kube-proxy-2x6jz_kube-system_34a7a8ba-e15d-4968-8a02-f5c0cb3c8361_1                      running   Up 14 minutes\ned0a665ec28e   k8s_POD_konnectivity-agent-9rnj7_kube-system_430027b4-75c3-487c-b94d-efeb7204616d_0                     running   Up 14 minutes\na9861a7beab5   k8s_POD_metrics-server-7556957bb7-wfg8k_kube-system_5f642105-78c8-450a-bfd2-2021b680b932_0              running   Up 14 minutes\n898befa4840e   k8s_POD_kube-router-fftkt_kube-system_940ad783-055e-4fce-8ce1-093ca01625b9_0                            running   Up 14 minutes\ne80dabc23ce7   k8s_POD_kube-proxy-2x6jz_kube-system_34a7a8ba-e15d-4968-8a02-f5c0cb3c8361_0                             running   Up 14 minutes\n430a784b1bdd   k8s_POD_coredns-85df575cdb-vmdq5_kube-system_6f26626e-d241-4f15-889a-bcae20d04e2c_0                     running   Up 14 minutes\n</code></pre>"},{"location":"security/","title":"Security policy","text":""},{"location":"security/#security-policy","title":"Security policy","text":"<p>For the security policy, please refer to the upstream k0s documentation.</p>"},{"location":"selinux/","title":"SELinux","text":""},{"location":"selinux/#selinux-overview","title":"SELinux Overview","text":"<p>SELinux enforces mandatory access control policies that confine user programs and system services, as well as access to files and network resources. Limiting privilege to the minimum required to work reduces or eliminates the ability of these programs and daemons to cause harm if faulty or compromised.</p> <p>Enabling SELinux in container runtime provides an additional security control to help further enforce isolation among deployed containers and the host.</p> <p>This guide describes how to enable SELinux in Kubernetes environment provided by k0s on CentOS and Red Hat Enterprise Linux (RHEL).</p>"},{"location":"selinux/#requirements","title":"Requirements","text":"<ul> <li>SELinux is enabled on host OS of the worker nodes.</li> <li>SELinux has the container-selinux policy installed.</li> <li>SELinux labels are correctly set for k0s installation files of the worker nodes.</li> <li>SELinux is enabled in container runtime such as containerd on the worker nodes.</li> </ul>"},{"location":"selinux/#check-whether-selinux-is-enabled","title":"Check whether SELinux is enabled","text":"<p>SELinux is enabled on CentOS and RHEL by default. Below command output indicates SELinux is enabled.</p> <pre><code>$ getenforce\nEnforcing\n</code></pre>"},{"location":"selinux/#install-container-selinux","title":"Install container-selinux","text":"<p>It is required to have container-selinux installed. In most Fedora based distributions including Fedora 37, Red Hat Enterprise Linux 7, 8 and 8, CentOS 7 and 8 and Rocky Linux 9 this can be achieved by installing the package container-selinux.</p> <p>In RHEL 7 and CentOS 7 this is achieved by running:</p> <pre><code>yum install -y container-selinux\n</code></pre> <p>In the rest of the metnioned distributions run:</p> <pre><code>dnf install -y container-selinux\n</code></pre>"},{"location":"selinux/#set-selinux-labels-for-k0s-installation-files","title":"Set SELinux labels for k0s installation files","text":"<p>Run below commands on the host OS of the worker nodes.</p> <pre><code>DATA_DIR=\"/var/lib/k0s\"\nsudo semanage fcontext -a -t container_runtime_exec_t \"${DATA_DIR}/bin/containerd.*\"\nsudo semanage fcontext -a -t container_runtime_exec_t \"${DATA_DIR}/bin/runc\"\nsudo restorecon -R -v ${DATA_DIR}/bin\nsudo semanage fcontext -a -t container_var_lib_t \"${DATA_DIR}/containerd(/.*)?\"\nsudo semanage fcontext -a -t container_ro_file_t \"${DATA_DIR}/containerd/io.containerd.snapshotter.*/snapshots(/.*)?\"\nsudo restorecon -R -v ${DATA_DIR}/containerd\n</code></pre>"},{"location":"selinux/#enable-selinux-in-containerd-of-k0s","title":"Enable SELinux in containerd of k0s","text":"<p>Add below lines to <code>/etc/k0s/containerd.toml</code> of the worker nodes. You need to restart k0s service on the node to make the change take effect.</p> <pre><code>[plugins.\"io.containerd.grpc.v1.cri\"]\n  enable_selinux = true\n</code></pre>"},{"location":"selinux/#verify-selinux-works-in-kubernetes-environment","title":"Verify SELinux works in Kubernetes environment","text":"<p>By following the example Assign SELinux labels to a Container, deploy a testing pod using below YAML file:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: test-selinux\nspec:\n  containers:\n  - image: busybox\n    name: test-selinux\n    command: [\"sleep\", \"infinity\"]\n    securityContext:\n      seLinuxOptions:\n        level: \"s0:c123,c456\"\n</code></pre> <p>After the pod starts, ssh to the worker node on which the pod is running and check the pod process. It should display the label <code>s0:c123,c456</code> that you specified in YAML file:</p> <pre><code>$ ps -efZ | grep -F 'sleep infinity'\nsystem_u:system_r:container_t:s0:c123,c456 root 3346 3288  0 16:39 ?       00:00:00 sleep infinity\n</code></pre>"},{"location":"shell-completion/","title":"Shell Completion","text":""},{"location":"shell-completion/#enabling-shell-completion","title":"Enabling Shell Completion","text":""},{"location":"shell-completion/#introduction","title":"Introduction","text":"<p>Shell completion enhances the user experience by providing auto-completion for commands in the terminal. K0s supports shell completion for the following shells:</p> <ul> <li><code>bash</code>, GNU Bash</li> <li><code>zsh</code>, the Z-shell</li> <li><code>fish</code>, the friendly interactive shell</li> <li><code>powershell</code>, Microsoft PowerShell</li> </ul>"},{"location":"shell-completion/#general-usage","title":"General Usage","text":"<p>To generate a completion script for your shell, use the following command: <code>k0s completion &lt;shell_name&gt;</code>. Sourcing the completion script in your shell enables k0s autocompletion.</p>"},{"location":"shell-completion/#bash","title":"bash","text":"<p>One-shot usage: <code>source &lt;(k0s completion bash)</code>.</p> <p>This is a recipe to load completions for each new shell. Adjust to your personal needs:</p> <pre><code>mkdir ~/.bash_completion.d\nk0s completion bash &gt;~/.bash_completion.d/k0s\n\ncat &lt;&lt;'EOF' &gt;~/.bashrc\nfor compFile in ~/.bash_completion.d/*; do\n  [ ! -f \"$compFile\" ] || source -- \"$compFile\"\ndone\nunset compFile\nEOF\n</code></pre> <p>Then restart the shell or source <code>~/.bashrc</code>.</p>"},{"location":"shell-completion/#zsh","title":"zsh","text":"<p>One-shot usage: <code>source &lt;(k0s completion bash)</code>.</p> <p>Following a recipe to load completions for each new shell. Adjust to your personal needs. If shell completion is not already enabled in your zsh environment you will need to enable it:</p> <pre><code>echo \"autoload -Uz compinit; compinit\" &gt;&gt;~/.zshrc\n</code></pre> <p>Place the completion script in a custom <code>site-functions</code> folder:</p> <pre><code>mkdir -p -- ~/.local/share/zsh/site-functions\nk0s completion zsh &gt;~/.local/share/zsh/site-functions/_k0s\n</code></pre> <p>Edit <code>~/.zshrc</code> and add the line <code>fpath+=(~/.local/share/zsh/site-functions)</code> somewhere before <code>compinit</code> is called. After that, restart the shell.</p> <p>When using Oh My ZSH!, you can create a custom plugin:</p> <pre><code>mkdir -- \"$ZSH_CUSTOM/plugins/k0s\"\ncat &lt;&lt;'EOF' &gt;\"$ZSH_CUSTOM/plugins/k0s/k0s.plugin.zsh\"\nk0s completion zsh &gt;| \"$ZSH_CACHE_DIR/completions/_k0s\" &amp;|\nEOF\nomz plugin enable k0s\n</code></pre> <p>Then restart the shell.</p>"},{"location":"shell-completion/#fish","title":"fish","text":"<p>One-shot usage: <code>k0s completion fish | source</code>.</p> <p>This is a recipe to load completions for each new shell. Adjust to your personal needs:</p> <pre><code>mkdir -p -- \"${XDG_CONFIG_HOME:-$HOME/.config}/fish/completions\"\nk0s completion fish &gt;\"${XDG_CONFIG_HOME:-$HOME/.config}/fish/completions/k0s.fish\"\n</code></pre> <p>Then restart the shell.</p>"},{"location":"shell-completion/#powershell","title":"powershell","text":"<p>Save the completion script into a file:</p> <pre><code>k0s completion powershell &gt; C:\\path\\to\\k0s.ps1\n</code></pre> <p>You can import it like so:</p> <pre><code>Import-Module C:\\path\\to\\k0s.ps1\n</code></pre> <p>To automatically load the module for each new shell session, add the above line to your shell profile. You can find the path to your profile via <code>Write-Output $profile</code>.</p>"},{"location":"single-stack-ipv6/","title":"IPv6 single-stack networking","text":""},{"location":"single-stack-ipv6/#ipv6-single-stack-networking","title":"IPv6 single-stack networking","text":"<p>K0s introduced experimental IPv6 single-stack networking, allowing clusters to operate exclusively with IPv6 addresses. IPv6 single stack is currently in alpha state and requires the IPv6SingleStack feature gate to be enabled on every controller.</p> <p>IPv6 single-stack is fully compatible with both node-local load balancing and control plane load balancing.</p>"},{"location":"single-stack-ipv6/#enabling-ipv6-single-stack-using-the-default-cni-kube-router","title":"Enabling IPv6 single-stack using the default CNI (Kube-router)","text":"<p>In order to enable IPv6 single-stack networking using the default CNI provider, both an IPv6 <code>podCIDR</code> and <code>serviceCIDR</code> must be provided. Dual stack must not be enabled. Migrations to dual stack are possible as long as the primary address family remains IPv6.</p> <pre><code>spec:\n  network:\n    podCIDR: fd00::/108\n    serviceCIDR: fd01::/108\n</code></pre> <p>Ensure that every controller in the cluster is executed with the IPv6SingleStack feature gate enabled:</p> <pre><code>k0s controller --feature-gates=\"IPv6SingleStack=true\"\n</code></pre> <p>This configuration will set up all Kubernetes components and Kube-router for IPv6 single-stack networking.</p>"},{"location":"single-stack-ipv6/#configuring-the-node-cidr-mask-size","title":"Configuring the node CIDR mask size","text":"<p>By default, k0s uses a <code>/117</code> node CIDR mask size for IPv6, which provides 2048 IP addresses per node and and a <code>/24</code> for IPv4 which provides 256 addresses per node.</p> <p>Using the example configuration <code>IPv6PodCIDR: fd00::/108</code>, there are 9 bits available for node allocation (117 - 108 = 9) and 11 bits available for pod allocation (128 - 117 = 11). This allows 512 nodes with 2048 IPs per node.</p> <p>You can customize the node CIDR mask size using the controller manager's extra arguments:</p> <pre><code>spec:\n  controllerManager:\n    extraArgs:\n      node-cidr-mask-size: \"120\"\n  network:\n    podCIDR: fd00::/108\n    serviceCIDR: fd01::/108\n</code></pre> <p>With a <code>/120</code> node CIDR mask size, the cluster would support more nodes (4096 nodes maximum with the <code>/108</code> pod CIDR) but each node would receive 256 IP addresses.</p>"},{"location":"single-stack-ipv6/#important-notes-for-kube-router","title":"Important Notes for Kube-router","text":"<p>Currently kube-router on IPv6 doesn't pass the kubernetes network conformance tests.</p>"},{"location":"storage/","title":"Storage (CSI)","text":""},{"location":"storage/#storage","title":"Storage","text":""},{"location":"storage/#csi","title":"CSI","text":"<p>k0s supports a wide range of different storage options by utilizing Container Storage Interface (CSI). All Kubernetes storage solutions are supported and users can easily select the storage that fits best for their needs.</p> <p>When the storage solution implements CSI, Kubernetes can communicate with the storage to create and configure persistent volumes. This makes it easy to dynamically provision the requested volumes. It also expands the supported storage solutions from the previous generation, in-tree volume plugins. More information about the CSI concept is described on the Kubernetes Blog.</p> <p></p>"},{"location":"storage/#installing-3rd-party-storage-solutions","title":"Installing 3rd party storage solutions","text":"<p>Follow your storage driver's installation instructions. Note that by default the Kubelet installed by k0s uses a slightly different path for its working directory (<code>/var/lib/k0s/kubelet</code> instead of <code>/var/lib/kubelet</code>). Consult the CSI driver's configuration documentation on how to customize this path. The actual path can differ if you defined the flag <code>--data-dir</code>.</p>"},{"location":"storage/#example-storage-solutions","title":"Example storage solutions","text":"<p>Different Kubernetes storage solutions are explained in the official Kubernetes storage documentation. All of them can be used with k0s. Here are some popular ones:</p> <ul> <li>Rook-Ceph (Open Source)</li> <li>MinIO (Open Source)</li> <li>GlusterFS (Open Source)</li> <li>Longhorn (Open Source)</li> <li>Amazon EBS</li> <li>Google Persistent Disk</li> <li>Azure Disk</li> <li>Portworx</li> </ul> <p>If you are looking for a fault-tolerant storage with data replication, you can follow our tutorial for configuring Ceph storage with Rook.</p>"},{"location":"system-monitoring/","title":"System Components Monitoring","text":""},{"location":"system-monitoring/#system-components-monitoring","title":"System components monitoring","text":"<p>Controller nodes are isolated by default, which thus means that a cluster user cannot schedule workloads onto controller nodes.</p> <p>k0s provides a mechanism to expose system components for monitoring. System component metrics can give a better look into what is happening inside them. Metrics are particularly useful for building dashboards and alerts. You can read more about metrics for Kubernetes system components in the Kubernetes documentation.</p> <p>Note: the mechanism is an opt-in feature, you can enable it on installation:</p> <pre><code>sudo k0s install controller --enable-metrics-scraper\n</code></pre> <p>Once enabled, a new set of objects will appear in the cluster:</p> <pre><code>\u276f ~ kubectl get all -n k0s-system\nNAME                                   READY   STATUS    RESTARTS   AGE\npod/k0s-pushgateway-6c5d8c54cf-bh8sb   1/1     Running   0          43h\n\nNAME                      TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE\nservice/k0s-pushgateway   ClusterIP   10.100.11.116   &lt;none&gt;        9091/TCP   43h\n\nNAME                              READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/k0s-pushgateway   1/1     1            1           43h\n\nNAME                                         DESIRED   CURRENT   READY   AGE\nreplicaset.apps/k0s-pushgateway-6c5d8c54cf   1         1         1       43h\n</code></pre> <p>That's not enough to start scraping these additional metrics. For Prometheus Operator based solutions, you can create a <code>ServiceMonitor</code> for it like this:</p> <pre><code>apiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: k0s\n  namespace: k0s-system\nspec:\n  endpoints:\n  - port: http\n  selector:\n    matchLabels:\n      app: k0s-observability\n      component: pushgateway\n      k0s.k0sproject.io/stack: metrics\n</code></pre> <p>Note that it won't clear alerts like <code>KubeControllerManagerDown</code> or <code>KubeSchedulerDown</code> as they are based on Prometheus' internal <code>up</code> metrics. But you can get rid of these alerts by modifying them to detect a working component like this:</p> <pre><code>absent(apiserver_audit_event_total{job=\"kube-scheduler\"})\n</code></pre>"},{"location":"system-monitoring/#jobs","title":"Jobs","text":"<p>The list of components which is scrapped by k0s:</p> <ul> <li>kube-scheduler</li> <li>kube-controller-manager</li> <li>etcd</li> <li>kine</li> </ul> <p>Note: kube-apiserver metrics are not scrapped since they are accessible via <code>kubernetes</code> endpoint within the cluster.</p>"},{"location":"system-monitoring/#architecture","title":"Architecture","text":"<p>k0s uses a pushgateway with a TTL to make it possible to detect issues with the metrics delivery. The default TTL is 2 minutes.</p>"},{"location":"system-requirements/","title":"System Requirements","text":""},{"location":"system-requirements/#system-requirements","title":"System requirements","text":"<p>This page describes the system requirements for k0s.</p>"},{"location":"system-requirements/#minimum-memory-and-cpu-requirements","title":"Minimum memory and CPU requirements","text":"<p>The minimum requirements for k0s detailed below are approximations, and thus your results may vary.</p> Role Memory (RAM in GB) Virtual CPUs (vCPU) Controller node 1 1 Worker node 0.5 1 Controller + worker 1 1"},{"location":"system-requirements/#controller-node-recommendations","title":"Controller node recommendations","text":"# of worker nodes # of pods Recommended RAM (in GB) Recommended vCPU 10 1000 1-2 1-2 50 5000 2-4 2-4 100 10000 4-8 2-4 500 50000 8-16 4-8 1000 100000 16-32 8-16 5000 150000 32-64 16-32 <p>k0s has the standard Kubernetes limits for the maximum number of nodes, pods, etc. For more details, see the Kubernetes considerations for large clusters.</p> <p>k0s controller node measured memory consumption can be found below on this page.</p>"},{"location":"system-requirements/#storage","title":"Storage","text":"<p>It's recommended to use an SSD for optimal storage performance (cluster latency and throughput are sensitive to storage).</p> <p>For worker nodes it is required that there is at least 15% relative disk space free.</p> <p>The specific storage consumption for k0s is as follows:</p> Role Usage (k0s part) Minimum required Controller node ~0.5 GB ~0.5 GB Worker node ~1.3 GB ~1.6 GB Controller + worker ~1.7 GB ~2.0 GB <p>Note: The operating system and application requirements must be considered in addition to the k0s part.</p>"},{"location":"system-requirements/#host-operating-system","title":"Host operating system","text":"<p>k0s runs on Linux and Windows operating systems.</p> <p>The following operating systems are automatically tested as part of our CI:</p> Operating System Version/Notes Amazon Linux 2023 Alpine Linux 3.19, 3.22 CentOS Stream 9, 10 (Coughlan) Debian GNU/Linux 11 (bullseye) (supported until 2026-08-31), 12 (bookworm) (supported until 2028-06-30) Fedora CoreOS stable stream Fedora Linux 41 (Cloud Edition) Flatcar Container Linux by Kinvolk Oracle Linux Server 8.9, 9.3 Red Hat Enterprise Linux 7.9 (Maipo), 8.10 (Ootpa), 9.5 (Plow) Rocky Linux 8.10 (Green Obsidian), 9.5 (Blue Onyx) SUSE Linux Enterprise Server 15 SP6 Ubuntu 20.04 LTS, 22.04 LTS, 24.04 <p>Note: For detailed Linux-specific requirements, please refer to the Linux specific requirements.</p>"},{"location":"system-requirements/#architecture","title":"Architecture","text":"<ul> <li><code>x86_64</code></li> <li><code>aarch64</code></li> <li><code>armv7l</code></li> </ul>"},{"location":"system-requirements/#networking","title":"Networking","text":"<p>For information on the required ports and protocols, refer to networking.</p>"},{"location":"system-requirements/#external-runtime-dependencies","title":"External runtime dependencies","text":"<p>k0s strives to be as independent from the operating system as possible. See the dedicated section on external runtime dependencies for details on current and past requirements.</p> <p>To run some automated compatiblility checks on your system, use <code>k0s sysinfo</code>.</p>"},{"location":"system-requirements/#controller-node-measured-memory-consumption","title":"Controller node measured memory consumption","text":"<p>The following table shows the measured memory consumption in the cluster of one controller node.</p> # of Worker nodes # of Pods (besides default) Memory consumption (in MB) 1 0 510 1 100 600 20 0 660 20 2000 1000 50 0 790 50 5000 1400 100 0 1000 100 10000 2300 200 0 1500 200 20000 3300 <p>Measurement details:</p> <ul> <li>k0s v1.22.4+k0s.2 (default configuration with etcd)</li> <li>Ubuntu Server 20.04.3 LTS, OS part of the used memory was around 180 MB</li> <li>Hardware: AWS t3.xlarge (4 vCPUs, 16 GB RAM)</li> <li>Pod image: nginx:1.21.4</li> </ul>"},{"location":"upgrade/","title":"Upgrade","text":""},{"location":"upgrade/#upgrade","title":"Upgrade","text":"<p>The k0s upgrade is a simple process due to its single binary distribution. The k0s single binary file includes all the necessary parts for the upgrade and essentially the upgrade process is to replace that file and restart the service.</p> <p>This tutorial explains two different approaches for k0s upgrade:</p> <ul> <li>Upgrade a k0s node locally</li> <li>Upgrade a k0s cluster using k0sctl</li> </ul>"},{"location":"upgrade/#upgrade-a-k0s-node-locally","title":"Upgrade a k0s node locally","text":"<p>If your k0s cluster has been deployed with k0sctl, then k0sctl provides the easiest upgrade method. In that case jump to the next chapter. However, if you have deployed k0s without k0sctl, then follow the upgrade method explained in this chapter.</p> <p>Before starting the upgrade, consider moving your applications to another node if you want to avoid downtime. This can be done by draining a worker node. Remember to uncordon the worker node afterwards to tell Kubernetes that it can resume scheduling new pods onto the node.</p> <p>The upgrade process is started by stopping the currently running k0s service.</p> <pre><code>sudo k0s stop\n</code></pre> <p>Now you can replace the old k0s binary file. The easiest way is to use the download script. It will download the latest k0s binary and replace the old binary with it. You can also do this manually without the download script.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://get.k0s.sh | sudo sh\n</code></pre> <p>Then you can start the service (with the upgraded k0s) and your upgrade is done.</p> <pre><code>sudo k0s start\n</code></pre>"},{"location":"upgrade/#upgrade-a-k0s-cluster-using-k0sctl","title":"Upgrade a k0s cluster using k0sctl","text":"<p>The upgrading of k0s clusters using k0sctl occurs not through a particular command (there is no <code>upgrade</code> sub-command in k0sctl) but by way of the configuration file. The configuration file describes the desired state of the cluster. When you pass the description to the <code>k0sctl apply</code> command, the system discovers the current state and performs whatever actions are necessary to bring the cluster to the desired state. For example, the system might perform an upgrade.</p>"},{"location":"upgrade/#k0sctl-cluster-upgrade-process","title":"k0sctl cluster upgrade process","text":"<p>The following operations occur during a k0sctl upgrade:</p> <ol> <li> <p>Upgrade of each controller, one at a time. There is no downtime if multiple controllers are configured.</p> </li> <li> <p>Upgrade of workers, in batches of 10%.</p> </li> <li> <p>Draining of workers, which allows the workload to move to other nodes prior to the actual upgrade of the worker node components. (To skip the drain process, use the <code>--no-drain</code> option.)</p> </li> <li> <p>The upgrade process continues once the upgraded nodes return to Ready state.</p> </li> </ol> <p>You can configure the desired cluster version in the k0sctl configuration by setting the value of <code>spec.k0s.version</code>:</p> <pre><code>spec:\n  k0s:\n    version: v1.34.1+head\n</code></pre> <p>If you do not specify a version, k0sctl checks online for the latest version and defaults to it.</p> <pre><code>k0sctl apply\n</code></pre> <pre><code>...\n...\nINFO[0001] ==&gt; Running phase: Upgrade controllers\nINFO[0001] [ssh] 10.0.0.23:22: starting upgrade\nINFO[0001] [ssh] 10.0.0.23:22: Running with legacy service name, migrating...\nINFO[0011] [ssh] 10.0.0.23:22: waiting for the k0s service to start\nINFO[0016] ==&gt; Running phase: Upgrade workers\nINFO[0016] Upgrading 1 workers in parallel\nINFO[0016] [ssh] 10.0.0.17:22: upgrade starting\nINFO[0027] [ssh] 10.0.0.17:22: waiting for node to become ready again\nINFO[0027] [ssh] 10.0.0.17:22: upgrade successful\nINFO[0027] ==&gt; Running phase: Disconnect from hosts\nINFO[0027] ==&gt; Finished in 27s\nINFO[0027] k0s cluster version v1.34.1+head is now installed\nINFO[0027] Tip: To access the cluster you can now fetch the admin kubeconfig using:\nINFO[0027]      k0sctl kubeconfig\n</code></pre>"},{"location":"user-management/","title":"User Management","text":""},{"location":"user-management/#user-management","title":"User Management","text":"<p>Kubernetes, and thus k0s, does not have any built-in functionality to manage users. Kubernetes relies solely on external sources for user identification and authentication. A client certificate is considered an external source in this case as Kubernetes API server \"just\" validates that the certificate is signed by a trusted CA. This means that it is recommended to use e.g. OpenID Connect to configure the API server to trust tokens issued by an external Identity Provider.</p> <p>k0s comes with some helper commands to create kubeconfig with client certificates for users. There are few caveats that one needs to take into consideration when using client certificates:</p> <ul> <li>Client certificates have long expiration time, they're valid for one year</li> <li>Client certificates cannot be revoked (general Kubernetes challenge)</li> </ul>"},{"location":"user-management/#adding-a-cluster-user","title":"Adding a Cluster User","text":"<p>Run the kubeconfig create command on the controller to add a user to the cluster. The command outputs a kubeconfig for the user, to use for authentication.</p> <pre><code>k0s kubeconfig create [username]\n</code></pre>"},{"location":"user-management/#enabling-access-to-cluster-resources","title":"Enabling Access to Cluster Resources","text":"<p>Create the user with the <code>system:masters</code> group to grant the user access to the cluster:</p> <pre><code>k0s kubeconfig create --groups \"system:masters\" testUser &gt; k0s.config\n</code></pre> <p>Create a <code>roleBinding</code> to grant the user access to the resources:</p> <pre><code>k0s kubectl create clusterrolebinding --kubeconfig k0s.config testUser-admin-binding --clusterrole=admin --user=testUser\n</code></pre>"},{"location":"verifying-signs/","title":"Verifying Signed Binaries","text":""},{"location":"verifying-signs/#verifying-signed-binaries","title":"Verifying Signed Binaries","text":"<p>K0smotron team provides signed binaries for k0s. The signatures are created using cosign. Public key and signature files are available for download from the releases page. Binaries can be verified using the <code>cosign</code> tool, for example:</p> <pre><code>cosign verify-blob \\\n  --key https://github.com/k0sproject/k0s/releases/download/v1.34.1%2Bhead/cosign.pub \\\n  --signature https://github.com/k0sproject/k0s/releases/download/v1.34.1%2Bhead/k0s-v1.34.1%2Bhead-amd64.sig \\\n  k0s-v1.34.1+head-amd64\n</code></pre>"},{"location":"worker-node-config/","title":"Worker Node Configuration","text":""},{"location":"worker-node-config/#configuration-options-for-worker-nodes","title":"Configuration options for worker nodes","text":"<p>Although the <code>k0s worker</code> command does not take in any special YAML configuration, there are still methods for configuring the workers to run various components.</p>"},{"location":"worker-node-config/#node-labels","title":"Node labels","text":"<p>The <code>k0s worker</code> command accepts the <code>--labels</code> flag, with which you can make the newly joined worker node register itself, in the Kubernetes API, with the given set of labels.</p> <p>For example, running the worker with <code>k0s worker --token-file k0s.token --labels=\"k0sproject.io/foo=bar,k0sproject.io/other=xyz\"</code> results in:</p> <pre><code>$ kubectl get node --show-labels\nNAME      STATUS     ROLES    AGE   VERSION       LABELS\nworker0   NotReady   &lt;none&gt;   10s   v1.34.1+k0s   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,k0sproject.io/foo=bar,k0sproject.io/other=xyz,kubernetes.io/arch=amd64,kubernetes.io/hostname=worker0,kubernetes.io/os=linux\n</code></pre> <p>Controller worker nodes are assigned <code>node.k0sproject.io/role=control-plane</code> and <code>node-role.kubernetes.io/control-plane=true</code> labels:</p> <pre><code>$ kubectl get node --show-labels\nNAME          STATUS     ROLES           AGE   VERSION       LABELS\ncontroller0   NotReady   control-plane   10s   v1.34.1+k0s   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/hostname=worker0,kubernetes.io/os=linux,node.k0sproject.io/role=control-plane,node-role.kubernetes.io/control-plane=true\n</code></pre> <p>Note: Setting the labels is only effective on the first registration of the node. Changing the labels thereafter has no effect.</p>"},{"location":"worker-node-config/#taints","title":"Taints","text":"<p>The <code>k0s worker</code> command accepts the <code>--taints</code> flag, with which you can make the newly joined worker node register itself with the given set of taints.</p> <p>Note: Controller nodes running with <code>--enable-worker</code> are assigned <code>node-role.kubernetes.io/control-plane:NoExecute</code> taint automatically. You can disable default taints using <code>--no-taints</code> parameter.</p> <pre><code>kubectl get nodes -o custom-columns=NAME:.metadata.name,TAINTS:.spec.taints\n</code></pre> <pre><code>NAME          TAINTS\ncontroller0   [map[effect:NoSchedule key:node-role.kubernetes.io/control-plane]]\nworker0       &lt;none&gt;\n</code></pre>"},{"location":"worker-node-config/#kubelet-configuration","title":"Kubelet configuration","text":"<p>The <code>k0s worker</code> command accepts a generic flag to pass in any set of arguments for the kubelet process.</p> <p>For example, running <code>k0s worker --token-file=k0s.token --kubelet-extra-args=\"--node-ip=1.2.3.4 --address=0.0.0.0\"</code> passes in the given flags to Kubelet as-is. As such, you must confirm that any flags you are passing in are properly formatted and valued as k0s will not validate those flags.</p>"},{"location":"worker-node-config/#worker-profiles","title":"Worker Profiles","text":"<p>Kubelet configuration fields can also be set via worker profiles. Worker profiles are defined in the main k0s.yaml and are used to generate ConfigMaps containing a custom <code>kubelet.config.k8s.io/v1beta1/KubeletConfiguration</code> object. See also the examples of k0s.yaml containing worker profiles and the list of possible Kubelet configuration fields.</p>"},{"location":"worker-node-config/#iptables-mode","title":"IPTables Mode","text":"<p>k0s detects the iptables backend automatically based on the existing records. On a brand-new setup, <code>iptables-nft</code> will be used. There is an <code>--iptables-mode</code> flag to specify the mode explicitly. Valid values: <code>nft</code>, <code>legacy</code> and <code>auto</code> (default).</p> <pre><code>k0s worker --iptables-mode=nft\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#architecture","title":"Architecture","text":"<p>Note: As k0s is a dynamic project, the product architecture may occasionally outpace the documentation. The high level concepts and patterns, however, should always apply.</p>"},{"location":"architecture/#packaging","title":"Packaging","text":"<p>The k0s package is a single, self-extracting binary that embeds Kubernetes binaries, the benefits of which include:</p> <ul> <li>Statically compiled</li> <li>No OS-level dependencies</li> <li>Requires no RPMs, dependencies, snaps, or any other OS-specific packaging</li> <li>Provides a single package for all operating systems</li> <li>Allows full version control for each dependency</li> </ul> <p></p>"},{"location":"architecture/#control-plane","title":"Control plane","text":"<p>As a single binary, k0s acts as the process supervisor for all other control plane components. As such, there is no container engine or kubelet running on controllers by default, which thus means that a cluster user cannot schedule workloads onto controller nodes.</p> <p></p> <p>Using k0s you can create, manage, and configure each of the components, running each as a \"naked\" process. Thus, there is no container engine running on the controller node.</p>"},{"location":"architecture/#storage","title":"Storage","text":"<p>Kubernetes control plane typically supports only etcd as the datastore. k0s, however, supports many other datastore options in addition to etcd, which it achieves by including kine. Kine allows the use of a wide variety of backend data stores, such as MySQL, PostgreSQL, SQLite, and dqlite (refer to the <code>spec.storage</code> documentation).</p> <p>In the case of k0s managed etcd, k0s manages the full lifecycle of the etcd cluster. For example, by joining a new controller node with <code>k0s controller \"long-join-token\"</code> k0s  automatically adjusts the etcd cluster membership info to allow the new member to join the cluster.</p> <p>Note: k0s cannot shrink the etcd cluster. As such, to shut down the k0s controller on a node that node must first be manually removed from the etcd cluster.</p>"},{"location":"architecture/#worker-node","title":"Worker node","text":"<p>As with the control plane, with k0s you can create and manage the core worker components as naked processes on the worker node.</p> <p>By default, k0s workers use containerd as a high-level runtime and runc as a low-level runtime. Custom runtimes are also supported, refer to Using custom CRI runtimes.</p>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/","title":"Adr 001 autopilot oci basic auth support","text":""},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#adr-1-add-support-for-oci-registry-and-http-authentication","title":"ADR 1: Add Support for OCI Registry and HTTP Authentication","text":""},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#context","title":"Context","text":"<p>Registries are increasingly being used as generic artifact stores, expanding beyond their traditional role of hosting container images. To align with this trend, it is beneficial for Autopilot to support pulling artifacts directly from registries. Currently, Autopilot's capabilities are limited to downloading artifacts via the HTTP[S] protocols.</p> <p>Enhancing Autopilot to pull artifacts directly from registries will streamline workflows and improve efficiency by allowing integration and deployment of diverse artifacts without relying solely on HTTP[S] endpoints. This update will enable Autopilot to handle registry-specific protocols and authentication mechanisms, aligning it with modern deployment practices.</p> <p>Currently, Autopilot does not support the retrieval of artifacts via the HTTP protocol when authentication is required. Implementing this feature to accommodate such authentication methods would be a valuable enhancement.</p>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#decision","title":"Decision","text":"<p>Implement support in Autopilot for pulling artifacts, such as k0s binaries and image bundles, directly from a registry using the ORAS client. Additionally, add support for HTTP authentication to ensure secure access to artifacts.</p>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#solution","title":"Solution","text":"<p>Starting with the current <code>PlanResourceURL</code> struct:</p> <pre><code>type PlanResourceURL struct {\n    // URL is the URL of a downloadable resource.\n    URL string `json:\"url\"`\n\n    // Sha256 provides an optional SHA256 hash of the URL's content for\n    // verification.\n    Sha256 string `json:\"sha256,omitempty\"`\n}\n</code></pre> <p>We must specify to Autopilot where to access credentials for remote artifact pulls. This will be achieved by adjusting the struct as follows:</p> <pre><code>type PlanResourceURL struct {\n    // URL is the URL of a downloadable resource.\n    URL string `json:\"url\"`\n\n    // Sha256 provides an optional SHA256 hash of the URL's content for\n    // verification.\n    Sha256 string `json:\"sha256,omitempty\"`\n\n    // SecretRef holds a reference to a secret where the credentials are\n    // stored. We use these credentials when pulling the artifacts from the\n    // provided URL using\n    // any of the supported protocols (http, https, and oci).\n    SecretRef *corev1.SecretReference `json:\"secretRef,omitempty\"`\n\n    // InsecureSkipTLSVerify indicates whether certificates in the remote\n    // URL (if using TLS) can be ignored.\n    InsecureSkipTLSVerify bool `json:\"insecureSkipTLSVerify,omitempty\"`\n}\n</code></pre> <p><code>SecretRef</code> property is of type <code>SecretReference</code> as defined by <code>k8s.io/api/core/v1</code> package. The secret pointed by the provided <code>SecretRef</code> will be used for pulling artifacts using either HTTP[S] or OCI protocols.</p>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#example-configurations","title":"Example Configurations","text":""},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#configuration-for-oci","title":"Configuration for OCI","text":"<pre><code>url: oci://my.registry/binaries/k0s:v1.30.1+k0s.0\nsha256: e95603f167cce6e3cffef5594ef06785b3c1c00d3e27d8e4fc33824fe6c38a99\nsecretRef:\n  namespace: kube-system\n  name: artifacts-registry\n</code></pre>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#configuration-for-oci-using-plain-http-transport","title":"Configuration for OCI using plain HTTP transport","text":"<pre><code>url: oci+http://my.registry/binaries/k0s:v1.30.1+k0s.0\nsha256: e95603f167cce6e3cffef5594ef06785b3c1c00d3e27d8e4fc33824fe6c38a99\nsecretRef:\n  namespace: kube-system\n  name: artifacts-registry\n</code></pre>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#configuration-for-https","title":"Configuration for HTTPS","text":"<pre><code>url: https://my.file.server/binaries/k0s-v1.30.1+k0s.0\nsha256: e95603f167cce6e3cffef5594ef06785b3c1c00d3e27d8e4fc33824fe6c38a99\nsecretRef:\n  namespace: kube-system\n  name: artifacts-basic-auth\n</code></pre>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#configuration-for-http","title":"Configuration for HTTP","text":"<pre><code>url: http://my.file.server/binaries/k0s-v1.30.1+k0s.0\nsha256: e95603f167cce6e3cffef5594ef06785b3c1c00d3e27d8e4fc33824fe6c38a99\nsecretRef:\n  namespace: kube-system\n  name: artifacts-token-based-auth\n</code></pre>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#secrets-layout","title":"Secrets Layout","text":"<p>The following standard Kubernetes secret types are supported:</p> <ul> <li><code>kubernetes.io/basic-auth</code>   The username and password are used according to the protocol's standard   procedure for password-based authentication.</li> </ul> <ul> <li><code>kubernetes.io/dockerconfigjson</code>    It works in the same way as a Pod's image pull secret. Only supported for   the <code>oci://</code> protocol. (Might be supported for other protocols in the future,   as well).</li> </ul> <p>Potentially supported in the future:</p> <ul> <li><code>kubernetes.io/tls</code>   For TLS client authentication.</li> </ul> <p>Moreover, k0s supports the following custom secret type:</p> <ul> <li> <p><code>k0sproject.io/http-authorization-header</code>   Sets a custom value for the HTTP Authorization header:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: creds\n  namespace: kube-system\ndata:\n  authorization: \"Bearer abc123def456ghi789jkl0\"\n</code></pre> <p>The <code>authorization</code> entry is used as is, with its content placed directly into the <code>Authorization</code> header. A secret like the above will make Autopilot set the <code>Authorization</code> header to <code>Bearer abc123def456ghi789jkl0</code>.</p> </li> </ul>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#additional-details","title":"Additional Details","text":"<ul> <li>The <code>InsecureSkipTLSVerify</code> property is equivalent to defining   <code>InsecureSkipTLSVerify</code> on a Go HTTP client.</li> <li>The <code>InsecureSkipTLSVerify</code> property will be valid for both <code>oci://</code> and   <code>https://</code> protocols. It has no effect for the <code>oci+http://</code> and <code>http://</code>   protocols.</li> <li>If a protocol is not specified or an incorrect one is provided, an error   state should be activated.</li> <li>If no <code>SecretRef</code> is defined, access will be anonymous (no authentication).</li> </ul>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#status","title":"Status","text":"<p>Proposed</p>"},{"location":"architecture/adr-001-autopilot-oci-basic-auth-support/#consequences","title":"Consequences","text":"<ul> <li>Users will have an additional protocol to be aware of.</li> <li>If the Secret referenced by <code>SecretRef</code> does not exist, the download will   fail.</li> <li>Users need to be notified about different failure types (e.g., unreadable   secret, invalid secret).</li> <li>Additional configuration is required to handle authentication, ensuring   secure access to resources.</li> <li>We will allow downloads from remote places using self-signed certificates if   requested to.</li> </ul>"},{"location":"cli/","title":"Command Line","text":""},{"location":"cli/#k0s","title":"k0s","text":"<p>k0s - Zero Friction Kubernetes</p>"},{"location":"cli/#synopsis","title":"Synopsis","text":"<p>k0s - The zero friction Kubernetes - https://k0sproject.io</p>"},{"location":"cli/#options","title":"Options","text":"<pre><code>  -h, --help   help for k0s\n</code></pre>"},{"location":"cli/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s airgap    - Tooling for airgapped installations</li> <li>k0s api  - Run the controller API</li> <li>k0s backup    - Back-Up k0s configuration. Must be run as root (or with sudo)</li> <li>k0s completion    - Generate completion script</li> <li>k0s config    - Configuration related sub-commands</li> <li>k0s controller    - Run controller</li> <li>k0s ctr  - containerd CLI</li> <li>k0s docs    - Generate k0s command documentation</li> <li>k0s etcd    - Manage etcd cluster</li> <li>k0s install  - Install k0s on a brand-new system. Must be run as root (or with sudo)</li> <li>k0s kubeconfig    - Create a kubeconfig file for a specified user</li> <li>k0s kubectl  - kubectl controls the Kubernetes cluster manager</li> <li>k0s reset  - Uninstall k0s. Must be run as root (or with sudo)</li> <li>k0s restore  - restore k0s state from given backup archive. Use '-' as filename to read from stdin. Must be run as root (or with sudo)</li> <li>k0s start  - Start the k0s service configured on this host. Must be run as root (or with sudo)</li> <li>k0s status    - Get k0s instance status information</li> <li>k0s stop    - Stop the k0s service configured on this host. Must be run as root (or with sudo)</li> <li>k0s sysinfo  - Display system information</li> <li>k0s token  - Manage join tokens</li> <li>k0s version  - Print the k0s version</li> <li>k0s worker    - Run worker</li> </ul>"},{"location":"cli/k0s/","title":"K0s","text":""},{"location":"cli/k0s/#k0s","title":"k0s","text":"<p>k0s - Zero Friction Kubernetes</p>"},{"location":"cli/k0s/#synopsis","title":"Synopsis","text":"<p>k0s - The zero friction Kubernetes - https://k0sproject.io</p>"},{"location":"cli/k0s/#options","title":"Options","text":"<pre><code>  -h, --help   help for k0s\n</code></pre>"},{"location":"cli/k0s/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s airgap    - Tooling for airgapped installations</li> <li>k0s api  - Run the controller API</li> <li>k0s backup    - Back-Up k0s configuration. Must be run as root (or with sudo)</li> <li>k0s completion    - Generate completion script</li> <li>k0s config    - Configuration related sub-commands</li> <li>k0s controller    - Run controller</li> <li>k0s ctr  - containerd CLI</li> <li>k0s docs    - Generate k0s command documentation</li> <li>k0s etcd    - Manage etcd cluster</li> <li>k0s install  - Install k0s on a brand-new system. Must be run as root (or with sudo)</li> <li>k0s kubeconfig    - Create a kubeconfig file for a specified user</li> <li>k0s kubectl  - kubectl controls the Kubernetes cluster manager</li> <li>k0s reset  - Uninstall k0s. Must be run as root (or with sudo)</li> <li>k0s restore  - restore k0s state from given backup archive. Use '-' as filename to read from stdin. Must be run as root (or with sudo)</li> <li>k0s start  - Start the k0s service configured on this host. Must be run as root (or with sudo)</li> <li>k0s status    - Get k0s instance status information</li> <li>k0s stop    - Stop the k0s service configured on this host. Must be run as root (or with sudo)</li> <li>k0s sysinfo  - Display system information</li> <li>k0s token  - Manage join tokens</li> <li>k0s version  - Print the k0s version</li> <li>k0s worker    - Run worker</li> </ul>"},{"location":"cli/k0s_airgap/","title":"K0s airgap","text":""},{"location":"cli/k0s_airgap/#k0s-airgap","title":"k0s airgap","text":"<p>Tooling for airgapped installations</p>"},{"location":"cli/k0s_airgap/#synopsis","title":"Synopsis","text":"<p>Tooling for airgapped installations.</p> <p>For example, to create an image bundle that contains the images required for the current configuration, use the following command:</p> <pre><code>k0s airgap list-images | k0s airgap bundle-artifacts -v -o image-bundle.tar\n</code></pre> <pre><code>k0s airgap [flags]\n</code></pre>"},{"location":"cli/k0s_airgap/#options","title":"Options","text":"<pre><code>  -h, --help   help for airgap\n</code></pre>"},{"location":"cli/k0s_airgap/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> <li>k0s airgap bundle-artifacts  - Bundles artifacts needed for airgapped installations into a tarball</li> <li>k0s airgap list-images    - List image names and versions needed for airgapped installations</li> </ul>"},{"location":"cli/k0s_airgap_bundle-artifacts/","title":"K0s airgap bundle artifacts","text":""},{"location":"cli/k0s_airgap_bundle-artifacts/#k0s-airgap-bundle-artifacts","title":"k0s airgap bundle-artifacts","text":"<p>Bundles artifacts needed for airgapped installations into a tarball</p>"},{"location":"cli/k0s_airgap_bundle-artifacts/#synopsis","title":"Synopsis","text":"<p>Bundles artifacts needed for airgapped installations into a tarball. Fetches the artifacts from their OCI registries and bundles them into an OCI Image Layout archive (written to standard output by default). Reads names from standard input if no names are given on the command line.</p> <pre><code>k0s airgap bundle-artifacts [flags] [names...]\n</code></pre>"},{"location":"cli/k0s_airgap_bundle-artifacts/#options","title":"Options","text":"<pre><code>  -d, --debug                           Debug logging (implies verbose logging)\n      --debugListenOn string            Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                            help for bundle-artifacts\n      --insecure-registries string      one of no, skip-tls-verify or plain-http (default \"no\")\n  -o, --output string                   output file path (writes to standard output if omitted)\n      --platform string                 the platform to export (default \"linux/amd64\")\n      --registries-config stringArray   paths to the authentication files for OCI registries (uses the standard Docker config if omitted)\n  -v, --verbose                         Verbose logging\n</code></pre>"},{"location":"cli/k0s_airgap_bundle-artifacts/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s airgap    - Tooling for airgapped installations</li> </ul>"},{"location":"cli/k0s_airgap_list-images/","title":"K0s airgap list images","text":""},{"location":"cli/k0s_airgap_list-images/#k0s-airgap-list-images","title":"k0s airgap list-images","text":"<p>List image names and versions needed for airgapped installations</p> <pre><code>k0s airgap list-images [flags]\n</code></pre>"},{"location":"cli/k0s_airgap_list-images/#examples","title":"Examples","text":"<pre><code>k0s airgap list-images\n</code></pre>"},{"location":"cli/k0s_airgap_list-images/#options","title":"Options","text":"<pre><code>      --all                    include all images, even if they are not used in the current configuration\n  -c, --config string          config file, use '-' to read the config from stdin (default \"/etc/k0s/k0s.yaml\")\n      --data-dir string        Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for list-images\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_airgap_list-images/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s airgap    - Tooling for airgapped installations</li> </ul>"},{"location":"cli/k0s_api/","title":"K0s api","text":""},{"location":"cli/k0s_api/#k0s-api","title":"k0s api","text":"<p>Run the controller API</p>"},{"location":"cli/k0s_api/#synopsis","title":"Synopsis","text":"<p>Run the controller API. Reads the runtime configuration from standard input.</p> <pre><code>k0s api [flags]\n</code></pre>"},{"location":"cli/k0s_api/#options","title":"Options","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for api\n  -v, --verbose                Verbose logging (default true)\n</code></pre>"},{"location":"cli/k0s_api/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_backup/","title":"K0s backup","text":""},{"location":"cli/k0s_backup/#k0s-backup","title":"k0s backup","text":"<p>Back-Up k0s configuration. Must be run as root (or with sudo)</p> <pre><code>k0s backup [flags]\n</code></pre>"},{"location":"cli/k0s_backup/#options","title":"Options","text":"<pre><code>      --data-dir string        Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for backup\n      --save-path string       destination directory path for backup assets, use '-' for stdout\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_backup/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_completion/","title":"K0s completion","text":""},{"location":"cli/k0s_completion/#k0s-completion","title":"k0s completion","text":"<p>Generate completion script</p>"},{"location":"cli/k0s_completion/#synopsis","title":"Synopsis","text":"<p>To load completions:</p> <p>Bash:</p> <p>$ source &lt;(k0s completion bash)</p>"},{"location":"cli/k0s_completion/#to-load-completions-for-each-session-execute-once","title":"To load completions for each session, execute once:","text":"<p>$ k0s completion bash &gt; /etc/bash_completion.d/k0s</p> <p>Zsh:</p>"},{"location":"cli/k0s_completion/#if-shell-completion-is-not-already-enabled-in-your-environment-you-will-need","title":"If shell completion is not already enabled in your environment you will need","text":""},{"location":"cli/k0s_completion/#to-enable-it-you-can-execute-the-following-once","title":"to enable it.  You can execute the following once:","text":"<p>$ echo \"autoload -U compinit; compinit\" &gt;&gt; ~/.zshrc</p>"},{"location":"cli/k0s_completion/#to-load-completions-for-each-session-execute-once_1","title":"To load completions for each session, execute once:","text":"<p>$ k0s completion zsh &gt; \"${fpath[1]}/_k0s\"</p>"},{"location":"cli/k0s_completion/#you-will-need-to-start-a-new-shell-for-this-setup-to-take-effect","title":"You will need to start a new shell for this setup to take effect.","text":"<p>Fish:</p> <p>$ k0s completion fish | source</p>"},{"location":"cli/k0s_completion/#to-load-completions-for-each-session-execute-once_2","title":"To load completions for each session, execute once:","text":"<p>$ k0s completion fish &gt; ~/.config/fish/completions/k0s.fish</p> <pre><code>k0s completion {bash|zsh|fish|powershell}\n</code></pre>"},{"location":"cli/k0s_completion/#options","title":"Options","text":"<pre><code>  -h, --help   help for completion\n</code></pre>"},{"location":"cli/k0s_completion/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_config/","title":"K0s config","text":""},{"location":"cli/k0s_config/#k0s-config","title":"k0s config","text":"<p>Configuration related sub-commands</p> <pre><code>k0s config [flags]\n</code></pre>"},{"location":"cli/k0s_config/#options","title":"Options","text":"<pre><code>  -h, --help   help for config\n</code></pre>"},{"location":"cli/k0s_config/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> <li>k0s config create  - Output the default k0s configuration yaml to stdout</li> <li>k0s config edit  - Launch the editor configured in your shell to edit k0s configuration</li> <li>k0s config status  - Display dynamic configuration reconciliation status</li> <li>k0s config validate  - Validate k0s configuration</li> </ul>"},{"location":"cli/k0s_config_create/","title":"K0s config create","text":""},{"location":"cli/k0s_config_create/#k0s-config-create","title":"k0s config create","text":"<p>Output the default k0s configuration yaml to stdout</p> <pre><code>k0s config create [flags]\n</code></pre>"},{"location":"cli/k0s_config_create/#options","title":"Options","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for create\n      --include-images         include the default images in the output\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_config_create/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s config    - Configuration related sub-commands</li> </ul>"},{"location":"cli/k0s_config_edit/","title":"K0s config edit","text":""},{"location":"cli/k0s_config_edit/#k0s-config-edit","title":"k0s config edit","text":"<p>Launch the editor configured in your shell to edit k0s configuration</p> <pre><code>k0s config edit [flags]\n</code></pre>"},{"location":"cli/k0s_config_edit/#options","title":"Options","text":"<pre><code>      --data-dir string   Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -h, --help              help for edit\n</code></pre>"},{"location":"cli/k0s_config_edit/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s config    - Configuration related sub-commands</li> </ul>"},{"location":"cli/k0s_config_status/","title":"K0s config status","text":""},{"location":"cli/k0s_config_status/#k0s-config-status","title":"k0s config status","text":"<p>Display dynamic configuration reconciliation status</p> <pre><code>k0s config status [flags]\n</code></pre>"},{"location":"cli/k0s_config_status/#options","title":"Options","text":"<pre><code>      --data-dir string   Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -h, --help              help for status\n  -o, --output string     Output format. Must be one of yaml|json\n</code></pre>"},{"location":"cli/k0s_config_status/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s config    - Configuration related sub-commands</li> </ul>"},{"location":"cli/k0s_config_validate/","title":"K0s config validate","text":""},{"location":"cli/k0s_config_validate/#k0s-config-validate","title":"k0s config validate","text":"<p>Validate k0s configuration</p>"},{"location":"cli/k0s_config_validate/#synopsis","title":"Synopsis","text":"<p>Example:    k0s config validate --config path_to_config.yaml</p> <pre><code>k0s config validate [flags]\n</code></pre>"},{"location":"cli/k0s_config_validate/#options","title":"Options","text":"<pre><code>  -c, --config string          config file, use '-' to read the config from stdin (default \"/etc/k0s/k0s.yaml\")\n  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for validate\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_config_validate/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s config    - Configuration related sub-commands</li> </ul>"},{"location":"cli/k0s_controller/","title":"K0s controller","text":""},{"location":"cli/k0s_controller/#k0s-controller","title":"k0s controller","text":"<p>Run controller</p> <pre><code>k0s controller [join-token] [flags]\n</code></pre>"},{"location":"cli/k0s_controller/#examples","title":"Examples","text":"<pre><code>    Command to associate master nodes:\n    CLI argument:\n    $ k0s controller [join-token]\n\n    or CLI flag:\n    $ k0s controller --token-file [path_to_file]\n    Note: Token can be passed either as a CLI argument or as a flag\n</code></pre>"},{"location":"cli/k0s_controller/#options","title":"Options","text":"<pre><code>  -c, --config string                                  config file, use '-' to read the config from stdin (default \"/etc/k0s/k0s.yaml\")\n      --cri-socket string                              container runtime socket to use, default to internal containerd. Format: [remote|docker]:[path-to-socket]\n      --data-dir string                                Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -d, --debug                                          Debug logging (implies verbose logging)\n      --debugListenOn string                           Http listenOn for Debug pprof handler (default \":6060\")\n      --disable-components strings                     disable components (valid items: applier-manager,autopilot,control-api,coredns,csr-approver,endpoint-reconciler,helm,konnectivity-server,kube-controller-manager,kube-proxy,kube-scheduler,metrics-server,network-provider,node-role,system-rbac,windows-node,worker-config)\n      --enable-cloud-provider                          Whether or not to enable cloud provider support in kubelet\n      --enable-dynamic-config                          enable cluster-wide dynamic config based on custom resource\n      --enable-k0s-cloud-provider                      enables the k0s-cloud-provider (default false)\n      --enable-metrics-scraper                         enable scraping metrics from the controller components (kube-scheduler, kube-controller-manager)\n      --enable-worker                                  enable worker (default false)\n  -h, --help                                           help for controller\n      --ignore-pre-flight-checks                       continue even if pre-flight checks fail\n      --init-only                                      only initialize controller and exit\n      --iptables-mode string                           iptables mode (valid values: nft, legacy, auto). default: auto\n      --k0s-cloud-provider-port int                    the port that k0s-cloud-provider binds on (default 10258)\n      --k0s-cloud-provider-update-frequency duration   the frequency of k0s-cloud-provider node updates (default 2m0s)\n      --kube-controller-manager-extra-args string      extra args for kube-controller-manager\n      --kubelet-extra-args string                      extra args for kubelet\n      --kubelet-root-dir string                        Kubelet root directory for k0s\n      --labels strings                                 Node labels, list of key=value pairs\n  -l, --logging stringToString                         Logging Levels for the different components (default [containerd=info,etcd=info,konnectivity-server=1,kube-apiserver=1,kube-controller-manager=1,kube-scheduler=1,kubelet=1])\n      --no-taints                                      disable default taints for controller node\n      --profile string                                 worker profile to use on the node (default \"default\")\n      --single                                         enable single node (implies --enable-worker, default false)\n      --status-socket string                           Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n      --taints strings                                 Node taints, list of key=value:effect strings\n      --token-file string                              Path to the file containing join-token.\n  -v, --verbose                                        Verbose logging (default true)\n</code></pre>"},{"location":"cli/k0s_controller/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_ctr/","title":"K0s ctr","text":""},{"location":"cli/k0s_ctr/#k0s-ctr","title":"k0s ctr","text":"<p>containerd CLI</p>"},{"location":"cli/k0s_ctr/#synopsis","title":"Synopsis","text":"<p>ctr is an unsupported debug and administrative client for interacting with the containerd daemon. Because it is unsupported, the commands, options, and operations are not guaranteed to be backward compatible or stable from release to release of the containerd project.</p> <pre><code>k0s ctr [flags]\n</code></pre>"},{"location":"cli/k0s_ctr/#options","title":"Options","text":"<pre><code>  -h, --help   help for ctr\n</code></pre>"},{"location":"cli/k0s_ctr/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_docs/","title":"K0s docs","text":""},{"location":"cli/k0s_docs/#k0s-docs","title":"k0s docs","text":"<p>Generate k0s command documentation</p> <pre><code>k0s docs {markdown|man} [flags]\n</code></pre>"},{"location":"cli/k0s_docs/#options","title":"Options","text":"<pre><code>  -h, --help   help for docs\n</code></pre>"},{"location":"cli/k0s_docs/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_etcd/","title":"K0s etcd","text":""},{"location":"cli/k0s_etcd/#k0s-etcd","title":"k0s etcd","text":"<p>Manage etcd cluster</p> <pre><code>k0s etcd [flags]\n</code></pre>"},{"location":"cli/k0s_etcd/#options","title":"Options","text":"<pre><code>      --data-dir string        Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for etcd\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_etcd/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> <li>k0s etcd leave    - Leave the etcd cluster, or remove a specific peer</li> <li>k0s etcd member-list    - List etcd cluster members (JSON encoded)</li> </ul>"},{"location":"cli/k0s_etcd_leave/","title":"K0s etcd leave","text":""},{"location":"cli/k0s_etcd_leave/#k0s-etcd-leave","title":"k0s etcd leave","text":"<p>Leave the etcd cluster, or remove a specific peer</p> <pre><code>k0s etcd leave [flags]\n</code></pre>"},{"location":"cli/k0s_etcd_leave/#options","title":"Options","text":"<pre><code>      --data-dir string               Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -h, --help                          help for leave\n      --peer-address ip-or-dns-name   etcd peer address to remove (default &lt;this node's peer address&gt;)\n      --status-socket string          Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n</code></pre>"},{"location":"cli/k0s_etcd_leave/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_etcd_leave/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s etcd    - Manage etcd cluster</li> </ul>"},{"location":"cli/k0s_etcd_member-list/","title":"K0s etcd member list","text":""},{"location":"cli/k0s_etcd_member-list/#k0s-etcd-member-list","title":"k0s etcd member-list","text":"<p>List etcd cluster members (JSON encoded)</p> <pre><code>k0s etcd member-list [flags]\n</code></pre>"},{"location":"cli/k0s_etcd_member-list/#options","title":"Options","text":"<pre><code>      --data-dir string        Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -h, --help                   help for member-list\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n</code></pre>"},{"location":"cli/k0s_etcd_member-list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_etcd_member-list/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s etcd    - Manage etcd cluster</li> </ul>"},{"location":"cli/k0s_install/","title":"K0s install","text":""},{"location":"cli/k0s_install/#k0s-install","title":"k0s install","text":"<p>Install k0s on a brand-new system. Must be run as root (or with sudo)</p> <pre><code>k0s install [flags]\n</code></pre>"},{"location":"cli/k0s_install/#options","title":"Options","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -e, --env stringArray        set environment variable\n      --force                  force init script creation\n  -h, --help                   help for install\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_install/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> <li>k0s install controller    - Install k0s controller on a brand-new system. Must be run as root (or with sudo)</li> <li>k0s install worker    - Install k0s worker on a brand-new system. Must be run as root (or with sudo)</li> </ul>"},{"location":"cli/k0s_install_controller/","title":"K0s install controller","text":""},{"location":"cli/k0s_install_controller/#k0s-install-controller","title":"k0s install controller","text":"<p>Install k0s controller on a brand-new system. Must be run as root (or with sudo)</p> <pre><code>k0s install controller [flags]\n</code></pre>"},{"location":"cli/k0s_install_controller/#examples","title":"Examples","text":"<pre><code>All default values of controller command will be passed to the service stub unless overridden.\n\nWith the controller subcommand you can setup a single node cluster by running:\n\n    k0s install controller --single\n</code></pre>"},{"location":"cli/k0s_install_controller/#options","title":"Options","text":"<pre><code>  -c, --config string                                  config file, use '-' to read the config from stdin (default \"/etc/k0s/k0s.yaml\")\n      --cri-socket string                              container runtime socket to use, default to internal containerd. Format: [remote|docker]:[path-to-socket]\n      --data-dir string                                Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n      --disable-components strings                     disable components (valid items: applier-manager,autopilot,control-api,coredns,csr-approver,endpoint-reconciler,helm,konnectivity-server,kube-controller-manager,kube-proxy,kube-scheduler,metrics-server,network-provider,node-role,system-rbac,windows-node,worker-config)\n      --enable-cloud-provider                          Whether or not to enable cloud provider support in kubelet\n      --enable-dynamic-config                          enable cluster-wide dynamic config based on custom resource\n      --enable-k0s-cloud-provider                      enables the k0s-cloud-provider (default false)\n      --enable-metrics-scraper                         enable scraping metrics from the controller components (kube-scheduler, kube-controller-manager)\n      --enable-worker                                  enable worker (default false)\n  -h, --help                                           help for controller\n      --init-only                                      only initialize controller and exit\n      --iptables-mode string                           iptables mode (valid values: nft, legacy, auto). default: auto\n      --k0s-cloud-provider-port int                    the port that k0s-cloud-provider binds on (default 10258)\n      --k0s-cloud-provider-update-frequency duration   the frequency of k0s-cloud-provider node updates (default 2m0s)\n      --kube-controller-manager-extra-args string      extra args for kube-controller-manager\n      --kubelet-extra-args string                      extra args for kubelet\n      --kubelet-root-dir string                        Kubelet root directory for k0s\n      --labels strings                                 Node labels, list of key=value pairs\n  -l, --logging stringToString                         Logging Levels for the different components (default [containerd=info,etcd=info,konnectivity-server=1,kube-apiserver=1,kube-controller-manager=1,kube-scheduler=1,kubelet=1])\n      --no-taints                                      disable default taints for controller node\n      --profile string                                 worker profile to use on the node (default \"default\")\n      --single                                         enable single node (implies --enable-worker, default false)\n      --status-socket string                           Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n      --taints strings                                 Node taints, list of key=value:effect strings\n      --token-file string                              Path to the file containing join-token.\n</code></pre>"},{"location":"cli/k0s_install_controller/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -e, --env stringArray        set environment variable\n      --force                  force init script creation\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_install_controller/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s install  - Install k0s on a brand-new system. Must be run as root (or with sudo)</li> </ul>"},{"location":"cli/k0s_install_worker/","title":"K0s install worker","text":""},{"location":"cli/k0s_install_worker/#k0s-install-worker","title":"k0s install worker","text":"<p>Install k0s worker on a brand-new system. Must be run as root (or with sudo)</p> <pre><code>k0s install worker [flags]\n</code></pre>"},{"location":"cli/k0s_install_worker/#examples","title":"Examples","text":"<pre><code>Worker subcommand allows you to pass in all available worker parameters.\nAll default values of worker command will be passed to the service stub unless overridden.\n</code></pre>"},{"location":"cli/k0s_install_worker/#options","title":"Options","text":"<pre><code>      --cri-socket string           container runtime socket to use, default to internal containerd. Format: [remote|docker]:[path-to-socket]\n      --data-dir string             Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n      --enable-cloud-provider       Whether or not to enable cloud provider support in kubelet\n  -h, --help                        help for worker\n      --iptables-mode string        iptables mode (valid values: nft, legacy, auto). default: auto\n      --kubelet-extra-args string   extra args for kubelet\n      --kubelet-root-dir string     Kubelet root directory for k0s\n      --labels strings              Node labels, list of key=value pairs\n  -l, --logging stringToString      Logging Levels for the different components (default [containerd=info,etcd=info,konnectivity-server=1,kube-apiserver=1,kube-controller-manager=1,kube-scheduler=1,kubelet=1])\n      --profile string              worker profile to use on the node (default \"default\")\n      --status-socket string        Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n      --taints strings              Node taints, list of key=value:effect strings\n      --token-file string           Path to the file containing join-token.\n</code></pre>"},{"location":"cli/k0s_install_worker/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -e, --env stringArray        set environment variable\n      --force                  force init script creation\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_install_worker/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s install  - Install k0s on a brand-new system. Must be run as root (or with sudo)</li> </ul>"},{"location":"cli/k0s_kubeconfig/","title":"K0s kubeconfig","text":""},{"location":"cli/k0s_kubeconfig/#k0s-kubeconfig","title":"k0s kubeconfig","text":"<p>Create a kubeconfig file for a specified user</p> <pre><code>k0s kubeconfig [command] [flags]\n</code></pre>"},{"location":"cli/k0s_kubeconfig/#options","title":"Options","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for kubeconfig\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_kubeconfig/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> <li>k0s kubeconfig admin    - Display Admin's Kubeconfig file</li> <li>k0s kubeconfig create  - Create a kubeconfig for a user</li> </ul>"},{"location":"cli/k0s_kubeconfig_admin/","title":"K0s kubeconfig admin","text":""},{"location":"cli/k0s_kubeconfig_admin/#k0s-kubeconfig-admin","title":"k0s kubeconfig admin","text":"<p>Display Admin's Kubeconfig file</p>"},{"location":"cli/k0s_kubeconfig_admin/#synopsis","title":"Synopsis","text":"<p>Print kubeconfig for the Admin user to stdout</p> <pre><code>k0s kubeconfig admin [flags]\n</code></pre>"},{"location":"cli/k0s_kubeconfig_admin/#examples","title":"Examples","text":"<pre><code>    $ k0s kubeconfig admin &gt; ~/.kube/config\n    $ export KUBECONFIG=~/.kube/config\n    $ kubectl get nodes\n</code></pre>"},{"location":"cli/k0s_kubeconfig_admin/#options","title":"Options","text":"<pre><code>      --data-dir string        Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -h, --help                   help for admin\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n</code></pre>"},{"location":"cli/k0s_kubeconfig_admin/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_kubeconfig_admin/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s kubeconfig    - Create a kubeconfig file for a specified user</li> </ul>"},{"location":"cli/k0s_kubeconfig_create/","title":"K0s kubeconfig create","text":""},{"location":"cli/k0s_kubeconfig_create/#k0s-kubeconfig-create","title":"k0s kubeconfig create","text":"<p>Create a kubeconfig for a user</p>"},{"location":"cli/k0s_kubeconfig_create/#synopsis","title":"Synopsis","text":"<p>Create a kubeconfig with a signed certificate and public key for a given user (and optionally user groups) Note: A certificate once signed cannot be revoked for a particular user</p> <pre><code>k0s kubeconfig create username [flags]\n</code></pre>"},{"location":"cli/k0s_kubeconfig_create/#examples","title":"Examples","text":"<pre><code>    Command to create a kubeconfig for a user:\n    CLI argument:\n    $ k0s kubeconfig create username\n\n    optionally add groups:\n    $ k0s kubeconfig create username --groups [groups]\n\n    customize the expiration duration of the certificate:\n    $ k0s kubeconfig create username --certificate-expires-after 8760h\n</code></pre>"},{"location":"cli/k0s_kubeconfig_create/#options","title":"Options","text":"<pre><code>      --certificate-expires-after duration   The expiration duration of the certificate (default 8760h0m0s)\n  -c, --config string                        config file, use '-' to read the config from stdin (default \"/etc/k0s/k0s.yaml\")\n      --data-dir string                      Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n      --groups string                        Specify groups\n  -h, --help                                 help for create\n      --status-socket string                 Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n</code></pre>"},{"location":"cli/k0s_kubeconfig_create/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_kubeconfig_create/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s kubeconfig    - Create a kubeconfig file for a specified user</li> </ul>"},{"location":"cli/k0s_kubectl/","title":"K0s kubectl","text":""},{"location":"cli/k0s_kubectl/#k0s-kubectl","title":"k0s kubectl","text":"<p>kubectl controls the Kubernetes cluster manager</p>"},{"location":"cli/k0s_kubectl/#synopsis","title":"Synopsis","text":"<p>kubectl controls the Kubernetes cluster manager.</p> <p>Find more information at: https://kubernetes.io/docs/reference/kubectl/</p> <pre><code>k0s kubectl [flags]\n</code></pre>"},{"location":"cli/k0s_kubectl/#options","title":"Options","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"/home/runner/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --data-dir string                Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n      --debug                          Debug logging [$DEBUG]\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n  -h, --help                           help for kubectl\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --log-flush-frequency duration   Maximum number of seconds between log flushes (default 5s)\n      --match-server-version           Require server version to match client version\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --password string                Password for basic authentication to the API server\n      --profile string                 Name of profile to capture. One of (none|cpu|heap|goroutine|threadcreate|block|mutex) (default \"none\")\n      --profile-output string          Name of the file to write the profile to (default \"profile.pprof\")\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n      --username string                Username for basic authentication to the API server\n  -v, --v Level                        number for the log level verbosity\n      --vmodule moduleSpec             comma-separated list of pattern=N settings for file-filtered logging (only works for the default text log format)\n      --warnings-as-errors             Treat warnings received from the server as errors and exit with a non-zero exit code\n</code></pre>"},{"location":"cli/k0s_kubectl/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_reset/","title":"K0s reset","text":""},{"location":"cli/k0s_reset/#k0s-reset","title":"k0s reset","text":"<p>Uninstall k0s. Must be run as root (or with sudo)</p> <pre><code>k0s reset [flags]\n</code></pre>"},{"location":"cli/k0s_reset/#options","title":"Options","text":"<pre><code>  -c, --config string             config file, use '-' to read the config from stdin (default \"/etc/k0s/k0s.yaml\")\n      --cri-socket string         container runtime socket to use, default to internal containerd. Format: [remote|docker]:[path-to-socket]\n      --data-dir string           Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -d, --debug                     Debug logging (implies verbose logging)\n      --debugListenOn string      Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                      help for reset\n      --kubelet-root-dir string   Kubelet root directory for k0s\n      --status-socket string      Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n  -v, --verbose                   Verbose logging\n</code></pre>"},{"location":"cli/k0s_reset/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_restore/","title":"K0s restore","text":""},{"location":"cli/k0s_restore/#k0s-restore","title":"k0s restore","text":"<p>restore k0s state from given backup archive. Use '-' as filename to read from stdin. Must be run as root (or with sudo)</p> <pre><code>k0s restore filename [flags]\n</code></pre>"},{"location":"cli/k0s_restore/#options","title":"Options","text":"<pre><code>      --config-out string      Specify desired name and full path for the restored k0s.yaml file (default: k0s_&lt;archive timestamp&gt;.yaml\n      --data-dir string        Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for restore\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_restore/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_start/","title":"K0s start","text":""},{"location":"cli/k0s_start/#k0s-start","title":"k0s start","text":"<p>Start the k0s service configured on this host. Must be run as root (or with sudo)</p> <pre><code>k0s start [flags]\n</code></pre>"},{"location":"cli/k0s_start/#options","title":"Options","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for start\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_start/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_status/","title":"K0s status","text":""},{"location":"cli/k0s_status/#k0s-status","title":"k0s status","text":"<p>Get k0s instance status information</p> <pre><code>k0s status [flags]\n</code></pre>"},{"location":"cli/k0s_status/#examples","title":"Examples","text":"<pre><code>The command will return information about system init, PID, k0s role, kubeconfig and similar.\n</code></pre>"},{"location":"cli/k0s_status/#options","title":"Options","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for status\n  -o, --out string             sets type of output to json or yaml\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_status/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> <li>k0s status components  - Get k0s instance component status information</li> </ul>"},{"location":"cli/k0s_status_components/","title":"K0s status components","text":""},{"location":"cli/k0s_status_components/#k0s-status-components","title":"k0s status components","text":"<p>Get k0s instance component status information</p> <pre><code>k0s status components [flags]\n</code></pre>"},{"location":"cli/k0s_status_components/#examples","title":"Examples","text":"<pre><code>The command will return information about k0s components.\n</code></pre>"},{"location":"cli/k0s_status_components/#options","title":"Options","text":"<pre><code>  -h, --help            help for components\n      --max-count int   how many latest probes to show (default 1)\n</code></pre>"},{"location":"cli/k0s_status_components/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_status_components/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s status    - Get k0s instance status information</li> </ul>"},{"location":"cli/k0s_stop/","title":"K0s stop","text":""},{"location":"cli/k0s_stop/#k0s-stop","title":"k0s stop","text":"<p>Stop the k0s service configured on this host. Must be run as root (or with sudo)</p> <pre><code>k0s stop [flags]\n</code></pre>"},{"location":"cli/k0s_stop/#options","title":"Options","text":"<pre><code>  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for stop\n  -v, --verbose                Verbose logging\n</code></pre>"},{"location":"cli/k0s_stop/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_sysinfo/","title":"K0s sysinfo","text":""},{"location":"cli/k0s_sysinfo/#k0s-sysinfo","title":"k0s sysinfo","text":"<p>Display system information</p>"},{"location":"cli/k0s_sysinfo/#synopsis","title":"Synopsis","text":"<p>Runs k0s's pre-flight checks and issues the results to stdout.</p> <pre><code>k0s sysinfo [flags]\n</code></pre>"},{"location":"cli/k0s_sysinfo/#options","title":"Options","text":"<pre><code>      --controller             Include controller-specific sysinfo (default true)\n      --data-dir string        Data Directory for k0s (default \"/var/lib/k0s\")\n  -d, --debug                  Debug logging (implies verbose logging)\n      --debugListenOn string   Http listenOn for Debug pprof handler (default \":6060\")\n  -h, --help                   help for sysinfo\n  -o, --output string          Output format (valid values: text, json, yaml) (default \"text\")\n  -v, --verbose                Verbose logging\n      --worker                 Include worker-specific sysinfo (default true)\n</code></pre>"},{"location":"cli/k0s_sysinfo/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_token/","title":"K0s token","text":""},{"location":"cli/k0s_token/#k0s-token","title":"k0s token","text":"<p>Manage join tokens</p> <pre><code>k0s token [flags]\n</code></pre>"},{"location":"cli/k0s_token/#options","title":"Options","text":"<pre><code>  -h, --help   help for token\n</code></pre>"},{"location":"cli/k0s_token/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> <li>k0s token create    - Create join token</li> <li>k0s token invalidate    - Invalidates existing join token</li> <li>k0s token list    - List join tokens</li> <li>k0s token pre-shared    - Generates token and secret and stores them as a files</li> </ul>"},{"location":"cli/k0s_token_create/","title":"K0s token create","text":""},{"location":"cli/k0s_token_create/#k0s-token-create","title":"k0s token create","text":"<p>Create join token</p> <pre><code>k0s token create [flags]\n</code></pre>"},{"location":"cli/k0s_token_create/#examples","title":"Examples","text":"<pre><code>k0s token create --role worker --expiry 100h //sets expiration time to 100 hours\nk0s token create --role worker --expiry 10m  //sets expiration time to 10 minutes\n</code></pre>"},{"location":"cli/k0s_token_create/#options","title":"Options","text":"<pre><code>      --data-dir string        Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n      --expiry string          Expiration time of the token. Format 1.5h, 2h45m or 300ms. (default \"0s\")\n  -h, --help                   help for create\n      --role string            Either worker or controller (default \"worker\")\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n      --wait                   wait forever (default false)\n</code></pre>"},{"location":"cli/k0s_token_create/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s token  - Manage join tokens</li> </ul>"},{"location":"cli/k0s_token_invalidate/","title":"K0s token invalidate","text":""},{"location":"cli/k0s_token_invalidate/#k0s-token-invalidate","title":"k0s token invalidate","text":"<p>Invalidates existing join token</p> <pre><code>k0s token invalidate join-token... [flags]\n</code></pre>"},{"location":"cli/k0s_token_invalidate/#examples","title":"Examples","text":"<pre><code>k0s token invalidate xyz123\n</code></pre>"},{"location":"cli/k0s_token_invalidate/#options","title":"Options","text":"<pre><code>      --data-dir string        Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -h, --help                   help for invalidate\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n</code></pre>"},{"location":"cli/k0s_token_invalidate/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s token  - Manage join tokens</li> </ul>"},{"location":"cli/k0s_token_list/","title":"K0s token list","text":""},{"location":"cli/k0s_token_list/#k0s-token-list","title":"k0s token list","text":"<p>List join tokens</p> <pre><code>k0s token list [flags]\n</code></pre>"},{"location":"cli/k0s_token_list/#examples","title":"Examples","text":"<pre><code>k0s token list --role worker // list worker tokens\n</code></pre>"},{"location":"cli/k0s_token_list/#options","title":"Options","text":"<pre><code>      --data-dir string        Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -h, --help                   help for list\n      --role string            Either worker, controller or empty for all roles\n      --status-socket string   Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n</code></pre>"},{"location":"cli/k0s_token_list/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s token  - Manage join tokens</li> </ul>"},{"location":"cli/k0s_token_pre-shared/","title":"K0s token pre shared","text":""},{"location":"cli/k0s_token_pre-shared/#k0s-token-pre-shared","title":"k0s token pre-shared","text":"<p>Generates token and secret and stores them as a files</p> <pre><code>k0s token pre-shared [flags]\n</code></pre>"},{"location":"cli/k0s_token_pre-shared/#examples","title":"Examples","text":"<pre><code>k0s token pre-shared --role worker --cert &lt;path&gt;/&lt;to&gt;/ca.crt --url https://&lt;controller-ip&gt;:&lt;port&gt;/\n</code></pre>"},{"location":"cli/k0s_token_pre-shared/#options","title":"Options","text":"<pre><code>      --cert string      path to the CA certificate file\n  -h, --help             help for pre-shared\n      --out string       path to the output directory. Default: current dir (default \".\")\n      --role string      token role. valid values: worker, controller. Default: worker (default \"worker\")\n      --url string       url of the api server to join\n      --valid duration   how long token is valid, in Go duration format\n</code></pre>"},{"location":"cli/k0s_token_pre-shared/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s token  - Manage join tokens</li> </ul>"},{"location":"cli/k0s_version/","title":"K0s version","text":""},{"location":"cli/k0s_version/#k0s-version","title":"k0s version","text":"<p>Print the k0s version</p> <pre><code>k0s version [flags]\n</code></pre>"},{"location":"cli/k0s_version/#options","title":"Options","text":"<pre><code>  -a, --all    use to print all k0s version info\n  -h, --help   help for version\n  -j, --json   use to print all k0s version info in json\n</code></pre>"},{"location":"cli/k0s_version/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"cli/k0s_worker/","title":"K0s worker","text":""},{"location":"cli/k0s_worker/#k0s-worker","title":"k0s worker","text":"<p>Run worker</p> <pre><code>k0s worker [join-token] [flags]\n</code></pre>"},{"location":"cli/k0s_worker/#examples","title":"Examples","text":"<pre><code>    Command to add worker node to the master node:\n    CLI argument:\n    $ k0s worker [token]\n\n    or CLI flag:\n    $ k0s worker --token-file [path_to_file]\n    Note: Token can be passed either as a CLI argument or as a flag\n</code></pre>"},{"location":"cli/k0s_worker/#options","title":"Options","text":"<pre><code>      --cri-socket string           container runtime socket to use, default to internal containerd. Format: [remote|docker]:[path-to-socket]\n      --data-dir string             Data Directory for k0s. DO NOT CHANGE for an existing setup, things will break! (default \"/var/lib/k0s\")\n  -d, --debug                       Debug logging (implies verbose logging)\n      --debugListenOn string        Http listenOn for Debug pprof handler (default \":6060\")\n      --enable-cloud-provider       Whether or not to enable cloud provider support in kubelet\n  -h, --help                        help for worker\n      --ignore-pre-flight-checks    continue even if pre-flight checks fail\n      --iptables-mode string        iptables mode (valid values: nft, legacy, auto). default: auto\n      --kubelet-extra-args string   extra args for kubelet\n      --kubelet-root-dir string     Kubelet root directory for k0s\n      --labels strings              Node labels, list of key=value pairs\n  -l, --logging stringToString      Logging Levels for the different components (default [containerd=info,etcd=info,konnectivity-server=1,kube-apiserver=1,kube-controller-manager=1,kube-scheduler=1,kubelet=1])\n      --profile string              worker profile to use on the node (default \"default\")\n      --status-socket string        Full file path to the socket file. (default: &lt;rundir&gt;/status.sock)\n      --taints strings              Node taints, list of key=value:effect strings\n      --token-file string           Path to the file containing join-token.\n  -v, --verbose                     Verbose logging (default true)\n</code></pre>"},{"location":"cli/k0s_worker/#see-also","title":"SEE ALSO","text":"<ul> <li>k0s  - k0s - Zero Friction Kubernetes</li> </ul>"},{"location":"contributors/","title":"Getting Started","text":""},{"location":"contributors/#getting-started","title":"Getting Started","text":"<p>Thank you for taking the time to make a contribution to k0s. The following document is a set of guidelines and instructions for contributing to k0s.</p> <p>When contributing to this repository, please consider first discussing the change you wish to make by opening an issue.</p>"},{"location":"contributors/#code-of-conduct","title":"Code of Conduct","text":"<p>Our code of conduct can be found in the link below. Please follow it in all your interactions with the project.</p> <ul> <li>Code of Conduct</li> </ul>"},{"location":"contributors/#github-workflow","title":"GitHub Workflow","text":"<p>We use GitHub flow, so all code changes are tracked via Pull Requests. A detailed guide on the recommended workflow can be found below:</p> <ul> <li>GitHub Workflow</li> </ul>"},{"location":"contributors/#code-testing","title":"Code Testing","text":"<p>All submitted PRs go through a set of tests and reviews. You can run most of these tests before a PR is submitted. In fact, we recommend it, because it will save on many possible review iterations and automated tests. The testing guidelines can be found here:</p> <ul> <li>Contributor's Guide to Testing</li> </ul>"},{"location":"contributors/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed as followed:</p> <ul> <li>All content residing under the \"docs/\" directory of this repository is licensed under \"Creative Commons Attribution Share Alike 4.0 International\" (CC-BY-SA-4.0). See docs/LICENSE for details.</li> <li>Content outside of the above mentioned directories or restrictions above is available under the \"Apache License 2.0\".</li> </ul>"},{"location":"contributors/#community","title":"Community","text":"<p>Some of you may have noticed that we have a community blog. If you're not following us  yet, we invite you to do so now! Make sure to follow us on X as well \ud83d\ude0a</p> <p>The main community communication channel is on Kubernetes Slack. There you'll find like-minded people and reach out for assistance and discussions.</p>"},{"location":"contributors/CODE_OF_CONDUCT/","title":"K0s Community Code of Conduct","text":"<p>K0s follows the CNCF Code of Conduct.</p>"},{"location":"contributors/docs/","title":"Documentation","text":""},{"location":"contributors/docs/#contributing-to-the-k0s-documentation","title":"Contributing to the k0s documentation","text":"<p>We use mkdocs and mike for publishing docs to docs.k0sproject.io. This guide will provide a simple how-to on how to configure and deploy newly added docs to our website.</p>"},{"location":"contributors/docs/#requirements","title":"Requirements","text":"<p>Install mike: https://github.com/jimporter/mike#installation</p>"},{"location":"contributors/docs/#adding-a-new-link-to-the-navigation","title":"Adding A New link to the Navigation","text":"<ul> <li>All docs must live under the <code>docs</code> directory (I.E., changes to the main <code>README.md</code> are not reflected in the website).</li> <li>Add a new link under <code>nav</code> in the main mkdocs.yml file:</li> </ul> <pre><code># ... other directives\nnav:\n  - Overview: README.md\n  - Installation:\n      - Quick Start Guide: install.md\n      - Using k0sctl: k0sctl-install.md\n      - Alternative Methods:\n          - Manual (advanced): k0s-multi-node.md\n          - Docker: k0s-in-docker.md\n          - Windows (experimental): experimental-windows.md\n          - Raspberry Pi 4: raspberry-pi4.md\n          - Raspberry Pi 5: raspberry-pi5.md\n          - Ansible Playbook: examples/ansible-playbook.md\n          - Airgapped Installation: airgap-install.md\n          - Using custom CA certificate (advanced): custom-ca.md\n      - System Requirements: system-requirements.md\n      - External runtime dependencies: external-runtime-deps.md\n      - Verifying Signed Binaries: verifying-signs.md\n  # more navigation links ...\n</code></pre> <ul> <li>Once your changes are pushed to <code>main</code>, the \"Publish Docs\" job will start running: https://github.com/k0sproject/k0s/actions?query=workflow%3A%22Publish+docs+via+GitHub+Pages%22</li> <li>You should see the deployment outcome in the <code>gh-pages</code> deployment page: https://github.com/k0sproject/k0s/deployments/activity_log?environment=github-pages</li> </ul>"},{"location":"contributors/docs/#testing-docs-locally","title":"Testing docs locally","text":"<p>We've got a dockerized setup for easily testing docs locally. Simply run <code>make docs-serve-dev</code>. The docs will be available on http://localhost:8000.</p> <p>Note If you have something already running locally on port <code>8000</code> you can choose another port like so: <code>make docs-serve-dev DOCS_DEV_PORT=9999</code>. The docs will then be available on http://localhost:9999.</p>"},{"location":"contributors/github_workflow/","title":"GitHub Workflow","text":""},{"location":"contributors/github_workflow/#github-workflow","title":"GitHub Workflow","text":"<p>This guide assumes you have already cloned the upstream repo to your system via <code>git clone</code>, or via <code>go get github.com/k0sproject/k0s</code>.</p>"},{"location":"contributors/github_workflow/#fork-the-project","title":"Fork The Project","text":"<ol> <li>Go to http://github.com/k0sproject/k0s</li> <li>On the top, right-hand side, click on \"fork\" and select your username for the fork destination.</li> </ol>"},{"location":"contributors/github_workflow/#adding-the-forked-remote","title":"Adding the Forked Remote","text":"<pre><code>export GITHUB_USER={ your github username }\n</code></pre> <pre><code>cd $WORKDIR/k0s\ngit remote add $GITHUB_USER git@github.com:${GITHUB_USER}/k0s.git\n\n# Prevent push to Upstream\ngit remote set-url --push origin no_push\n\n# Set your fork remote as a default push target\ngit push --set-upstream $GITHUB_USER main\n</code></pre> <p>Your remotes should look something like this:</p> <pre><code>git remote -v\n</code></pre> <pre><code>origin  https://github.com/k0sproject/k0s (fetch)\norigin  no_push (push)\nmy_fork git@github.com:{ github_username }/k0s.git (fetch)\nmy_fork git@github.com:{ github_username }/k0s.git (push)\n</code></pre>"},{"location":"contributors/github_workflow/#create-rebase-your-feature-branch","title":"Create &amp; Rebase Your Feature Branch","text":"<p>Create a feature branch and switch to it:</p> <pre><code>git checkout -b my_feature_branch\n</code></pre> <p>Rebase your branch:</p> <pre><code>git fetch origin &amp;&amp; \\\n  git rebase origin/main\n</code></pre> <pre><code>Current branch my_feature_branch is up to date.\n</code></pre> <p>Please don't use <code>git pull</code> instead of the above <code>fetch</code> / <code>rebase</code>. <code>git pull</code> does a merge, which leaves merge commits. These make the commit history messy and violate the principle that commits ought to be individually understandable and useful.</p>"},{"location":"contributors/github_workflow/#commit-push","title":"Commit &amp; Push","text":"<p>Commit and sign your changes:</p> <pre><code>git commit --signoff\n</code></pre> <p>The commit message should have a short, capitalized title without trailing period as first line. After the title a blank line and then a longer description that explains why the change was made, unless it is obvious.</p> <p>Use imperative mood in the commit message.</p> <p>For example:</p> <pre><code>Summarize changes in around 50 characters or less\n\nMore detailed explanatory text, if necessary. Wrap it to about 72\ncharacters or so. In some contexts, the first line is treated as the\nsubject of the commit and the rest of the text as the body. The\nblank line separating the summary from the body is critical (unless\nyou omit the body entirely); various tools like `log`, `shortlog`\nand `rebase` can get confused if you run the two together.\n\nExplain the problem that this commit is solving. Focus on why you\nare making this change as opposed to how (the code explains that).\nAre there side effects or other unintuitive consequences of this\nchange? Here's the place to explain them.\n\nFurther paragraphs come after blank lines.\n\n - Bullet points are okay, too\n\n - Typically a hyphen or asterisk is used for the bullet, preceded\n   by a single space, with blank lines in between.\n\nIf you use an issue tracker, put references to them at the bottom,\nlike this:\n\nFixes: https://github.com/k0sproject/k0s/issues/373\nSee also: #456, #789\n\nSigned-off-by: Name Lastname &lt;user@example.com&gt;\n</code></pre> <p>You can go back and edit/build/test some more, then <code>commit --amend</code> in a few cycles.</p> <p>When ready, push your changes to your fork's repository:</p> <pre><code>git push --set-upstream my_fork my_feature_branch\n</code></pre>"},{"location":"contributors/github_workflow/#open-a-pull-request","title":"Open a Pull Request","text":"<p>See GitHub's docs on how to create a pull request from a fork.</p>"},{"location":"contributors/github_workflow/#get-a-code-review","title":"Get a code review","text":"<p>Once your pull request has been opened it will be assigned to one or more reviewers, and will go through a series of smoke tests.</p> <p>Commit changes made in response to review comments should be added to the same branch on your fork.</p> <p>Very small PRs are easy to review. Very large PRs are very difficult to review.</p>"},{"location":"contributors/github_workflow/#squashing-commits","title":"Squashing Commits","text":"<p>Commits on your branch should represent meaningful milestones or units of work. Small commits that contain typo fixes, rebases, review feedbacks, etc should be squashed.</p> <p>To do that, it's best to perform an interactive rebase:</p>"},{"location":"contributors/github_workflow/#example","title":"Example","text":"<p>Rebase your feature branch against upstream main branch:</p> <pre><code>git rebase -i origin/main\n</code></pre> <p>If your PR has 3 commits, output would be similar to this:</p> <pre><code>pick f7f3f6d Changed some code\npick 310154e fixed some typos\npick a5f4a0d made some review changes\n\n# Rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# Commands:\n# p, pick &lt;commit&gt; = use commit\n# r, reword &lt;commit&gt; = use commit, but edit the commit message\n# e, edit &lt;commit&gt; = use commit, but stop for amending\n# s, squash &lt;commit&gt; = use commit, but meld into previous commit\n# f, fixup &lt;commit&gt; = like \"squash\", but discard this commit's log message\n# x, exec &lt;command&gt; = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop &lt;commit&gt; = remove commit\n# l, label &lt;label&gt; = label current HEAD with a name\n# t, reset &lt;label&gt; = reset HEAD to a label\n# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c &lt;commit&gt; to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n</code></pre> <p>Use a command line text editor to change the word <code>pick</code> to <code>f</code> of <code>fixup</code> for the commits you want to squash, then save your changes and continue the rebase:</p> <p>Per the output above, you can see that:</p> <pre><code>fixup &lt;commit&gt; = like \"squash\", but discard this commit's log message\n</code></pre> <p>Which means that when rebased, the commit message \"fixed some typos\" will be removed, and squashed with the parent commit.</p>"},{"location":"contributors/github_workflow/#push-your-final-changes","title":"Push Your Final Changes","text":"<p>Once done, you can push the final commits to your branch:</p> <pre><code>git push --force\n</code></pre> <p>You can run multiple iteration of <code>rebase</code>/<code>push -f</code>, if needed.</p>"},{"location":"contributors/testing/","title":"Testing","text":""},{"location":"contributors/testing/#testing-your-code","title":"Testing Your Code","text":"<p>k0s uses github actions to run automated tests on any PR, before merging. However, a PR will not be reviewed before all tests are green, so to save time and prevent your PR from going stale, it is best to test it before submitting the PR.</p>"},{"location":"contributors/testing/#run-local-verifications","title":"Run Local Verifications","text":"<p>Please run the following style and formatting commands and fix/check-in any changes:</p> <ol> <li> <p>Linting</p> <p>We use <code>golangci-lint</code> for style verification.  In the repository's root directory, simply run:</p> <pre><code>make lint\n</code></pre> <p>There's no need to install <code>golangci-lint</code> manually. The build system will  take care of that.</p> </li> <li> <p>Go fmt</p> <pre><code>go fmt ./...\n</code></pre> </li> <li> <p>Checking the documentation</p> <p>Follow the instructions for testing the documentation  locally to verify any changes.</p> </li> <li> <p>Pre-submit Flight Checks</p> <p>In the repository root directory, make sure that:</p> <ul> <li><code>make build &amp;&amp; git diff --exit-code</code> runs successfully.    Verifies that the build is working and that the generated source code    matches the one that's checked into source control.</li> <li><code>make check-unit</code> runs successfully.    Verifies that all the unit tests pass.</li> <li><code>make check-basic</code> runs successfully.    Verifies basic cluster functionality using one controller and two workers.</li> <li><code>make check-hacontrolplane</code> runs successfully.    Verifies that joining of controllers works.</li> </ul> <p>Please note that this last test is prone to \"flakiness\", so it might fail on  occasion. If it fails constantly, take a deeper look at your code to find the  source of the problem.</p> <p>If you find that all tests passed, you may open a pull request upstream.</p> </li> </ol>"},{"location":"contributors/testing/#opening-a-pull-request","title":"Opening A Pull Request","text":""},{"location":"contributors/testing/#draft-mode","title":"Draft Mode","text":"<p>You may open a pull request in draft mode. All automated tests will still run against the PR, but the PR will not be assigned for review. Once a PR is ready for review, transition it from Draft mode, and code owners will be notified.</p>"},{"location":"contributors/testing/#pre-requisites-for-pr-merge","title":"Pre-Requisites for PR Merge","text":"<p>In order for a PR to be merged, the following conditions should exist:</p> <ol> <li>The PR has passed all the automated tests (style, build &amp; tests).</li> <li>PR commits have been signed with the <code>--signoff</code> option.</li> <li>PR was reviewed and approved by a code owner.</li> <li>PR is rebased against upstream's main branch.</li> </ol>"},{"location":"contributors/testing/#cleanup-the-local-workspace","title":"Cleanup the local workspace","text":"<p>In order to clean up the local workspace, run <code>make clean</code>. It will clean up all of the intermediate files and directories created during the k0s build. Note that you can't just use <code>git clean -X</code> or even <code>rm -rf</code>, since the Go modules cache sets all of its subdirectories to read-only. If you get in trouble while trying to delete your local workspace, try <code>chmod -R u+w /path/to/workspace &amp;&amp; rm -rf /path/to/workspace</code>.</p>"},{"location":"examples/ansible-playbook/","title":"Ansible Playbook","text":""},{"location":"examples/ansible-playbook/#creating-a-cluster-with-an-ansible-playbook","title":"Creating a cluster with an Ansible Playbook","text":"<p>Ansible is a popular infrastructure-as-code tool that can use to automate tasks for the purpose of achieving the desired state in a system. With Ansible (and the k0s-Ansible playbook) you can quickly install a multi-node Kubernetes Cluster.</p> <p>Note: Before using Ansible to create a cluster, you should have a general understanding of Ansible (refer to the official Ansible User Guide.</p>"},{"location":"examples/ansible-playbook/#prerequisites","title":"Prerequisites","text":"<p>You will require the following tools to install k0s on local virtual machines:</p> Tool Detail <code>multipass</code> A lightweight VM manager that uses KVM on Linux, Hyper-V on Windows, and hypervisor.framework on macOS. Installation information <code>ansible</code> An infrastructure as code tool. Installation Guide <code>kubectl</code> Command line tool for running commands against Kubernetes clusters.  Kubernetes Install Tools"},{"location":"examples/ansible-playbook/#create-the-cluster","title":"Create the cluster","text":"<ol> <li> <p>Download k0s-ansible</p> <p>Clone the k0s-ansible repository on your local machine:</p> <pre><code>git clone https://github.com/movd/k0s-ansible.git\ncd k0s-ansible\n</code></pre> </li> <li> <p>Create virtual machines</p> <p>Note: Though multipass is the VM manager in use here, there is no interdependence.</p> <p>Create a number of virtual machines. For the automation to work, each instance must have passwordless SSH access. To achieve this, provision each instance with a cloud-init manifest that imports your current users' public SSH key and into a user <code>k0s</code> (refer to the bash script below).</p> <p>This creates 7 virtual machines:</p> <pre><code>./tools/multipass_create_instances.sh 7\n</code></pre> <pre><code>Create cloud-init to import ssh key...\n[1/7] Creating instance k0s-1 with multipass...\nLaunched: k0s-1\n[2/7] Creating instance k0s-2 with multipass...\nLaunched: k0s-2\n[3/7] Creating instance k0s-3 with multipass...\nLaunched: k0s-3\n[4/7] Creating instance k0s-4 with multipass...\nLaunched: k0s-4\n[5/7] Creating instance k0s-5 with multipass...\nLaunched: k0s-5\n[6/7] Creating instance k0s-6 with multipass...\nLaunched: k0s-6\n[7/7] Creating instance k0s-7 with multipass...\nLaunched: k0s-7\nName State IPv4 Image\nk0s-1 Running 192.168.64.32 Ubuntu 20.04 LTS\nk0s-2 Running 192.168.64.33 Ubuntu 20.04 LTS\nk0s-3 Running 192.168.64.56 Ubuntu 20.04 LTS\nk0s-4 Running 192.168.64.57 Ubuntu 20.04 LTS\nk0s-5 Running 192.168.64.58 Ubuntu 20.04 LTS\nk0s-6 Running 192.168.64.60 Ubuntu 20.04 LTS\nk0s-7 Running 192.168.64.61 Ubuntu 20.04 LTS\n</code></pre> </li> <li> <p>Create Ansible inventory</p> <p>1. Copy the sample to create the inventory directory:</p> <pre><code>  ```shell\n  cp -rfp inventory/sample inventory/multipass\n  ```\n</code></pre> <p>2. Create the inventory.</p> <pre><code>  Assign the virtual machines to the different host groups, as required by the playbook logic.\n\n  | Host group            | Detail                                    |\n  |:----------------------|:------------------------------------------|\n  | `initial_controller`  | Must contain a single node that creates the worker and controller tokens needed by the other nodes|\n  | `controller`          | Can contain nodes that, together with the host from `initial_controller`, form a highly available isolated control plane |\n  | `worker`              | Must contain at least one node, to allow for the deployment of Kubernetes objects |\n</code></pre> <p>3. Fill in <code>inventory/multipass/inventory.yml</code>. This can be done by direct entry using the metadata provided by <code>multipass list,</code>, or you can use the following Python script <code>multipass_generate_inventory.py</code>:</p> <pre><code>  ```shell\n  ./tools/multipass_generate_inventory.py\n  ```\n\n  ```shell\n  Designate first three instances as control plane\n  Created Ansible Inventory at: /Users/dev/k0s-ansible/tools/inventory.yml\n  $ cp tools/inventory.yml inventory/multipass/inventory.yml\n  ```\n\n  Your `inventory/multipass/inventory.yml` should resemble the example below:\n\n  ```yaml\n  ---\n  all:\n    children:\n      initial_controller:\n        hosts:\n          k0s-1:\n      controller:\n        hosts:\n          k0s-2:\n          k0s-3:\n      worker:\n        hosts:\n          k0s-4:\n          k0s-5:\n          k0s-6:\n          k0s-7:\n    hosts:\n      k0s-1:\n        ansible_host: 192.168.64.32\n      k0s-2:\n        ansible_host: 192.168.64.33\n      k0s-3:\n        ansible_host: 192.168.64.56\n      k0s-4:\n        ansible_host: 192.168.64.57\n      k0s-5:\n        ansible_host: 192.168.64.58\n      k0s-6:\n        ansible_host: 192.168.64.60\n      k0s-7:\n        ansible_host: 192.168.64.61\n    vars:\n      ansible_user: k0s\n  ```\n</code></pre> </li> <li> <p>Test the virtual machine connections</p> <p>Run the following command to test the connection to your hosts:</p> <pre><code>ansible -i inventory/multipass/inventory.yml -m ping\n</code></pre> <pre><code>k0s-4 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n...\n</code></pre> <p>If the test result indicates success, you can proceed.</p> </li> <li> <p>Provision the cluster with Ansible</p> <p>Applying the playbook, k0s download and be set up on all nodes, tokens will be exchanged, and a kubeconfig will be dumped to your local deployment environment.</p> <pre><code>ansible-playbook site.yml -i inventory/multipass/inventory.yml\n</code></pre> <pre><code>TASK [k0s/initial_controller : print kubeconfig command] *******************************************************\nTuesday 22 December 2020  17:43:20 +0100 (0:00:00.257)       0:00:41.287 ******\nok: [k0s-1] =&gt; {\n    \"msg\": \"To use Cluster: export KUBECONFIG=/Users/dev/k0s-ansible/inventory/multipass/artifacts/k0s-kubeconfig.yml\"\n}\n...\nPLAY RECAP *****************************************************************************************************\nk0s-1                      : ok=21   changed=11   unreachable=0    failed=0    skipped=1    rescued=0    ignored=0\nk0s-2                      : ok=10   changed=5    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0\nk0s-3                      : ok=10   changed=5    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0\nk0s-4                      : ok=9    changed=5    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0\nk0s-5                      : ok=9    changed=5    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0\nk0s-6                      : ok=9    changed=5    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0\nk0s-7                      : ok=9    changed=5    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0\n\nTuesday 22 December 2020  17:43:36 +0100 (0:00:01.204)       0:00:57.478 ******\n===============================================================================\nprereq : Install apt packages -------------------------------------------------------------------------- 22.70s\nk0s/controller : Wait for k8s apiserver ----------------------------------------------------------------- 4.30s\nk0s/initial_controller : Create worker join token ------------------------------------------------------- 3.38s\nk0s/initial_controller : Wait for k8s apiserver --------------------------------------------------------- 3.36s\ndownload : Download k0s binary k0s-v0.9.0-rc1-amd64 ----------------------------------------------------- 3.11s\nGathering Facts ----------------------------------------------------------------------------------------- 2.85s\nGathering Facts ----------------------------------------------------------------------------------------- 1.95s\nprereq : Create k0s Directories ------------------------------------------------------------------------- 1.53s\nk0s/worker : Enable and check k0s service --------------------------------------------------------------- 1.20s\nprereq : Write the k0s config file ---------------------------------------------------------------------- 1.09s\nk0s/initial_controller : Enable and check k0s service --------------------------------------------------- 0.94s\nk0s/controller : Enable and check k0s service ----------------------------------------------------------- 0.73s\nGathering Facts ----------------------------------------------------------------------------------------- 0.71s\nGathering Facts ----------------------------------------------------------------------------------------- 0.66s\nGathering Facts ----------------------------------------------------------------------------------------- 0.64s\nk0s/worker : Write the k0s token file on worker --------------------------------------------------------- 0.64s\nk0s/worker : Copy k0s service file ---------------------------------------------------------------------- 0.53s\nk0s/controller : Write the k0s token file on controller ------------------------------------------------- 0.41s\nk0s/controller : Copy k0s service file ------------------------------------------------------------------ 0.40s\nk0s/initial_controller : Copy k0s service file ---------------------------------------------------------- 0.36s\n</code></pre> </li> </ol>"},{"location":"examples/ansible-playbook/#use-the-cluster-with-kubectl","title":"Use the cluster with kubectl","text":"<p>A kubeconfig was copied to your local machine while the playbook was running which you can use to gain access to your new Kubernetes cluster:</p> <pre><code>export KUBECONFIG=/Users/dev/k0s-ansible/inventory/multipass/artifacts/k0s-kubeconfig.yml\nkubectl cluster-info\n</code></pre> <pre><code>Kubernetes control plane is running at https://192.168.64.32:6443\nCoreDNS is running at https://192.168.64.32:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy\nMetrics-server is running at https://192.168.64.32:6443/api/v1/namespaces/kube-system/services/https:metrics-server:/proxy\n\n$ kubectl get nodes -o wide\nNAME    STATUS     ROLES    AGE   VERSION        INTERNAL-IP     EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION     CONTAINER-RUNTIME\nk0s-4   Ready      &lt;none&gt;   21s   v1.20.1-k0s1   192.168.64.57   &lt;none&gt;        Ubuntu 20.04.1 LTS   5.4.0-54-generic   containerd://1.4.3\nk0s-5   Ready      &lt;none&gt;   21s   v1.20.1-k0s1   192.168.64.58   &lt;none&gt;        Ubuntu 20.04.1 LTS   5.4.0-54-generic   containerd://1.4.3\nk0s-6   NotReady   &lt;none&gt;   21s   v1.20.1-k0s1   192.168.64.60   &lt;none&gt;        Ubuntu 20.04.1 LTS   5.4.0-54-generic   containerd://1.4.3\nk0s-7   NotReady   &lt;none&gt;   21s   v1.20.1-k0s1   192.168.64.61   &lt;none&gt;        Ubuntu 20.04.1 LTS   5.4.0-54-generic   containerd://1.4.3\n</code></pre> <p>Note: The first three control plane nodes will not display, as the control plane is fully isolated. To check on the distributed etcd cluster, you can use ssh to securely log a controller node, or you can run the following ad-hoc command:</p> <pre><code>ansible k0s-1 -a \"k0s etcd member-list -c /etc/k0s/k0s.yaml\" -i inventory/multipass/inventory.yml | tail -1 | jq\n</code></pre> <pre><code>{\n  \"level\": \"info\",\n  \"members\": {\n    \"k0s-1\": \"https://192.168.64.32:2380\",\n    \"k0s-2\": \"https://192.168.64.33:2380\",\n    \"k0s-3\": \"https://192.168.64.56:2380\"\n  },\n  \"msg\": \"done\",\n  \"time\": \"2020-12-23T00:21:22+01:00\"\n}\n</code></pre> <p>Once all worker nodes are at <code>Ready</code> state you can use the cluster. You can test the cluster state by creating a simple nginx deployment.</p> <pre><code>kubectl create deployment nginx --image=gcr.io/google-containers/nginx --replicas=5\n</code></pre> <pre><code>deployment.apps/nginx created\n</code></pre> <pre><code>kubectl expose deployment nginx --target-port=80 --port=8100\n</code></pre> <pre><code>service/nginx exposed\n</code></pre> <pre><code>kubectl run hello-k0s --image=quay.io/prometheus/busybox --rm -it --restart=Never --command -- wget -qO- nginx:8100\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx on Debian!&lt;/title&gt;\n...\npod \"hello-k0s\" deleted\n</code></pre> <p>Note: k0s users are the developers of k0s-ansible. Please send your feedback, bug reports, and pull requests to github.com/movd/k0s-ansible._</p>"},{"location":"examples/gitops-flux/","title":"GitOps with Flux","text":""},{"location":"examples/gitops-flux/#using-gitops-with-flux","title":"Using GitOps with Flux","text":"<p>This tutorial describes the benefits of using GitOps with k0s and provides an example of deploying an application with Flux v2.</p> <p>GitOps is a practice where you leverage Git as the single source of truth. It offers a declarative way to do Kubernetes cluster management and application delivery. The desired states, using Kubernetes manifests and helm packages, are pulled from a git repository and automatically deployed to the cluster. This also makes it quick to re-deploy and recover applications whenever needed.</p> <p></p>"},{"location":"examples/gitops-flux/#why-gitops-with-k0s","title":"Why GitOps with k0s","text":"<p>k0s doesn't come with a lot of different extensions and add-ons that some users might find useful (and some not). Instead, k0s comes with 100% upstream Kubernetes and is compatible with all Kubernetes extensions. This makes it easy for k0s users to freely select the needed extensions that their applications and infrastructure need, without conflicting to any predefined options. Now, GitOps is a perfect practice to deploy these extensions automatically with applications by defining and configuring them directly in Git. This will also help with cluster security as the cluster doesn't need to be accessed directly when application changes are needed. However, this puts more stress on the Git access control, because changes in Git are propagated automatically to the cluster.</p>"},{"location":"examples/gitops-flux/#install-k0s","title":"Install k0s","text":"<p>Let's start by installing k0s. Any k0s deployment option will do, but to keep things simple, this Quick Start Guide gets you started with a single node k0s cluster.</p> <p>Run these three commands to download k0s, install and start it:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://get.k0s.sh | sudo sh\nsudo k0s install controller --single\nsudo k0s start\n</code></pre>"},{"location":"examples/gitops-flux/#set-kubeconfig","title":"Set kubeconfig","text":"<p>Next, you need to set the KUBECONFIG variable, which is needed by Flux CLI later on.</p> <pre><code>sudo k0s kubeconfig admin &gt; kubeconfig\nexport KUBECONFIG=$PWD/kubeconfig\n</code></pre>"},{"location":"examples/gitops-flux/#install-flux","title":"Install Flux","text":"<p>To proceed with Flux, install the Flux CLI, which is used for configuring Flux to your Kubernetes cluster. For macOS and Linux, this can be done either with brew or bash script. Use one of them:</p> <pre><code>brew install fluxcd/tap/flux\n</code></pre> <p>or</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://fluxcd.io/install.sh | sudo bash\n</code></pre> <p>For more details of the Flux installation, check the Flux documentation.</p>"},{"location":"examples/gitops-flux/#configure-flux-for-a-github-repository","title":"Configure Flux for a GitHub repository","text":"<p>Export your GitHub personal access token (instructions how to get it) and username:</p> <pre><code>export GITHUB_TOKEN=&lt;your-token&gt;\nexport GITHUB_USER=&lt;your-username&gt;\n</code></pre> <p>Come up with a GitHub repo name (e.g. flux-demo), which will be used by Flux to store (and sync) the config files.</p> <pre><code>export GITHUB_REPO_NAME=&lt;select-repo-name-to-be-created&gt;\n</code></pre> <p>Bootstrap flux to your cluster. The GitHub repo will be created automatically by Flux:</p> <pre><code>flux bootstrap github \\\n--owner=$GITHUB_USER \\\n--repository=$GITHUB_REPO_NAME \\\n--branch=main \\\n--path=./clusters/my-cluster \\\n--personal\n</code></pre> <p>Now you are all set with Flux and can proceed to deploy your first application.</p>"},{"location":"examples/gitops-flux/#deploy-example-application","title":"Deploy example application","text":"<p>Next, we'll deploy a simple web application and expose it using a NodePort service. In the previous step, we configured Flux to track the path /clusters/my-cluster/ in your repository. Now clone the repo to your local machine:</p> <pre><code>git clone git@github.com:$GITHUB_USER/$GITHUB_REPO_NAME.git\ncd $GITHUB_REPO_NAME/clusters/my-cluster/\n</code></pre> <p>Create the following YAML file (simple-web-server-with-nodeport.yaml) into the same directory:</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\n  name: web\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-server\n  namespace: web\nspec:\n  selector:\n    matchLabels:\n      app: web\n    template:\n      metadata:\n        labels:\n          app: web\n      spec:\n        containers:\n        - name: httpd\n          image: httpd:2.4.53-alpine\n          ports:\n          - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: web-server-service\n  namespace: web\nspec:\n  type: NodePort\n  selector:\n    app: web\n  ports:\n    - port: 80\n      targetPort: 80\n      nodePort: 30003\n</code></pre> <p>Then push the new file to the repository:</p> <pre><code>git add .\ngit commit -m \"Add web server manifest\"\ngit push\n</code></pre> <p>Check that Flux detects your changes and the web server gets applied (by default this should happen within 1 min):</p> <pre><code>flux get kustomizations\n</code></pre> <p>If the deployment went successfully, you should see the newly added objects:</p> <pre><code>sudo k0s kubectl get all -n web\n</code></pre> <p>You can try to access the web application using</p> <pre><code>curl localhost:30003\n</code></pre> <p>or by using a web browser http://localhost:30003.</p> <p>Voil\u00e0! You have now installed the example application using the GitOps method with Flux. As a next step you can try to modify the web app YAML file or add another application directly in to the Git repo and see how Flux will automatically pick up the changes without accessing the cluster with kubectl.</p>"},{"location":"examples/gitops-flux/#uninstall-flux","title":"Uninstall Flux","text":"<p>If you want to uninstall Flux from the cluster, run:</p> <pre><code>flux uninstall --namespace=flux-system\n</code></pre> <p>Your applications, which were installed by Flux, will remain in the cluster, but you don't have the Flux processes anymore to sync up the desired state from Git.</p>"},{"location":"examples/metallb-loadbalancer/","title":"MetalLB Load Balancer","text":""},{"location":"examples/metallb-loadbalancer/#installing-metallb-load-balancer","title":"Installing MetalLB Load Balancer","text":"<p>This tutorial covers the installation of MetalLB load balancer on k0s. k0s doesn't come with an in-built load balancer, but it's easy to deploy MetalLB as shown in this document.</p>"},{"location":"examples/metallb-loadbalancer/#about-load-balancers","title":"About Load Balancers","text":"<p>Load balancers can be used for exposing applications to the external network. Load balancer provides a single IP address to route incoming requests to your app. In order to successfully create Kubernetes services of type LoadBalancer, you need to have the load balancer (implementation) available for Kubernetes.</p> <p>Load balancer can be implemented by a cloud provider as an external service (with additional cost). This can also be implemented internally in the Kubernetes cluster (pure SW solution) with MetalLB.</p>"},{"location":"examples/metallb-loadbalancer/#metallb","title":"MetalLB","text":"<p>MetalLB implements the Kubernetes service of type LoadBalancer. When a LoadBalancer service is requested, MetalLB allocates an IP address from the configured range and makes the network aware that the IP \u201clives\u201d in the cluster.</p> <p></p> <p>One of the benefits of MetalLB is that you avoid all cloud provider dependencies. That's why MetalLB is typically used for bare-metal deployments.</p> <p>See the MetalLB requirements in the MetalLB's official documentation. By default, k0s runs with Kube-Router CNI, which is compatible with MetalLB as long as you don't use MetalLB\u2019s BGP mode. If you are not using Kube-Router and you are using kube-proxy in IPVS mode, you need to enable strict ARP mode in kube-proxy (see MetalLB preparations):</p> <pre><code>apiVersion: k0s.k0sproject.io/v1beta1\nkind: ClusterConfig\nmetadata:\n  name: k0s\nspec:\n  network:\n    kubeProxy:\n      mode: ipvs\n      ipvs:\n        strictARP: true\n</code></pre> <p>Port 7946 (TCP &amp; UDP) must be allowed between the nodes. In addition, before installing MetalLB, make sure there is no other software running on port 7946 on the nodes, such as docker daemon.</p>"},{"location":"examples/metallb-loadbalancer/#install-metallb","title":"Install MetalLB","text":"<ol> <li> <p>Install MetalLB using the official Helm chart and k0s Helm extension manager:</p> <pre><code>apiVersion: k0s.k0sproject.io/v1beta1\nkind: ClusterConfig\n  metadata:\nname: k0s\nspec:\n  extensions:\n    helm:\n      repositories:\n      - name: metallb\n        url: https://metallb.github.io/metallb\n      charts:\n      - name: metallb\n        chartname: metallb/metallb\n        namespace: metallb\n</code></pre> <p>Other installation methods are available in the MetalLB's official documentation.</p> </li> <li> <p>Create ConfigMap for MetalLB</p> <p>Next you need to create ConfigMap, which includes an IP address range for the load balancer. The pool of IPs must be dedicated to MetalLB's use. You can't reuse for example the Kubernetes node IPs or IPs controlled by other services. You can, however, use private IP addresses, for example 192.168.1.180-192.168.1.199, but then you need to take care of the routing from the external network if you need external access. In this example, we don't need it.</p> <p>Create a YAML file accordingly, and deploy it: <code>kubectl apply -f metallb-l2-pool.yaml</code></p> <pre><code>---\napiVersion: metallb.io/v1beta1\nkind: IPAddressPool\nmetadata:\n  name: first-pool\n  namespace: metallb-system\nspec:\n  addresses:\n  - &lt;ip-address-range-start&gt;-&lt;ip-address-range-stop&gt;\n---\napiVersion: metallb.io/v1beta1\nkind: L2Advertisement\nmetadata:\n  name: example\n  namespace: metallb-system\n</code></pre> </li> <li> <p>Deploy an example application (web server) with a load balancer</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\n  name: web\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-server\n  namespace: web\nspec:\n  selector:\n    matchLabels:\n      app: web\n  template:\n    metadata:\n      labels:\n        app: web\n    spec:\n      containers:\n      - name: httpd\n        image: httpd:2.4.53-alpine\n        ports:\n        - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: web-server-service\n  namespace: web\nspec:\n  selector:\n    app: web\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 80\n  type: LoadBalancer\n</code></pre> </li> <li> <p>Check your LoadBalancer</p> <p>Run the following command to see your LoadBalancer with the external-ip and port.</p> <pre><code>kubectl get service -n web\n</code></pre> </li> <li> <p>Access your example application</p> <p>If you used private IP addresses for MetalLB in the ConfigMap (in step 2), you should run the following command from the local network. Use the IP address from the previous step.</p> <pre><code>curl &lt;EXTERNAL-IP&gt;\n</code></pre> <p>If you are successful, you should see <code>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code>.</p> </li> </ol>"},{"location":"examples/metallb-loadbalancer/#additional-information","title":"Additional information","text":"<p>For more information about MetalLB installation, take a look at the official MetalLB documentation.</p>"},{"location":"examples/metallb-loadbalancer/#alternative-examples","title":"Alternative examples","text":"<p>Get load balancer using cloud provider.</p>"},{"location":"examples/nginx-ingress/","title":"NGINX Ingress Controller","text":""},{"location":"examples/nginx-ingress/#installing-nginx-ingress-controller","title":"Installing NGINX Ingress Controller","text":"<p>This tutorial covers the installation of Ingress NGINX Controller, which is an open source project made by the Kubernetes community. k0s doesn't come with a built-in ingress controller, but it's easy to deploy Ingress NGINX Controller as shown in this document. Other ingress solutions can be used as well (see the links at the end of the page).</p>"},{"location":"examples/nginx-ingress/#nodeport-vs-loadbalancer-vs-ingress","title":"<code>NodePort</code> vs. <code>LoadBalancer</code> vs. <code>Ingress</code>","text":"<p>Kubernetes offers multiple options for exposing services to external networks. The main options are <code>NodePort</code>, <code>LoadBalancer</code> and <code>Ingress</code>.</p> <p>NodePort, as the name says, means that a port on a node is configured to route incoming requests to a certain service. The port range is limited to 30000-32767, so you cannot expose commonly used ports like 80 or 443 via <code>NodePort</code>.</p> <p>LoadBalancer is a service, which is typically implemented by the cloud provider as an external service (with additional cost). Load balancers can also be installed internally in the Kubernetes cluster with MetalLB, which is typically used for bare-metal deployments. Load balancer provides a single IP address to access your services, which can run on multiple nodes.</p> <p>Ingress controller helps to consolidate routing rules of multiple applications into one entity. Ingress controller is exposed to an external network with the help of <code>NodePort</code>, <code>LoadBalancer</code> or host network. You can also use Ingress controller to terminate TLS for your domain in one place, instead of terminating TLS for each application separately.</p>"},{"location":"examples/nginx-ingress/#ingress-nginx-controller","title":"Ingress NGINX Controller","text":"<p>Ingress NGINX Controller is a very popular ingress for Kubernetes. In many cloud environments, it can be exposed to an external network by using the load balancer offered by the cloud provider. However, cloud load balancers are not necessary. Load balancer can also be implemented with MetalLB, which can be deployed in the same Kubernetes cluster. Another option to expose the Ingress controller to an external network is to use <code>NodePort</code>. The third option is to use host network. All of these alternatives are described in more detail on below, with separate examples.</p> <p></p>"},{"location":"examples/nginx-ingress/#installation-using-nodeport","title":"Installation using <code>NodePort</code>","text":"<p>Installing using <code>NodePort</code> is the most simple example for Ingress NGINX Controller as we can avoid the load balancer dependency. <code>NodePort</code> is used for exposing the controller to the external network.</p> <ol> <li> <p>Install Ingress NGINX Controller (using the official manifests from the official <code>ingress-nginx</code> Kubernetes git repository)</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.3/deploy/static/provider/baremetal/deploy.yaml\n</code></pre> </li> <li> <p>Check that the Ingress controller pods have started</p> <pre><code>kubectl get pods -n ingress-nginx\n</code></pre> </li> <li> <p>Check that you can see the NodePort service</p> <pre><code>kubectl get services -n ingress-nginx\n</code></pre> </li> <li> <p>From version <code>v1.0.0</code> of the Ingress NGINX Controller, a ingressclass object is required.</p> <p>In the default installation, an ingressclass object named <code>nginx</code> has already been created.</p> <pre><code>$ kubectl -n ingress-nginx get ingressclasses\nNAME    CONTROLLER             PARAMETERS   AGE\nnginx   k8s.io/ingress-nginx   &lt;none&gt;       162m\n</code></pre> <p>If this is only instance of the Ingress NGINX Controller, you should add the annotation <code>ingressclass.kubernetes.io/is-default-class</code> in your ingress class:</p> <pre><code>kubectl -n ingress-nginx annotate ingressclasses nginx ingressclass.kubernetes.io/is-default-class=\"true\"\n</code></pre> </li> <li> <p>Try connecting the controller using the <code>NodePort</code> from the previous step (in the range of 30000-32767)</p> <pre><code>curl &lt;worker-external-ip&gt;:&lt;node-port&gt;\n</code></pre> <p>If you don't yet have any backend service configured, you should see \"404 Not Found\" from nginx. This is okay for now. If you see a response from nginx, the ingress controller is running and you can reach it.</p> </li> <li> <p>Deploy a small test application (Apache HTTP Server) to verify your ingress controller.</p> <p>Create the following YAML file and name it <code>simple-web-server-with-ingress.yaml</code>:</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\n  name: web\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-server\n  namespace: web\nspec:\n  selector:\n    matchLabels:\n      app: web\n  template:\n    metadata:\n      labels:\n        app: web\n    spec:\n      containers:\n      - name: httpd\n        image: httpd:2.4.53-alpine\n        ports:\n        - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: web-server-service\n  namespace: web\nspec:\n  selector:\n    app: web\n  ports:\n    - protocol: TCP\n      port: 5000\n      targetPort: 80\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-server-ingress\n  namespace: web\nspec:\n  ingressClassName: nginx\n  rules:\n  - host: web.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-server-service\n            port:\n              number: 5000\n</code></pre> <p>Deploy the app:</p> <pre><code>kubectl apply -f simple-web-server-with-ingress.yaml\n</code></pre> </li> <li> <p>Verify that you can access your application using the <code>NodePort</code> from step 3.</p> <pre><code>curl &lt;worker-external-ip&gt;:&lt;node-port&gt; -H 'Host: web.example.com'\n</code></pre> <p>If you are successful, you should see <code>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code>.</p> </li> </ol>"},{"location":"examples/nginx-ingress/#install-using-loadbalancer","title":"Install using <code>LoadBalancer</code>","text":"<p>In this example you'll install Ingress NGINX Controller using <code>LoadBalancer</code> on k0s.</p> <ol> <li> <p>Install a <code>LoadBalancer</code></p> <p>There are two alternatives to install <code>LoadBalancer</code> on k0s. Follow the links in order to install <code>LoadBalancer</code>.</p> <p>- MetalLB as a pure software solution running internally in the k0s cluster   - Cloud provider's load balancer running outside of the k0s cluster</p> </li> <li> <p>Verify <code>LoadBalancer</code></p> <p>In order to proceed you need to have a load balancer available for the Kubernetes cluster. To verify that it's available, deploy a simple Service of type <code>LoadBalancer</code>.</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: example-load-balancer\nspec:\n  selector:\n    app: web\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 80\n  type: LoadBalancer\n</code></pre> <pre><code>kubectl apply -f example-load-balancer.yaml\n</code></pre> <p>Then run the following command to see your <code>LoadBalancer</code> with an external IP address.</p> <pre><code>kubectl get service example-load-balancer\n</code></pre> <p>If the <code>LoadBalancer</code> is not available, you won't get an IP address for EXTERNAL-IP. Instead, it's <code>&lt;pending&gt;</code>. In this case you should go back to the previous step and check your load balancer availability.</p> <p>If you are successful, you'll see a real IP address and you can proceed further.</p> <p>You can delete the example-load-balancer:</p> <pre><code>kubectl delete -f example-load-balancer.yaml\n</code></pre> </li> <li> <p>Install Ingress NGINX Controller by following the steps in the previous chapter (step 1 to step 4).</p> </li> <li> <p>Edit the Ingress NGINX Controller to use <code>LoadBalancer</code> instead of <code>NodePort</code></p> <pre><code>kubectl edit service ingress-nginx-controller -n ingress-nginx\n</code></pre> <p>Find the spec.type field and change it from <code>NodePort</code> to <code>LoadBalancer</code>.</p> </li> <li> <p>Check that you can see the <code>ingress-nginx</code> service with type <code>LoadBalancer</code>.</p> <pre><code>kubectl get services -n ingress-nginx\n</code></pre> </li> <li> <p>Try connecting to the ingress controller</p> <p>If you used private IP addresses for MetalLB in step 2, you should run the following command from the local network. Use the IP address from the previous step, column EXTERNAL-IP.</p> <pre><code>curl &lt;EXTERNAL-IP&gt;\n</code></pre> <p>If you don't yet have any backend service configured, you should see \"404 Not Found\" from nginx. This is okay for now. If you see a response from nginx, the Ingress Controller is running and you can reach it using <code>LoadBalancer</code>.</p> </li> <li> <p>Deploy a small test application (Apache HTTP Server) to verify your <code>Ingress</code>.</p> <p>Create the YAML file <code>simple-web-server-with-ingress.yaml</code> as described in the previous chapter (step 6) and deploy it.</p> <pre><code>kubectl apply -f simple-web-server-with-ingress.yaml\n</code></pre> </li> <li> <p>Verify that you can access your application through the <code>LoadBalancer</code> and ingress controller.</p> <pre><code>curl &lt;worker-external-ip&gt; -H 'Host: web.example.com'\n</code></pre> <p>If you are successful, you should see <code>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code>.</p> </li> </ol>"},{"location":"examples/nginx-ingress/#install-using-host-network","title":"Install using host network","text":"<p>The host network option exposes Ingress directly using the worker nodes' IP addresses. It also allows you to use ports 80 and 443. This option doesn't use any Service objects (<code>ClusterIP</code>, <code>NodePort</code>, <code>LoadBalancer</code>) and it has the limitation that only one Ingress controller Pod may be scheduled on each cluster node.</p> <ol> <li> <p>Install Ingress NGINX Controller manifests:</p> <pre><code>wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.3/deploy/static/provider/baremetal/deploy.yaml\n</code></pre> </li> <li> <p>Edit <code>deploy.yaml</code>. Find the Deployment ingress-nginx-controller and enable the host network option by adding the <code>hostNetwork</code> line:</p> <pre><code>spec:\n  template:\n    spec:\n      hostNetwork: true\n</code></pre> <p>You can also remove the Service ingress-nginx-controller completely, because it won't be needed.</p> </li> <li> <p>Install Ingress</p> <pre><code>kubectl apply -f deploy.yaml\n</code></pre> </li> <li> <p>Try to connect to the ingress controller, deploy a test application and verify the access. These steps are similar to the previous install methods.</p> </li> </ol>"},{"location":"examples/nginx-ingress/#additional-information","title":"Additional information","text":"<p>For more information about Ingress NGINX Controller installation, take a look at the official installation guide and bare-metal considerations.</p>"},{"location":"examples/nginx-ingress/#alternative-examples-for-ingress-controllers-on-k0s","title":"Alternative examples for ingress controllers on k0s","text":"<p>Traefik Ingress</p>"},{"location":"examples/openebs/","title":"OpenEBS storage","text":""},{"location":"examples/openebs/#openebs","title":"OpenEBS","text":"<p>This tutorial covers the installation of OpenEBS as a Helm extension. OpenEBS can be installed as a helm chart by adding it as an extension to your configuration:</p> <pre><code>  extensions:\n    helm:\n      repositories:\n      - name: openebs-internal\n        url: https://openebs.github.io/charts\n      charts:\n      - name: openebs\n        chartname: openebs-internal/openebs\n        version: \"3.9.0\"\n        namespace: openebs\n        order: 1\n        values: |\n          localprovisioner:\n            hostpathClass:\n              enabled: true\n              isDefaultClass: false\n</code></pre> <p>If you want OpenEBS to be your default storage class, set <code>isDefaultClass</code> to <code>true</code>.</p>"},{"location":"examples/openebs/#usage","title":"Usage","text":"<p>Once installed, the cluster will have two storage classes available for you to use:</p> <pre><code>k0s kubectl get storageclass\n</code></pre> <pre><code>NAME               PROVISIONER        RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE\nopenebs-device     openebs.io/local   Delete          WaitForFirstConsumer   false                  24s\nopenebs-hostpath   openebs.io/local   Delete          WaitForFirstConsumer   false                  24s\n</code></pre> <p>The <code>openebs-hostpath</code> is the storage class that maps to <code>/var/openebs/local</code>.</p> <p>The <code>openebs-device</code> is not configured and could be configured by manifest deployer accordingly to the OpenEBS documentation</p>"},{"location":"examples/openebs/#example","title":"Example","text":"<p>Use following manifests as an example of pod with mounted volume:</p> <pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: nginx-pvc\n  namespace: default\nspec:\n  accessModes:\n    - ReadWriteOnce\n  storageClassName: openebs-hostpath\n  resources:\n    requests:\n      storage: 5Gi\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx\n  namespace: default\n  labels:\n    app: nginx\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n  strategy:\n    type: Recreate\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - image: nginx\n        name: nginx\n        volumeMounts:\n        - name: persistent-storage\n          mountPath: /var/lib/nginx\n      volumes:\n      - name: persistent-storage\n        persistentVolumeClaim:\n          claimName: nginx-pvc\n</code></pre> <pre><code>k0s kubectl apply -f nginx.yaml\n</code></pre> <pre><code>persistentvolumeclaim/nginx-pvc created\ndeployment.apps/nginx created\nbash-5.1# k0s kc get pods\nNAME                    READY   STATUS    RESTARTS   AGE\nnginx-d95bcb7db-gzsdt   1/1     Running   0          30s\n</code></pre> <pre><code>k0s kubectl get pv\n</code></pre> <pre><code>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS       REASON   AGE\npvc-9a7fae2d-eb03-42c3-aaa9-1a807d5df12f   5Gi        RWO            Delete           Bound    default/nginx-pvc   openebs-hostpath            30s\n</code></pre>"},{"location":"examples/rook-ceph/","title":"Ceph Storage with Rook","text":""},{"location":"examples/rook-ceph/#installing-ceph-storage-with-rook","title":"Installing Ceph Storage with Rook","text":"<p>In this tutorial you'll create a Ceph storage for k0s. Ceph is a highly scalable, distributed storage solution. It offers object, block, and file storage, and it's designed to run on any common hardware. Ceph implements data replication into multiple volumes that makes it fault-tolerant. Another clear advantage of Ceph in Kubernetes is the dynamic provisioning. This means that applications just need to request the storage (persistent volume claim) and Ceph will automatically provision the requested storage without a manual creation of the persistent volume each time.</p> <p>Unfortunately, the Ceph deployment as such can be considered a bit complex. To make the deployment easier, we'll use Rook operator. Rook is a CNCF project and it's dedicated to storage orchestration. Rook supports several storage solutions, but in this tutorial we will use it to manage Ceph.</p> <p>This tutorial uses three worker nodes and one controller. It's possible to use less nodes, but using three worker nodes makes it a good example for deploying a high-available storage cluster. We use external storage partitions, which are assigned to the worker nodes to be used by Ceph.</p> <p>After the Ceph deployment we'll deploy a sample application (MongoDB) to use the storage in practice.</p> <p></p>"},{"location":"examples/rook-ceph/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux</li> <li>GitHub access</li> <li>AWS account</li> <li>Terraform</li> </ul>"},{"location":"examples/rook-ceph/#deployment-steps","title":"Deployment steps","text":""},{"location":"examples/rook-ceph/#1-preparations","title":"1. Preparations","text":"<p>In this example we'll use Terraform to create four Ubuntu virtual machines on AWS. Using Terraform makes the VM deployment fast and repeatable. You can avoid manually setting up everything in the AWS GUI. Moreover, when you have finished with the tutorial, it's very easy to tear down the virtual machines with Terraform (with one command). However, you can set up the nodes in many different ways and it doesn't make a difference in the following steps.</p> <p>We will use k0sctl to create the k0s cluster. The k0sctl repository also includes a ready-made Terraform configuration to create the virtual machines on AWS. We'll use that. Let's start be cloning the k0sctl repo.</p> <pre><code>git clone git@github.com:k0sproject/k0sctl.git\n</code></pre> <p>Take a look at the Terraform files</p> <pre><code>cd k0sctl/examples/aws-tf\nls -l\n</code></pre> <p>Open <code>variables.tf</code> and set the number of controller and worker nodes like this:</p> <pre><code>variable \"cluster_name\" {\n  type    = string\n  default = \"k0sctl\"\n}\n\nvariable \"controller_count\" {\n  type    = number\n  default = 1\n}\n\nvariable \"worker_count\" {\n  type    = number\n  default = 3\n}\n\nvariable \"cluster_flavor\" {\n  type    = string\n  default = \"t3.small\"\n}\n</code></pre> <p>Open <code>main.tf</code> to check or modify k0s version near the end of the file.</p> <p>You can also configure a different name to your cluster and change the default VM type. <code>t3.small</code> (2 vCPUs, 2 GB RAM) runs just fine for this tutorial.</p>"},{"location":"examples/rook-ceph/#2-create-the-virtual-machines","title":"2. Create the virtual machines","text":"<p>For AWS, you need an account. Terraform will use the following environment variable: <code>AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN</code>. You can easily copy-paste them from the AWS portal. For more information, see the AWS documentation.</p> <p></p> <p>When the environment variables are set, you can proceed with Terraform and deploy the virtual machines.</p> <pre><code>terraform init\nterraform apply\n</code></pre> <p>If you decide to create the virtual machines manually using AWS GUI, you need to disable source / destination checking. This needs to be disabled always for multi-node Kubernetes clusters in order to get the node-to-node communication working due to Network Address Translation. For Terraform this is already taken care of in the default configuration.</p>"},{"location":"examples/rook-ceph/#3-create-and-attach-the-volumes","title":"3. Create and attach the volumes","text":"<p>Ceph requires one of the following storage options for storing the data:</p> <ul> <li>Raw devices (no partitions or formatted filesystems)</li> <li>Raw partitions (no formatted filesystem)</li> <li>PVs available from a storage class in block mode</li> </ul> <p>We will be using raw partitions (AWS EBS volumes), which can be easily attached to the worker node virtual machines. They are automatically detected by Ceph with its default configuration.</p> <p>Deploy AWS EBS volumes, one for each worker node. You can manually create three EBS volumes (for example 10 GB each) using the AWS GUI and attach those to your worker nodes. Formatting shouldn't be done. Instead, Ceph handles that part automatically.</p> <p>After you have attached the EBS volumes to the worker nodes, log in into one of the workers and check the available block devices:</p> <pre><code>lsblk -f\n</code></pre> <pre><code>NAME        FSTYPE   LABEL           UUID                                 FSAVAIL FSUSE% MOUNTPOINT\nloop0       squashfs                                                            0   100% /snap/amazon-ssm-agent/3552\nloop1       squashfs                                                            0   100% /snap/core18/1997\nloop2       squashfs                                                            0   100% /snap/snapd/11588\nloop3       squashfs                                                            0   100% /snap/lxd/19647\nnvme0n1\n\u2514\u2500nvme0n1p1 ext4     cloudimg-rootfs e8070c31-bfee-4314-a151-d1332dc23486    5.1G    33% /\nnvme1n1\n</code></pre> <p>The last line (<code>nvme1n1</code>) in this example printout corresponds to the attached EBS volume. Note that it doesn't have any filesystem (<code>FSTYPE</code> is empty). This meets the Ceph storage requirements and you are good to proceed.</p>"},{"location":"examples/rook-ceph/#4-install-k0s-using-k0sctl","title":"4. Install k0s using k0sctl","text":"<p>You can use Terraform to automatically output a config file for k0sctl with the IP addresses and access details.</p> <pre><code>terraform output -raw k0s_cluster &gt; k0sctl.yaml\n</code></pre> <p>After that deploying k0s becomes very easy with the ready-made configuration.</p> <pre><code>k0sctl apply --config k0sctl.yaml\n</code></pre> <p>It might take around 2-3 minutes for k0sctl to connect each node, install k0s and connect the nodes together to form a cluster.</p>"},{"location":"examples/rook-ceph/#5-access-k0s-cluster","title":"5. Access k0s cluster","text":"<p>To access your new cluster remotely, you can use k0sctl to fetch kubeconfig and use that with kubectl or Lens.</p> <pre><code>k0sctl kubeconfig --config k0sctl.yaml &gt; kubeconfig\nexport KUBECONFIG=$PWD/kubeconfig\nkubectl get nodes\n</code></pre> <p>The other option is to login to your controller node and use the k0s in-built kubectl to access the cluster. Then you don't need to worry about kubeconfig (k0s takes care of that automatically).</p> <pre><code>ssh -i aws.pem &lt;username&gt;@&lt;ip-address&gt;\nsudo k0s kubectl get nodes\n</code></pre>"},{"location":"examples/rook-ceph/#6-deploy-rook","title":"6. Deploy Rook","text":"<p>To get started with Rook, let's first clone the Rook GitHub repo:</p> <pre><code>git clone --single-branch --branch release-1.7 https://github.com/rook/rook.git\ncd rook/cluster/examples/kubernetes/ceph\n</code></pre> <p>We will use mostly the default Rook configuration. However, k0s kubelet directory must be configured in <code>operator.yaml</code> like this</p> <pre><code>ROOK_CSI_KUBELET_DIR_PATH: \"/var/lib/k0s/kubelet\"\n</code></pre> <p>To create the resources, which are needed by the Rook\u2019s Ceph operator, run</p> <pre><code>kubectl apply -f crds.yaml -f common.yaml -f operator.yaml\n</code></pre> <p>Now you should see the operator running. Check them with</p> <pre><code>kubectl get pods -n rook-ceph\n</code></pre>"},{"location":"examples/rook-ceph/#7-deploy-ceph-cluster","title":"7. Deploy Ceph Cluster","text":"<p>Then you can proceed to create a Ceph cluster. Ceph will use the three EBS volumes attached to the worker nodes:</p> <pre><code>kubectl apply -f cluster.yaml\n</code></pre> <p>It takes some minutes to prepare the volumes and create the cluster. Once this is completed you should see the following output:</p> <pre><code>kubectl get pods -n rook-ceph\n</code></pre> <pre><code>NAME                                                         READY   STATUS      RESTARTS   AGE\ncsi-cephfsplugin-nhxc8                                       3/3     Running     0          2m48s\ncsi-cephfsplugin-provisioner-db45f85f5-ldhjp                 6/6     Running     0          2m48s\ncsi-cephfsplugin-provisioner-db45f85f5-sxfm8                 6/6     Running     0          2m48s\ncsi-cephfsplugin-tj2bh                                       3/3     Running     0          2m48s\ncsi-cephfsplugin-z2rrl                                       3/3     Running     0          2m48s\ncsi-rbdplugin-5q7gq                                          3/3     Running     0          2m49s\ncsi-rbdplugin-8sfpd                                          3/3     Running     0          2m49s\ncsi-rbdplugin-f2xdz                                          3/3     Running     0          2m49s\ncsi-rbdplugin-provisioner-d85cbdb48-g6vck                    6/6     Running     0          2m49s\ncsi-rbdplugin-provisioner-d85cbdb48-zpmvr                    6/6     Running     0          2m49s\nrook-ceph-crashcollector-ip-172-31-0-76-64cb4c7775-m55x2     1/1     Running     0          45s\nrook-ceph-crashcollector-ip-172-31-13-183-654b46588d-djqsd   1/1     Running     0          2m57s\nrook-ceph-crashcollector-ip-172-31-15-5-67b68698f-gcjb7      1/1     Running     0          2m46s\nrook-ceph-mgr-a-5ffc65c874-8pxgv                             1/1     Running     0          58s\nrook-ceph-mon-a-ffcd85c5f-z89tb                              1/1     Running     0          2m59s\nrook-ceph-mon-b-fc8f59464-lgczk                              1/1     Running     0          2m46s\nrook-ceph-mon-c-69bd87b558-kl4nl                             1/1     Running     0          91s\nrook-ceph-operator-54cf7487d4-pl66p                          1/1     Running     0          4m57s\nrook-ceph-osd-0-dd4fd8f6-g6s9m                               1/1     Running     0          48s\nrook-ceph-osd-1-7c478c49c4-gkqml                             1/1     Running     0          47s\nrook-ceph-osd-2-5b887995fd-26492                             1/1     Running     0          46s\nrook-ceph-osd-prepare-ip-172-31-0-76-6b5fw                   0/1     Completed   0          28s\nrook-ceph-osd-prepare-ip-172-31-13-183-cnkf9                 0/1     Completed   0          25s\nrook-ceph-osd-prepare-ip-172-31-15-5-qc6pt                   0/1     Completed   0          23s\n</code></pre>"},{"location":"examples/rook-ceph/#8-configure-ceph-block-storage","title":"8. Configure Ceph block storage","text":"<p>Before Ceph can provide storage to your cluster, you need to create a <code>ReplicaPool</code> and a <code>StorageClass</code>. In this example, we use the default configuration to create the block storage.</p> <pre><code>kubectl apply -f ./csi/rbd/storageclass.yaml\n</code></pre>"},{"location":"examples/rook-ceph/#9-request-storage","title":"9. Request storage","text":"<p>Create a new manifest file <code>mongo-pvc.yaml</code> with the following content:</p> <pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: mongo-pvc\nspec:\n  storageClassName: rook-ceph-block\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 2Gi\n</code></pre> <p>This will create Persistent Volume Claim (PVC) to request a 2 GB block storage from Ceph. Provisioning will be done dynamically. You can define the block size freely as long as it fits to the available storage size.</p> <pre><code>kubectl apply -f mongo-pvc.yaml\n</code></pre> <p>You can now check the status of your PVC:</p> <pre><code>kubectl get pvc\n</code></pre> <p>When the PVC gets the requested volume reserved (bound), it should look like this:</p> <pre><code>kubectl get pvc\n</code></pre> <pre><code>NAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE\nmongo-pvc   Bound    pvc-08337736-65dd-49d2-938c-8197a8871739   2Gi        RWO            rook-ceph-block   6s\n</code></pre>"},{"location":"examples/rook-ceph/#10-deploy-an-example-application","title":"10. Deploy an example application","text":"<p>Let's deploy a MongoDB database to verify the Ceph storage. Create a new file <code>mongo.yaml</code> with the following content:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mongo\nspec:\n  selector:\n    matchLabels:\n      app: mongo\n  template:\n    metadata:\n      labels:\n        app: mongo\n    spec:\n      containers:\n      - image: mongo:4.0\n        name: mongo\n        ports:\n        - containerPort: 27017\n          name: mongo\n        volumeMounts:\n        - name: mongo-persistent-storage\n          mountPath: /data/db\n      volumes:\n      - name: mongo-persistent-storage\n        persistentVolumeClaim:\n          claimName: mongo-pvc\n</code></pre> <p>Deploy the database:</p> <pre><code>kubectl apply -f mongo.yaml\n</code></pre>"},{"location":"examples/rook-ceph/#11-access-the-application","title":"11. Access the application","text":"<p>Open the MongoDB shell using the MongoDB pod:</p> <pre><code>kubectl get pods\n</code></pre> <pre><code>NAME                    READY   STATUS    RESTARTS   AGE\nmongo-b87cbd5cc-4wx8t   1/1     Running   0          76s\n</code></pre> <pre><code>kubectl exec -it mongo-b87cbd5cc-4wx8t -- mongo\n</code></pre> <p>Create a DB and insert some data:</p> <pre><code>&gt; use testDB\nswitched to db testDB\n&gt; db.testDB.insertOne( {name: \"abc\", number: 123  })\n{\n  \"acknowledged\" : true,\n  \"insertedId\" : ObjectId(\"60815690a709d344f83b651d\")\n}\n&gt; db.testDB.insertOne( {name: \"bcd\", number: 234  })\n{\n  \"acknowledged\" : true,\n  \"insertedId\" : ObjectId(\"6081569da709d344f83b651e\")\n}\n</code></pre> <p>Read the data:</p> <pre><code>&gt; db.getCollection(\"testDB\").find()\n{ \"_id\" : ObjectId(\"60815690a709d344f83b651d\"), \"name\" : \"abc\", \"number\" : 123 }\n{ \"_id\" : ObjectId(\"6081569da709d344f83b651e\"), \"name\" : \"bcd\", \"number\" : 234 }\n&gt;\n</code></pre> <p>You can also try to restart the MongoDB pod or restart the worker nodes to verity that the storage is persistent.</p>"},{"location":"examples/rook-ceph/#12-clean-up","title":"12. Clean-up","text":"<p>You can use Terraform to take down the virtual machines:</p> <pre><code>terraform destroy\n</code></pre> <p>Remember to delete the EBS volumes separately.</p>"},{"location":"examples/rook-ceph/#conclusions","title":"Conclusions","text":"<p>You have now created a replicated Ceph storage for k0s. All your data is stored to multiple disks at the same time so you have a fault-tolerant solution. You also have enabled dynamic provisioning. Your applications can request the available storage without a manual creation of the persistent volumes each time.</p> <p>This was just one example to deploy distributed storage to k0s cluster using an operator. You can easily use different Kubernetes storage solutions with k0s.</p>"},{"location":"examples/traefik-ingress/","title":"Traefik Ingress Controller","text":""},{"location":"examples/traefik-ingress/#installing-traefik-ingress-controller","title":"Installing Traefik Ingress Controller","text":"<p>You can configure k0s with the Traefik Ingress Controller, a MetalLB service load balancer, and deploy the Traefik Dashboard using a service sample. To do this you leverage Helm's extensible bootstrapping functionality to add the correct extensions to the <code>k0s.yaml</code> file during cluster configuration.</p>"},{"location":"examples/traefik-ingress/#1-configure-k0syaml","title":"1. Configure k0s.yaml","text":"<p>Configure k0s to install Traefik and MetalLB during cluster bootstrapping by adding their Helm charts as extensions in the k0s configuration file (<code>k0s.yaml</code>).</p> <p>Note:</p> <p>A good practice is to have a small range of IP addresses that are addressable on your network, preferably outside the assignment pool your DHCP server allocates (though any valid IP range should work locally on your machine). Providing an addressable range allows you to access your load balancer and Ingress services from anywhere on your local network.</p> <pre><code>extensions:\n  helm:\n    repositories:\n    - name: traefik\n      url: https://traefik.github.io/charts\n    - name: bitnami\n      url: https://charts.bitnami.com/bitnami\n    charts:\n    - name: traefik\n      chartname: traefik/traefik\n      version: \"20.5.3\"\n      namespace: default\n    - name: metallb\n      chartname: bitnami/metallb\n      version: \"2.5.4\"\n      namespace: default\n      values: |\n        configInline:\n          address-pools:\n          - name: generic-cluster-pool\n            protocol: layer2\n            addresses:\n            - 192.168.0.5-192.168.0.10\n</code></pre>"},{"location":"examples/traefik-ingress/#2-retrieve-the-load-balancer-ip","title":"2. Retrieve the Load Balancer IP","text":"<p>After you start your cluster, run <code>kubectl get all</code> to confirm the deployment of Traefik and MetalLB. The command should return a response with the <code>metallb</code> and <code>traefik</code> resources, along with a service load balancer that has an assigned <code>EXTERNAL-IP</code>.</p> <pre><code>kubectl get all\n</code></pre> <p>Output:</p> <pre><code>NAME                                                 READY   STATUS    RESTARTS   AGE\npod/metallb-1607085578-controller-864c9757f6-bpx6r   1/1     Running   0          81s\npod/metallb-1607085578-speaker-245c2                 1/1     Running   0          60s\npod/traefik-1607085579-77bbc57699-b2f2t              1/1     Running   0          81s\n\nNAME                         TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE\nservice/kubernetes           ClusterIP      10.96.0.1        &lt;none&gt;           443/TCP                      96s\nservice/traefik-1607085579   LoadBalancer   10.105.119.102   192.168.0.5      80:32153/TCP,443:30791/TCP   84s\n\nNAME                                        DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE\ndaemonset.apps/metallb-1607085578-speaker   1         1         1       1            1           kubernetes.io/os=linux   87s\n\nNAME                                            READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/metallb-1607085578-controller   1/1     1            1           87s\ndeployment.apps/traefik-1607085579              1/1     1            1           84s\n\nNAME                                                       DESIRED   CURRENT   READY   AGE\nreplicaset.apps/metallb-1607085578-controller-864c9757f6   1         1         1       81s\nreplicaset.apps/traefik-1607085579-77bbc57699              1         1         1       81s\n</code></pre> <p>Take note of the <code>EXTERNAL-IP</code> given to the <code>service/traefik-n</code> load balancer. In this example, <code>192.168.0.5</code> has been assigned and can be used to access services via the Ingress proxy:</p> <pre><code>NAME                         TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE\nservice/traefik-1607085579   LoadBalancer   10.105.119.102   192.168.0.5      80:32153/TCP,443:30791/TCP   84s\n</code></pre> <p>Receiving a 404 response here is normal, as you've not configured any Ingress resources to respond yet:</p> <pre><code>curl http://192.168.0.5\n</code></pre> <pre><code>404 page not found\n</code></pre>"},{"location":"examples/traefik-ingress/#3-deploy-and-access-the-traefik-dashboard","title":"3. Deploy and access the Traefik Dashboard","text":"<p>With an available and addressable load balancer present on your cluster, now you can quickly deploy the Traefik dashboard and access it from anywhere on your LAN (assuming that MetalLB is configured with an addressable range).</p> <ol> <li> <p>Create the Traefik Dashboard IngressRoute in a YAML file:</p> <pre><code>apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: dashboard\nspec:\n  entryPoints:\n    - web\n  routes:\n    - match: PathPrefix(`/dashboard`) || PathPrefix(`/api`)\n      kind: Rule\n      services:\n        - name: api@internal\n          kind: TraefikService\n</code></pre> </li> <li> <p>Deploy the resource:</p> <pre><code>kubectl apply -f traefik-dashboard.yaml\n</code></pre> <p>Output:</p> <pre><code>ingressroute.traefik.containo.us/dashboard created\n</code></pre> <p>At this point you should be able to access the dashboard using the <code>EXTERNAL-IP</code> that you noted above by visiting <code>http://192.168.0.5/dashboard/</code> in your browser:</p> <p></p> </li> <li> <p>Create a simple <code>whoami</code> Deployment, Service, and Ingress manifest:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: whoami-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: whoami\n  template:\n    metadata:\n      labels:\n        app: whoami\n    spec:\n      containers:\n      - name: whoami-container\n        image: containous/whoami\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: whoami-service\nspec:\n  ports:\n  - name: http\n    targetPort: 80\n    port: 80\n  selector:\n    app: whoami\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: whoami-ingress\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /whoami\n        pathType: Exact\n        backend:\n          service:\n            name: whoami-service\n            port:\n              number: 80\n</code></pre> </li> <li> <p>Apply the manifests:</p> <pre><code>kubectl apply -f whoami.yaml\n</code></pre> <p>Output:</p> <pre><code>deployment.apps/whoami-deployment created\nservice/whoami-service created\ningress.networking.k8s.io/whoami-ingress created\n</code></pre> </li> <li> <p>Test the ingress and service:</p> <pre><code>curl http://192.168.0.5/whoami\n</code></pre> <p>Output:</p> <pre><code>Hostname: whoami-deployment-85bfbd48f-7l77c\nIP: 127.0.0.1\nIP: ::1\nIP: 10.244.214.198\nIP: fe80::b049:f8ff:fe77:3e64\nRemoteAddr: 10.244.214.196:34858\nGET /whoami HTTP/1.1\nHost: 192.168.0.5\nUser-Agent: curl/7.68.0\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 192.168.0.82\nX-Forwarded-Host: 192.168.0.5\nX-Forwarded-Port: 80\nX-Forwarded-Proto: http\nX-Forwarded-Server: traefik-1607085579-77bbc57699-b2f2t\nX-Real-Ip: 192.168.0.82\n</code></pre> </li> </ol>"},{"location":"examples/traefik-ingress/#further-details","title":"Further details","text":"<p>With the Traefik Ingress Controller it is possible to use third party tools, such as ngrok, to go further and expose your load balancer to the world. In doing this you enable dynamic certificate provisioning through Let's Encrypt, using either cert-manager or Traefik's own built-in ACME provider.</p>"},{"location":"examples/oidc/oidc-cluster-configuration/","title":"OpenID Connect","text":""},{"location":"examples/oidc/oidc-cluster-configuration/#openid-connect-integration","title":"OpenID Connect integration","text":"<p>Developers use <code>kubectl</code> to access Kubernetes clusters. By default <code>kubectl</code> uses a certificate to authenticate to the Kubernetes API. This means that when multiple developers need to access a cluster, the certificate needs to be shared. Sharing the credentials to access a Kubernetes cluster presents a significant security problem. Compromise of the certificate is very easy and the consequences can be catastrophic.</p> <p>In this tutorial, we walk through how to set up your Kubernetes cluster to add Single Sign-On support for kubectl using OpenID Connect (OIDC).</p>"},{"location":"examples/oidc/oidc-cluster-configuration/#openid-connect-based-authentication","title":"OpenID Connect based authentication","text":"<p>OpenID Connect can be enabled by modifying k0s configuration (using extraArgs).</p>"},{"location":"examples/oidc/oidc-cluster-configuration/#configuring-k0s-overview","title":"Configuring k0s: overview","text":"<p>There are list of arguments for the kube-api that allows us to manage OIDC based authentication</p> Parameter Description Example Required <code>--oidc-issuer-url</code> URL of the provider which allows the API server to discover public signing keys. Only URLs which use the <code>https://</code> scheme are accepted.  This is typically the provider's discovery URL without a path, for example \"https://accounts.google.com\" or \"https://login.salesforce.com\".  This URL should point to the level below .well-known/openid-configuration If the discovery URL is <code>https://accounts.google.com/.well-known/openid-configuration</code>, the value should be <code>https://accounts.google.com</code> Yes <code>--oidc-client-id</code> A client id that all tokens must be issued for. kubernetes Yes <code>--oidc-username-claim</code> JWT claim to use as the user name. By default <code>sub</code>, which is expected to be a unique identifier of the end user. Admins can choose other claims, such as <code>email</code> or <code>name</code>, depending on their provider. However, claims other than <code>email</code> will be prefixed with the issuer URL to prevent naming clashes with other plugins. sub No <code>--oidc-username-prefix</code> Prefix prepended to username claims to prevent clashes with existing names (such as <code>system:</code> users). For example, the value <code>oidc:</code> will create usernames like <code>oidc:jane.doe</code>. If this flag isn't provided and <code>--oidc-username-claim</code> is a value other than <code>email</code> the prefix defaults to <code>( Issuer URL )#</code> where <code>( Issuer URL )</code> is the value of <code>--oidc-issuer-url</code>. The value <code>-</code> can be used to disable all prefixing. <code>oidc:</code> No <code>--oidc-groups-claim</code> JWT claim to use as the user's group. If the claim is present it must be an array of strings. groups No <code>--oidc-groups-prefix</code> Prefix prepended to group claims to prevent clashes with existing names (such as <code>system:</code> groups). For example, the value <code>oidc:</code> will create group names like <code>oidc:engineering</code> and <code>oidc:infra</code>. <code>oidc:</code> No <code>--oidc-required-claim</code> A key=value pair that describes a required claim in the ID Token. If set, the claim is verified to be present in the ID Token with a matching value. Repeat this flag to specify multiple claims. <code>claim=value</code> No <code>--oidc-ca-file</code> The path to the certificate for the CA that signed your identity provider's web certificate.  Defaults to the host's root CAs. <code>/etc/kubernetes/ssl/kc-ca.pem</code> No <p>To set up bare minimum example we need to use:</p> <ul> <li>oidc-issuer-url</li> <li>oidc-client-id</li> <li>oidc-username-claim</li> </ul>"},{"location":"examples/oidc/oidc-cluster-configuration/#configuring-k0s-prerequisites","title":"Configuring k0s: prerequisites","text":"<p>You will require:</p> <ul> <li>issuer-url</li> <li>client-id</li> <li>username-claim</li> </ul> <p>Please, refer to providers configuration guide or your selected OIDC provider's own documentation (we don't cover all of them in k0s docs).</p>"},{"location":"examples/oidc/oidc-cluster-configuration/#configuration-example","title":"Configuration example","text":"<pre><code>apiVersion: k0s.k0sproject.io/v1beta1\nkind: ClusterConfig\nspec:\n  api:\n    extraArgs:\n      oidc-issuer-url: &lt;issuer-url&gt;\n      oidc-client-id: &lt;client-id&gt;\n      oidc-username-claim: email # we use email token claim field as a username\n</code></pre> <p>Use the configuration as a starting point. Continue with configuration guide for finishing k0s cluster installation.</p>"},{"location":"examples/oidc/oidc-cluster-configuration/#openid-connect-based-authorisation","title":"OpenID Connect based authorisation","text":"<p>There are two alternative options to implement authorization</p>"},{"location":"examples/oidc/oidc-cluster-configuration/#provider-based-role-mapping","title":"Provider based role mapping","text":"<p>Please refer to the providers configuration guide. Generally speaking, using the <code>oidc-groups-claim</code> argument let's you specify which token claim is used a list of RBAC roles for a given user. You still need somehow sync up that data between your OIDC provider and kube-api RBAC system.</p>"},{"location":"examples/oidc/oidc-cluster-configuration/#manual-roles-management","title":"Manual roles management","text":"<p>To use manual role management for each user you will need to create a role and role-binding for each new user within k0s cluster. The role can be shared for all the users. Role example:</p> <pre><code>---\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  namespace: default\n  name: dev-role\nrules:\n- apiGroups: [\"*\"]\n  resources: [\"*\"]\n  verbs: [\"*\"]\n</code></pre> <p>RoleBinding example:</p> <pre><code>kind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: dev-role-binding\nsubjects:\n  - kind: User\n    name: &lt;provider side user id&gt;\nroleRef:\n  kind: Role\n  name: dev-role\n  apiGroup: rbac.authorization.k8s.io\n</code></pre> <p>The provided Role example is an all-inclusive and comprehensive example and should be tuned up to your actual requirements.</p>"},{"location":"examples/oidc/oidc-cluster-configuration/#kubeconfig-management","title":"kubeconfig management","text":"<p>NB: it's not safe to provide full content of the <code>/var/lib/k0s/pki/admin.conf</code> to the end-user. Instead, create a user specific kubeconfig with limited permissions.</p> <p>The authorization side of the kubeconfig management is described in provider specific guides. Use <code>/var/lib/k0s/pki/admin.conf</code> as a template for cluster specific kubeconfig.</p>"},{"location":"examples/oidc/oidc-cluster-configuration/#references","title":"References","text":"<p>OAuth2 spec Kubernetes authorization system (RBAC) Kubernetes authenticating system</p>"},{"location":"examples/oidc/oidc-provider-configuration/","title":"Oidc provider configuration","text":""},{"location":"examples/oidc/oidc-provider-configuration/#providers","title":"Providers","text":"<p>We use Google Cloud as a provider for the sake of the example. Check your vendor documentation in case if you use some other vendor.</p>"},{"location":"examples/oidc/oidc-provider-configuration/#notes-on-stand-alone-providers","title":"Notes on stand-alone providers","text":"<p>If you are using stand-alone OIDC provider, you might need to specify <code>oidc-ca-file</code> argument for the kube-api.</p>"},{"location":"examples/oidc/oidc-provider-configuration/#google-cloud","title":"Google Cloud","text":"<p>We use k8s-oidc-helper tool to create proper kubeconfig user record.</p> <p>The issuer URL for the Google cloud is <code>https://accounts.google.com</code></p>"},{"location":"examples/oidc/oidc-provider-configuration/#creating-an-application","title":"Creating an application","text":"<ul> <li>Go to the Google Cloud Dashboard</li> <li>Create a new project in your organization</li> <li>Go to the \"Credentials\" page</li> <li>Create \"OAuth consent screen\"</li> </ul>"},{"location":"examples/oidc/oidc-provider-configuration/#creating-a-user-credentials","title":"Creating a user credentials","text":"<ul> <li>Go to the Google Cloud Dashboard</li> <li>Go to the \"Credentials\" page</li> <li>Create new credentials. Select \"OAuth client ID\" as a type.</li> <li>Select \"Desktop\" app as an application type.</li> <li>Save client ID and client secret</li> </ul>"},{"location":"examples/oidc/oidc-provider-configuration/#creating-kubeconfig-user-record","title":"Creating kubeconfig user record","text":"<p>Use the command and follow the instructions:</p> <pre><code>k8s-oidc-helper --client-id=&lt;CLIENT_ID&gt; \\\n  --client-secret=&lt;CLIENT_SECRET&gt; \\\n  --write=true\n</code></pre>"},{"location":"examples/oidc/oidc-provider-configuration/#using-kubelogin","title":"Using kubelogin","text":"<p>For other OIDC providers it is possible to use <code>kubelogin</code> plugin. Please refer to the setup guide for details.</p>"},{"location":"examples/oidc/oidc-provider-configuration/#google-cloud-example-using-kubelogin","title":"Google Cloud example using <code>kubelogin</code>","text":"<pre><code>kubectl oidc-login setup \\\n  --oidc-issuer-url=https://accounts.google.com \\\n  --oidc-client-id=&lt;CLIENT_ID&gt; \\\n  --oidc-client-secret=&lt;CLIENT_SECRET&gt;\n\n  kubectl config set-credentials oidc \\\n  --exec-api-version=client.authentication.k8s.io/v1beta1 \\\n  --exec-command=kubectl \\\n  --exec-arg=oidc-login \\\n  --exec-arg=get-token \\\n  --exec-arg=--oidc-issuer-url=https://accounts.google.com \\\n  --exec-arg=--oidc-client-id=&lt;CLIENT_ID&gt;  \\\n  --exec-arg=--oidc-client-secret=&lt;CLIENT_SECRET&gt;\n</code></pre> <p>You can switch the current context to oidc.</p> <p><code>kubectl config set-context --current --user=oidc</code></p>"},{"location":"governance/cncf/gtr/","title":"General Technical Review","text":""},{"location":"governance/cncf/gtr/#general-technical-review-gtr","title":"General Technical Review (GTR)","text":"<p>This document collects information for the CNCF General Technical Review. It is built to support the k0s CNCF Sandbox application but will be a living document that we update regularly.</p> <p>As we are currently applying for the sandbox level, the document only covers the GTR's \u201cDay 0\u201d phase.</p>"},{"location":"governance/cncf/gtr/#scope","title":"Scope","text":""},{"location":"governance/cncf/gtr/#roadmap-process","title":"Roadmap process","text":"<p>The k0s roadmap process is a collaborative effort to align with user needs, community feedback, and emerging trends. We prioritize initiatives that simplify Kubernetes operations and extend its capabilities for far-edge, IoT, and disconnected environments. The roadmap is a living document, refined iteratively based on technical feasibility, testing, and industry shifts. By emphasizing usability, automation, and feedback-driven iterations, we ensure that k0s continues to lead in lightweight, scalable Kubernetes solutions.</p>"},{"location":"governance/cncf/gtr/#target-personas","title":"Target personas","text":""},{"location":"governance/cncf/gtr/#devops-engineers","title":"DevOps Engineers","text":"<ul> <li>Focused on managing Kubernetes clusters efficiently.</li> <li>Seek simplicity in deployment, maintenance, and scaling.</li> <li>Prioritize automation and minimize operational overhead.</li> </ul>"},{"location":"governance/cncf/gtr/#platform-engineers","title":"Platform Engineers","text":"<ul> <li>Responsible for building and maintaining internal platforms on top of Kubernetes.</li> <li>Interested in integrating k0s into CI/CD pipelines, monitoring systems, and other tooling.</li> </ul>"},{"location":"governance/cncf/gtr/#iot-and-edge-architects","title":"IoT and Edge Architects","text":"<ul> <li>Working on deploying Kubernetes at the far edge.</li> <li>Require lightweight, resource-efficient solutions for disconnected or resource-constrained environments.</li> </ul>"},{"location":"governance/cncf/gtr/#cloud-native-developers","title":"Cloud-Native Developers","text":"<ul> <li>Building and deploying applications on Kubernetes.</li> <li>Need a developer-friendly experience with minimal setup and maximum portability.</li> </ul>"},{"location":"governance/cncf/gtr/#system-integrators","title":"System Integrators","text":"<ul> <li>Designing bespoke solutions that leverage Kubernetes in varied environments, including on-premises and hybrid setups.</li> <li>Value flexibility and compatibility with existing tools and standards.</li> </ul>"},{"location":"governance/cncf/gtr/#it-operations-teams","title":"IT Operations Teams","text":"<ul> <li>Managing infrastructure at scale across data centers, cloud, and edge locations.</li> <li>Seek reliability, scalability, and tools to simplify multi-cluster operations.</li> </ul>"},{"location":"governance/cncf/gtr/#primary-use-cases","title":"Primary use cases","text":"<p>k0s is a streamlined, self-contained Kubernetes distribution designed to serve as a portable and lightweight foundational core for Kubernetes environments. It simplifies deployment and management, while maintaining the flexibility to build out additional functionality. As such, it's tailor-made for a variety of use cases, including:</p>"},{"location":"governance/cncf/gtr/#edge-computing-and-iot","title":"Edge Computing and IoT","text":"<p>Deploying Kubernetes in resource-constrained, far-edge environments where lightweight and efficient solutions are critical. Ideal for managing IoT devices, disconnected edge nodes, and remote locations. k0s also support air gapped environments by being able to automatically load container image bundles and having zero dependencies.</p>"},{"location":"governance/cncf/gtr/#cloud-native-application-hosting","title":"Cloud-Native Application Hosting","text":"<p>Enabling developers to run containerized applications with minimal operational complexity. Suitable for both small-scale setups and large-scale production workloads.</p>"},{"location":"governance/cncf/gtr/#devtest-environment","title":"Dev/Test Environment","text":"<p>Providing a quick, easy-to-set-up Kubernetes environment for development, testing, and CI/CD pipelines. Allows developers to spin up Kubernetes clusters locally or in isolated environments without significant overhead.</p>"},{"location":"governance/cncf/gtr/#centralized-control-for-distributed-clusters","title":"Centralized Control for Distributed Clusters","text":"<p>Offering the ability to centrally manage control planes while operating clusters in remote or disconnected locations. Ensures operational simplicity across distributed systems.</p>"},{"location":"governance/cncf/gtr/#heterogeneous-environments","title":"Heterogeneous environments","text":"<p>Running Kubernetes efficiently on bare-metal servers or in hybrid cloud/on-premises environments. Tailored for teams looking to minimize dependency on external cloud services. Focus on lightweight deployment without the need for heavy dependencies on external cloud services.</p>"},{"location":"governance/cncf/gtr/#isolated-control-planes","title":"Isolated control planes","text":"<p>k0s uses konnectivity by default and is therefore a good fit for environments where control planes and worker nodes are isolated. This architecture is good fit for e.g. Edge type use cases or where users want to cenrtalize their control planes in general.</p>"},{"location":"governance/cncf/gtr/#unsupported-use-cases","title":"Unsupported use cases","text":"<p>While k0s provides a self-contained core for Kubernetes operations, it does not aim to be a feature-complete \"all-in-one\" solution. In particular, the following are out of scope:</p>"},{"location":"governance/cncf/gtr/#bundling-of-higher-level-ecosystem-components","title":"Bundling of higher-level ecosystem components","text":"<p>k0s does not include additional tools such as ingress controllers, service meshes, or advanced observability capabilities by default. Cluster administrators are expected to install and configure these components separately using the extension points provided by k0s, according to their unique requirements.</p>"},{"location":"governance/cncf/gtr/#being-a-turnkey-solution","title":"Being a \"Turnkey Solution\"","text":"<p>k0s avoids bundling excessive features to remain lightweight and customizable. It is best suited for those who value flexibility over out-of-the-box completeness.</p>"},{"location":"governance/cncf/gtr/#intended-types-of-organizations","title":"Intended types of organizations","text":"<p>The intended types of organizations for using k0s are those that prioritize simplicity, flexibility, and efficiency in Kubernetes deployments. Some examples:</p>"},{"location":"governance/cncf/gtr/#small-and-medium-sized-businesses-smbs","title":"Small and Medium-Sized Businesses (SMBs)","text":"<ul> <li>Looking for a straightforward, cost-effective Kubernetes solution.</li> <li>Often lack dedicated Kubernetes experts and benefit from k0s's ease of deployment and management.</li> </ul>"},{"location":"governance/cncf/gtr/#edge-computing-and-iot-organizations","title":"Edge Computing and IoT Organizations","text":"<ul> <li>Deploying Kubernetes at the far edge to manage IoT devices, industrial equipment, or remote sites.</li> <li>Require lightweight, resource-efficient solutions that can operate in disconnected or low-bandwidth environments.</li> </ul>"},{"location":"governance/cncf/gtr/#software-development-teams-and-startups","title":"Software Development Teams and Startups","text":"<ul> <li>Need fast, simple Kubernetes clusters for development, testing, and CI/CD pipelines.</li> <li>Value the minimal overhead of k0s for prototyping and scaling quickly.</li> </ul>"},{"location":"governance/cncf/gtr/#enterprises-with-distributed-operations","title":"Enterprises with Distributed Operations","text":"<ul> <li>Manage hybrid setups with centralized control planes and distributed worker nodes across on-premises, cloud, and edge environments.</li> <li>Use k0s to simplify cluster management across multiple locations.</li> </ul>"},{"location":"governance/cncf/gtr/#organizations-in-regulated-industries","title":"Organizations in Regulated Industries","text":"<ul> <li>Operate Kubernetes in on-premises or air-gapped environments due to regulatory requirements.</li> <li>'s lean design of reducing unnecessary complexity, making it easier to audit and verify compliance with regulatory standards</li> </ul>"},{"location":"governance/cncf/gtr/#educational-and-research-institutions","title":"Educational and Research Institutions","text":"<ul> <li>Need Kubernetes clusters for experimentation, training, or academic research.</li> <li>Value k0s's simplicity for non-commercial use cases and resource-constrained setups.</li> </ul>"},{"location":"governance/cncf/gtr/#software-vendors-and-system-integrators","title":"Software Vendors and System Integrators","text":"<ul> <li>Deliver Kubernetes-based solutions to clients across various industries.</li> <li>Bundle and package k0s with their applications to create \"Kubernetes appliances\".</li> <li>Ship pre-configured, self-contained solutions for customers without requiring Kubernetes expertise.</li> <li>Appreciate k0s's ease of deployment, lightweight architecture, and flexibility to adapt to different environments.</li> <li>Benefit from its embedded-friendly design, making it ideal for turnkey application deployments in diverse scenarios.</li> </ul>"},{"location":"governance/cncf/gtr/#completed-end-user-research","title":"Completed end-user research","text":"<p>No comprehensive end-user research has been conducted.</p>"},{"location":"governance/cncf/gtr/#usability","title":"Usability","text":"<p>k0s simplifies Kubernetes operations by delivering the entire distribution as a single, self-contained binary. This design ensures:</p> <ol> <li>Streamlined Installation<ul> <li>Deploy Kubernetes with a single command, without the need to manage multiple dependencies or configurations.</li> </ul> </li> <li>Portability and Flexibility<ul> <li>The binary can be easily copied and run on various systems, making it ideal for edge devices, bare-metal servers, or cloud environments.</li> </ul> </li> <li>Simplified Upgrades<ul> <li>Upgrading k0s is as easy as replacing the binary, reducing downtime and operational complexity. To help in orchestrating the cluster upgrade k0s comes with a component called autopilot that automates the node upgrade orchestration, including the needed node draining and coordination.</li> </ul> </li> <li>Reduced Operational Overhead<ul> <li>No need for additional packaging or complex tooling \u2014 everything needed to run Kubernetes is included in one binary.</li> </ul> </li> <li>Developer and Operator Friendly<ul> <li>The single-binary approach removes barriers to entry, enabling faster adoption and simpler workflows for teams of any size.</li> </ul> </li> </ol> <p>As such, k0s provides a conformant Kubernetes which means any ecosystem add-on works on k0s.</p>"},{"location":"governance/cncf/gtr/#design","title":"Design","text":""},{"location":"governance/cncf/gtr/#design-principles-best-practices","title":"Design principles &amp; best practices","text":""},{"location":"governance/cncf/gtr/#design-principles","title":"Design Principles","text":"<ol> <li>Simplicity First<ul> <li>k0s is designed to minimize complexity for both users and operators. Packaging Kubernetes as a single binary and automating common tasks eliminates unnecessary configuration overhead.</li> </ul> </li> <li>Lightweight and Efficient<ul> <li>Optimized for resource-constrained environments, k0s ensures minimal system resource usage, making it ideal for edge computing, IoT, and small-scale deployments.</li> </ul> </li> <li>Decoupled and Modular Architecture<ul> <li>k0s separates the control plane and worker components, allowing flexible deployment topologies. It supports running control planes centrally while distributing worker nodes across diverse locations.</li> </ul> </li> <li>Zero Friction, Zero Lock-In<ul> <li>k0s follows a vendor-neutral approach, ensuring users retain full control of their infrastructure. It avoids proprietary tooling, adhering to upstream Kubernetes standards.</li> </ul> </li> <li>Security by Default<ul> <li>Secure configurations are baked into k0s from the start, with features like automatic TLS management, disabling anonymous access etc.</li> </ul> </li> <li>Ease of Maintenance and Upgrades<ul> <li>The project prioritizes operational simplicity, with upgrades streamlined through single-binary replacements, embedded autopilot for upgrades, and minimal manual intervention.</li> </ul> </li> <li>Adaptability<ul> <li>Designed to run in diverse environments, from local development setups to far-edge and production-grade clusters.</li> </ul> </li> </ol>"},{"location":"governance/cncf/gtr/#best-practices","title":"Best Practices","text":"<ol> <li>Stay Aligned with Upstream Kubernetes<ul> <li>k0s is and will be 100% vanilla upstream Kubernetes.</li> </ul> </li> <li>Automate Wherever Possible<ul> <li>Automation of cluster configuration, control plane management, and other operational tasks ensures reliability and reduces human error.</li> </ul> </li> <li>Test for Real-World Use Cases<ul> <li>Every feature and release is tested in scenarios reflecting actual user environments, such as edge deployments, air-gapped setups, and hybrid clusters.</li> </ul> </li> <li>Community-Driven Development<ul> <li>Open communication with the user community drives prioritization and improvements, ensuring the project meets real-world needs.</li> </ul> </li> <li>Focus on Documentation<ul> <li>Clear and comprehensive documentation ensures users of all skill levels can deploy, manage, and scale k0s effectively.</li> </ul> </li> </ol>"},{"location":"governance/cncf/gtr/#identity-and-access-management","title":"Identity and Access Management","text":"<p>k0s being vanilla upstream Kubernetes thus it supports all the same things as Kubernetes does. By default, k0s only sets up certificate authentication but users can fully configure OIDC or webhook authentication when they need.</p>"},{"location":"governance/cncf/gtr/#compliance-requirements-implemented","title":"Compliance requirements implemented","text":""},{"location":"governance/cncf/gtr/#ha-requirements","title":"HA Requirements","text":"<ol> <li>Control Plane Redundancy<ul> <li>To achieve HA, the control plane (API server, etcd, controller manager, and scheduler) must be deployed in a redundant configuration:<ul> <li>Multiple Control Plane Nodes: At least three control plane nodes are recommended to ensure quorum and fault tolerance for etcd. In case kine is used with HA SQL database backend, 2 controller nodes are often sufficient.</li> <li>Load Balancer: A load balancer is required in front of the control plane nodes to distribute API traffic evenly and provide fail-over.<ul> <li>k0s offers an embedded control plane load balancer (CPLB) for use cases where the infrastructure/network does not provide easy ways to create load balancers on its own.</li> <li>K0s has a node-local (NLLB) for worker nodes to automatically re-route API connections to different nodes in case of failures.</li> </ul> </li> </ul> </li> </ul> </li> <li>Worker Node Scalability<ul> <li>Worker nodes operate independently of the control plane. In an HA setup:<ul> <li>Worker nodes can connect to multiple control plane endpoints for resilience.</li> <li>Horizontal scaling of worker nodes ensures workload availability and supports increased demand.</li> </ul> </li> </ul> </li> <li>Distributed etcd<ul> <li>etcd, the data store for Kubernetes, requires three or five instances for HA to maintain quorum.</li> <li>etcd instances are distributed across control plane nodes, ensuring data replication and consistency even if a node fails.</li> <li>k0s supports externally (from k0s point of view) managed etcd.</li> </ul> </li> <li>Kine<ul> <li>k0s also supports kine as etcd replacement thus offering users the ability to utilize externally managed HA databases as the control plane state storage.</li> </ul> </li> </ol>"},{"location":"governance/cncf/gtr/#resource-requirements","title":"Resource requirements","text":"<p>k0s is designed to be lightweight, making it suitable resource-constrained systems. Below is an overview of the resource requirements, including CPU, memory, storage, and networking considerations.</p>"},{"location":"governance/cncf/gtr/#minimum-memory-and-cpu-requirements","title":"Minimum Memory and CPU Requirements","text":"<p>The following table outlines the approximate minimum hardware requirements for different node roles:</p> Role Memory (RAM) Virtual CPU (vCPU) Controller Node 1 GB 1 vCPU Worker Node 0.5 GB 1 vCPU Controller + Worker 1 GB 1 vCPU <p>These values are approximations; actual requirements may vary based on workload and cluster size.</p>"},{"location":"governance/cncf/gtr/#controller-node-recommendations-for-larger-clusters","title":"Controller Node Recommendations for Larger Clusters","text":"<p>For larger clusters, the recommended resources for controller nodes are:</p> Number of Worker Nodes Number of Pods Recommended RAM Recommended vCPU Up to 10 Up to 1,000 1\u20132 GB 1\u20132 vCPU Up to 50 Up to 5,000 2\u20134 GB 2\u20134 vCPU Up to 100 Up to 10,000 4\u20138 GB 2\u20134 vCPU Up to 500 Up to 50,000 8\u201316 GB 4\u20138 vCPU Up to 1,000 Up to 100,000 16\u201332 GB 8\u201316 vCPU Up to 5,000 Up to 150,000 32\u201364 GB 16\u201332 vCPU <p>These recommendations help ensure optimal performance and stability for larger deployments.</p>"},{"location":"governance/cncf/gtr/#storage-requirements","title":"Storage Requirements","text":"<ul> <li>Controller Node: Approximately 0.5 GB for k0s components; minimum 0.5 GB required.</li> <li>Worker Node: Approximately 1.3 GB for k0s components; minimum 1.6 GB required.</li> <li>Controller + Worker: Approximately 1.7 GB for k0s components; minimum 2.0 GB required.</li> </ul> <p>It's recommended to use SSDs for optimal storage performance, as cluster latency and throughput are sensitive to storage performance.</p>"},{"location":"governance/cncf/gtr/#networking-requirements","title":"Networking Requirements","text":"<p>k0s requires certain network ports to be open for proper communication between components. Detailed information on the required ports and protocols can be found in the k0s networking documentation.</p>"},{"location":"governance/cncf/gtr/#host-operating-system-and-architecture","title":"Host Operating System and Architecture","text":"<ul> <li>Operating Systems:<ul> <li>Linux (kernel version 4.3 or later)<ul> <li><code>x86_64</code></li> <li><code>aarch64</code></li> <li><code>armv7l</code></li> </ul> </li> <li>Windows Server 2019 (experimental)<ul> <li><code>x86_64</code></li> </ul> </li> </ul> </li> </ul> <p>Note: K0s is actively tested on the <code>armv7l</code> architecture, which is not currently done by upstream Kubernetes. This has enabled us to identify and resolve architecture-related issues that upstream Kubernetes did not detect, before they were included in a stable Kubernetes release.</p> <p>These specifications ensure compatibility across a wide range of hardware platforms.</p>"},{"location":"governance/cncf/gtr/#additional-considerations","title":"Additional Considerations","text":"<ul> <li>Operating System Dependencies: k0s strives to be as independent from the operating system as possible.</li> <li>The necessary kernel configurations and any external runtime dependencies are documented in the k0s system requirements.</li> </ul>"},{"location":"governance/cncf/gtr/#storage-requirements_1","title":"Storage requirements","text":""},{"location":"governance/cncf/gtr/#controller-node-storage","title":"Controller Node Storage","text":"<ul> <li>Storage for Kubernetes Control Plane:<ul> <li>Approximately 0.5 GB is required for k0s system components on a controller-only node.</li> <li>Persistent storage is essential for the etcd data store, which maintains the cluster\u2019s state.</li> <li>Recommended Storage:<ul> <li>SSD for improved etcd performance.</li> <li>At least 20 GB of free space for larger clusters with significant cluster state changes.</li> </ul> </li> </ul> </li> </ul>"},{"location":"governance/cncf/gtr/#worker-node-storage","title":"Worker Node Storage","text":"<ul> <li>Storage for Kubernetes Workloads:<ul> <li>Approximately 1.3 GB is required for k0s system components.</li> <li>Additional space is needed for container images, temporary files, and any application-specific storage.</li> </ul> </li> </ul>"},{"location":"governance/cncf/gtr/#api-design","title":"API Design","text":"<ol> <li>Kubernetes API Compatibility<ul> <li>k0s runs the upstream Kubernetes API server as-is, providing users with the standard Kubernetes API experience.</li> <li>This ensures seamless interaction with Kubernetes-native tools (e.g., <code>kubectl</code>, Helm, and CI/CD systems) and compatibility with Kubernetes custom resources.</li> </ul> </li> <li>Declarative API Model<ul> <li>Like Kubernetes, k0s uses a declarative API model, enabling users to define desired states for resources (e.g., deployments, services, and custom objects).</li> <li>The system continuously reconciles actual states with desired states, ensuring consistent and predictable behavior.</li> </ul> </li> <li>API Evolution and Versioning<ul> <li>The k0s API design follows Kubernetes\u2019 API versioning practices, supporting multiple API versions (e.g., <code>v1beta1</code>, <code>v1</code>) for gradual transitions and backward compatibility.<ul> <li>We currently support only <code>v1beta1</code> but are planning for the next version (<code>v2</code>)</li> </ul> </li> <li>Deprecated APIs are phased out according to Kubernetes release cycles, ensuring compatibility with upstream developments.</li> </ul> </li> </ol>"},{"location":"governance/cncf/gtr/#release-process","title":"Release process","text":"<p>The k0s project closely follows the upstream Kubernetes release cycle. The only difference in the Kubernetes release and maintenance schedule is that our initial release date is always a few weeks after the Kubernetes release date. This is because we build our version of k0s from the officially released Kubernetes version and need time to test the final version before shipping. ![][image1] The k0s version string consists of the Kubernetes version and the k0s version. For example:</p> <pre><code>v1.34.1+head\n</code></pre> <p>The Kubernetes version (v1.34.1) is the first part, and the last part (head) reflects the k0s version, which is built on top of the certain Kubernetes version.</p>"},{"location":"governance/cncf/gtr/#installation","title":"Installation","text":"<p>Here\u2019s an example of how to set a single node cluster:</p> <pre><code># export K0S_VERSION=v1.34.1+head\n# curl -sSfL https://github.com/k0sproject/k0s/releases/download/$K0S_VERSION/k0s-$K0S_VERSION-amd64 -o k0s\n# chmod u+x k0s\n# ./k0s install controller --single &amp;&amp; ./k0s start\n</code></pre> <p>Naturally, this will spin up k0s with the default configuration. In case the user needs to configure something, they can create a YAML document to describe the configuration:</p> <p>As part of the startup sequence, k0s performs a series of pre-flight checks. This ensures that the system meets the requirements, such as all required kernel modules are loaded, enough free disk capacity on the node, and so on. If the pre-flight checks fail, k0s will refuse to start unless it's explicitly told to, and the logs will clearly indicate why they failed.</p> <p>Additionally, users have the option to run the CNCF Certified Kubernetes Conformance test suite. This test suite is executed by the CI for each release (on <code>x86_64</code> and <code>aarch64</code>) and its results are made available as release artifacts.</p>"},{"location":"governance/cncf/gtr/#security","title":"Security","text":""},{"location":"governance/cncf/gtr/#cncf-security-self-assessment","title":"CNCF Security self-assessment","text":"<p>See separate document.</p>"},{"location":"governance/cncf/gtr/#security-hygiene","title":"Security hygiene","text":""},{"location":"governance/cncf/gtr/#code-quality-and-development-practices","title":"Code Quality and Development Practices","text":"<ul> <li>Version Control and Workflow:<ul> <li>All development is managed through Git and a structured branching strategy.</li> <li>Pull Requests (PRs) are mandatory for all changes, requiring reviews and approval by maintainers before merging.</li> </ul> </li> <li>Code Reviews:<ul> <li>Every PR undergoes peer review to ensure adherence to coding standards and to identify potential issues early.</li> </ul> </li> <li>Automated Testing:<ul> <li>Unit Tests: Validate individual components for functionality and correctness.</li> <li>End-to-End (E2E) Tests: Assess cluster-level behaviors and workflows under real-world scenarios.</li> <li>Conformance Tests: Ensure alignment with upstream Kubernetes standards.</li> </ul> </li> <li>Continuous Integration/Continuous Deployment (CI/CD):<ul> <li>CI pipelines run automated tests, perform builds, and validate compatibility before code is merged.<ul> <li>All CI is built on GitHub actions with declarative and open models</li> </ul> </li> </ul> </li> </ul>"},{"location":"governance/cncf/gtr/#security-practices","title":"Security Practices","text":"<ul> <li>Dependency Management:<ul> <li>Dependabot is used to automate security updates for vulnerable libraries.</li> <li>System Images shipped with k0s are regurarly scanned by Trivy.</li> </ul> </li> <li>Signed Binaries:<ul> <li>All k0s binaries are signed using Cosign as part of the release process to prevent tampering.</li> <li>Documentation has instructions for users on how to verify the signature</li> </ul> </li> <li>Secure Default Configurations:<ul> <li>k0s ships with secure-by-default settings, such as TLS encryption for API communication and RBAC enabled by default.</li> </ul> </li> <li>Vulnerability Response:<ul> <li>A defined process for responding to discovered vulnerabilities, including prompt patching and communication with users.   See k0s security policy for more information.</li> </ul> </li> </ul>"},{"location":"governance/cncf/gtr/#community-and-governance","title":"Community and Governance","text":"<ul> <li>Community Involvement:<ul> <li>Security and health are bolstered by a transparent development process that invites contributions from the community.</li> <li>Security issues can be reported confidentially to maintainers via a designated vulnerability disclosure program.</li> </ul> </li> <li>Governance Model:<ul> <li>Decisions about features, security, and releases are guided by a structured governance framework involving maintainers and key contributors.</li> </ul> </li> <li>Documentation Standards:<ul> <li>Comprehensive and updated documentation ensures users follow best practices, reducing misconfigurations and security risks.</li> </ul> </li> </ul>"},{"location":"governance/cncf/gtr/#release-management","title":"Release Management","text":"<ul> <li>Semantic Versioning:<ul> <li>Releases follow semantic versioning to provide clarity on the nature of changes (major, minor, or patch).</li> </ul> </li> <li>Testing Before Release:<ul> <li>Each release undergoes rigorous automated testing to ensure stability and security.</li> </ul> </li> <li>Timely Security Patches:<ul> <li>Critical vulnerabilities are addressed through prompt patch releases , given that an upstream fix is available.</li> </ul> </li> <li>Signed Binaries:<ul> <li>k0s binaries are signed with Cosign, ensuring artifact integrity and authenticity.</li> </ul> </li> <li>Release Notes:<ul> <li>Detailed notes accompany each release, highlighting new features, bug fixes, and security updates.</li> </ul> </li> </ul>"},{"location":"governance/cncf/gtr/#compliance-with-cncf-best-practices","title":"Compliance with CNCF Best Practices","text":"<ul> <li>Kubernetes Conformance:<ul> <li>Regular conformance testing ensures compatibility with upstream Kubernetes APIs.</li> </ul> </li> <li>TAG Security Alignment:<ul> <li>Security practices align with CNCF TAG Security recommendations, providing a robust baseline for health and security.</li> </ul> </li> </ul>"},{"location":"governance/cncf/gtr/#supply-chain-security","title":"Supply Chain Security","text":"<ul> <li>Source Code Integrity:<ul> <li>Code hosted on trusted platform on GitHub.</li> <li>Git used as version control and all changes going through pull request process to ensure integrity.</li> </ul> </li> <li>Build Pipeline Security:<ul> <li>All build pipelines are managed as code using GitHub Actions workflows in the k0s git repository.</li> <li>All changes are going through normal review process.</li> <li>Non-maintainer PRs require approval to run the CI workflows allowing a maintainer to verify the PR before allowing it to run.</li> </ul> </li> <li>Dependency Transparency:<ul> <li>The project maintains transparency about its dependencies and their versions.</li> <li>Automated dependency updates are handled by Dependabot and Renovate Bot.</li> <li>A signed SBOM report, in SPDX format, is produced for all releases.</li> </ul> </li> </ul>"},{"location":"governance/cncf/security-self-assessment/","title":"TAG-Security self-assessment","text":""},{"location":"governance/cncf/security-self-assessment/#cncf-tag-security-self-assessment","title":"CNCF TAG-Security self-assessment","text":"<p>This document serves as the k0s project CNCF TAG-Security self-assessment.</p>"},{"location":"governance/cncf/security-self-assessment/#metadata","title":"Metadata","text":"Assessment Stage Draft Software https://github.com/k0sproject/k0s Security Provider No Languages Golang SBOM https://github.com/k0sproject/k0s/releases/download/v1.34.1%2Bhead/spdx.json"},{"location":"governance/cncf/security-self-assessment/#security-links","title":"Security links","text":"Doc URL Security file https://github.com/k0sproject/k0s/blob/main/SECURITY.md"},{"location":"governance/cncf/security-self-assessment/#project-overview","title":"Project Overview","text":"<p>Description:</p> <ul> <li>k0s is a lightweight, open-source Kubernetes distribution designed to simplify cluster setup and management. It offers an all-inclusive binary for streamlined operations with minimal dependencies.</li> </ul> <p>Key Use Cases:</p> <ul> <li>Simplifying Kubernetes deployment for edge and production environments.</li> <li>Managing distributed workloads at scale with reduced operational overhead.</li> </ul> <p>Security Goals:</p> <ul> <li>Secure defaults for deployment and operation.</li> <li>Flexibility for various deployment scenarios while adhering to Kubernetes security best practices.</li> </ul>"},{"location":"governance/cncf/security-self-assessment/#background","title":"Background","text":""},{"location":"governance/cncf/security-self-assessment/#actors","title":"Actors","text":""},{"location":"governance/cncf/security-self-assessment/#control-plane","title":"Control Plane","text":"<ul> <li>Components: API Server, Scheduler, Controller Manager.</li> <li>Role: Centralized management of the Kubernetes cluster, handling scheduling, API requests, and resource management.</li> <li>Security Mechanisms:<ul> <li>Mutual TLS is used to secure communication between control plane components.</li> <li>Anonymous access is disabled by default.</li> <li>Role-Based Access Control (RBAC) ensures that only authorized users or processes can interact with the API Server.<ul> <li>K0s creates minimal RBAC for the system components it manages</li> </ul> </li> <li>Control plane nodes can be physically or logically separated from worker nodes to reduce exposure to potential compromise.<ul> <li>This is achieved with konnectivity and is enabled by default.</li> </ul> </li> <li>K0s creates and manages the CA and other needed certificates<ul> <li>Serving and client certs are rotated on each k0s restart<sup>1</sup></li> </ul> </li> </ul> </li> </ul>"},{"location":"governance/cncf/security-self-assessment/#data-store-etcd","title":"Data Store (etcd)","text":"<ul> <li>Components: Distributed key-value store for cluster state and secrets.</li> <li>Role: Maintains the state of the cluster, including configuration and sensitive data such as secrets.</li> <li>Security Mechanisms:<ul> <li>Etcd API is only exposed on localhost on controller nodes</li> <li>Access to etcd is restricted to authenticated and authorized control plane components and secured with mutual TLS</li> </ul> </li> </ul>"},{"location":"governance/cncf/security-self-assessment/#worker-nodes","title":"Worker Nodes","text":"<ul> <li>Components: Kubelet, kube-proxy, and container runtimes.</li> <li>Role: Execute workloads and interact with the control plane for orchestration.</li> <li>Security Mechanisms:<ul> <li>Worker nodes can be isolated from each other through network policies, preventing direct communication between pods unless explicitly allowed.</li> <li>Pod Security Standards (optional) enforce restrictions on workload capabilities, reducing the risk of lateral movement in case of a compromise.</li> <li>Kubelet APIs are configured with authentication.</li> <li>Kubelet is configured with certificate rotation.</li> <li>Worker nodes are joined using revocable bootstrap tokens which can be configured to be short-living too.</li> </ul> </li> </ul>"},{"location":"governance/cncf/security-self-assessment/#networking-layer","title":"Networking Layer","text":"<ul> <li>Components: Cluster networking via CNI plugins, kube-proxy, or Calico</li> <li>Role: Facilitate communication between pods, services, and external systems.</li> <li>Security Mechanisms:<ul> <li>Network segmentation and policy enforcement restrict traffic between pods, nodes, and external endpoints.</li> </ul> </li> </ul>"},{"location":"governance/cncf/security-self-assessment/#goals","title":"Goals","text":"<p>Security goals for k0s can be summarized as follows:</p>"},{"location":"governance/cncf/security-self-assessment/#secure-by-default-configurations","title":"Secure-by-default configurations","text":"<p>K0s in its default configuration should provide a secure base-level configuration. That includes things like no anonymous authentication, TLS enabled everywhere, RBAC, etc. While that does NOT include integrations with things like AppArmor and seccomp, those configurations are exposed to users. In general, k0s allows users to fine-tune pretty much any and all Kubernetes options.</p>"},{"location":"governance/cncf/security-self-assessment/#minimized-operational-complexity","title":"Minimized operational complexity","text":"<p>By minimizing the operational complexity for Kubernetes the users have better and more easy control of their security configurations.</p>"},{"location":"governance/cncf/security-self-assessment/#compatibility-with-kubernetes-security-best-practices","title":"Compatibility with Kubernetes security best practices","text":"<p>k0s adheres to the established security frameworks and guidelines provided by Kubernetes, such as RBAC, network policies, and encryption mechanisms. This ensures that organizations can seamlessly integrate k0s into their existing Kubernetes environments without compromising security standards.</p>"},{"location":"governance/cncf/security-self-assessment/#self-assessment-use","title":"Self-assessment use","text":"<p>This document evaluates the security posture of k0s, identifies existing measures, and highlights areas for improvement. It serves as a reference for stakeholders and to advance k0s at the CNCF Sandbox level.</p>"},{"location":"governance/cncf/security-self-assessment/#project-compliance","title":"Project compliance","text":"<p>k0s follows the CIS Kubernetes Benchmark with documented exceptions.</p>"},{"location":"governance/cncf/security-self-assessment/#secure-development-practices","title":"Secure development practices","text":""},{"location":"governance/cncf/security-self-assessment/#development-pipeline","title":"Development pipeline","text":"<p>Code Reviews: All changes undergo peer review by project maintainers.</p> <p>Dependency Management: Regular automated vulnerability scanning and updates of dependencies</p> <p>CI/CD Security: Security checks integrated into CI/CD pipelines. For non-maintainer pull requests, we require approval to run CI which allows us to verify</p> <p>Signed-off commits: All commits are required to be signed-off.</p>"},{"location":"governance/cncf/security-self-assessment/#communication-channels","title":"Communication channels","text":"<p>Internal: Internal, between maintainers, communication is handled mostly in Kubernetes Slack #k0s-dev channel, and in Mirantis internal channels for Mirantis core maintainers.</p> <p>Inbound: #k0s-users in Kubernetes Slack and GitHub issues. Stack Overflow has also a k0s tag for related questions.</p> <p>External: k0s does not currently have any mailing lists. There are Mirantis-operated social media accounts that are used for communicating things like new releases etc. There\u2019s also a community blog which is backed by a GitHub repository.</p>"},{"location":"governance/cncf/security-self-assessment/#security-issue-resolution","title":"Security issue resolution","text":""},{"location":"governance/cncf/security-self-assessment/#issue-reporting","title":"Issue Reporting","text":"<p>Vulnerabilities can be reported via the k0s GitHub project using GitHub's private security vulnerability reporting feature.</p>"},{"location":"governance/cncf/security-self-assessment/#incident-response","title":"Incident Response","text":"<p>The k0s maintainers triage and resolve issues. Security patches and advisories are published as needed.</p>"},{"location":"governance/cncf/security-self-assessment/#appendix","title":"Appendix","text":""},{"location":"governance/cncf/security-self-assessment/#case-studies","title":"Case studies","text":"<p>List of known users along with some case studies.</p> <ol> <li> <p>The serving and client certs are valid for 1 year per default. Hence upgrading, and thus restarting k0s, at least once a year will rotate the certs automatically.\u00a0\u21a9</p> </li> </ol>"},{"location":"troubleshooting/FAQ/","title":"FAQ","text":""},{"location":"troubleshooting/FAQ/#frequently-asked-questions","title":"Frequently asked questions","text":""},{"location":"troubleshooting/FAQ/#how-is-k0s-pronounced","title":"How is k0s pronounced?","text":"<p>kay-zero-ess</p>"},{"location":"troubleshooting/FAQ/#how-do-i-run-a-single-node-cluster","title":"How do I run a single node cluster?","text":"<p>The cluster can be started with:</p> <pre><code>k0s controller --single\n</code></pre> <p>See also the Getting Started tutorial.</p>"},{"location":"troubleshooting/FAQ/#how-do-i-connect-to-the-cluster","title":"How do I connect to the cluster?","text":"<p>You find the config in <code>${DATADIR}/pki/admin.conf</code> (default: <code>/var/lib/k0s/pki/admin.conf</code>). Copy this file, and change the <code>localhost</code> entry to the public IP address of the controller. Use the modified config to connect with kubectl:</p> <pre><code>export KUBECONFIG=/path/to/admin.conf\nkubectl ...\n</code></pre>"},{"location":"troubleshooting/FAQ/#why-doesnt-kubectl-get-nodes-list-the-k0s-controllers","title":"Why doesn't <code>kubectl get nodes</code> list the k0s controllers?","text":"<p>As a default, the control plane does not run kubelet at all, and will not accept any workloads, so the controller will not show up on the node list in kubectl. If you want your controller to accept workloads and run pods, you do so with: <code>k0s controller --enable-worker</code> (recommended only as test/dev/POC environments).</p>"},{"location":"troubleshooting/FAQ/#is-k0s-really-open-source","title":"Is k0s really open source?","text":"<p>Yes, k0s is 100% open source. The source code is licensed under the Apache 2.0 License, and the documentation under a Creative Commons License. The project is part of the CNCF Sandbox. While Mirantis, Inc. remains a principal contributor and sponsor, k0s adheres to CNCF's open governance and IP policies to ensure transparency and community-driven development under a vendor-neutral umbrella.</p>"},{"location":"troubleshooting/FAQ/#a-kubeconfig-created-via-k0s-kubeconfig-has-been-leaked-what-can-i-do","title":"A kubeconfig created via <code>k0s kubeconfig</code> has been leaked, what can I do?","text":"<p>Kubernetes does not support certificate revocation (see k/k/18982). This means that you cannot disable the leaked credentials. The only way to effectively revoke them is to replace the Kubernetes CA for your cluster.</p>"},{"location":"troubleshooting/certificate-authorities/","title":"Certificate Authorities (CAs)","text":""},{"location":"troubleshooting/certificate-authorities/#certificate-authorities-cas","title":"Certificate Authorities (CAs)","text":""},{"location":"troubleshooting/certificate-authorities/#overview-of-cas-managed-by-k0s","title":"Overview of CAs managed by k0s","text":"<p>k0s maintains two Certificate Authorities and one public/private key pair:</p> <ul> <li>The Kubernetes CA is used to secure the Kubernetes cluster and manage   client and server certificates for API communication.</li> <li>The etcd CA is used only when managed etcd is enabled, for securing etcd   communications.</li> <li>The Kubernetes Service Account (SA) key pair is used for signing   Kubernetes service account tokens.</li> </ul> <p>These CAs are automatically created during cluster initialization and have a default expiration period of 10 years. They are distributed once to all k0s controllers as part of k0s's join process. Replacing them is a manual process, as k0s currently lacks automation for CA renewal.</p>"},{"location":"troubleshooting/certificate-authorities/#replacing-the-kubernetes-ca-and-sa-key-pair","title":"Replacing the Kubernetes CA and SA key pair","text":"<p>The following steps describe a way how to manually replace the Kubernetes CA and SA key pair by taking a cluster down, regenerating those and redistributing them to all nodes, and then bringing the cluster back online:</p> <ol> <li> <p>Take a backup! Things might go wrong at any level.</p> </li> <li> <p>Stop k0s on all worker and controller nodes. All the instructions below    assume that all k0s nodes are using the default data directory    <code>/var/lib/k0s</code>. Adjust the path accordingly if a different data directory is    used.</p> </li> <li> <p>Delete the Kubernetes CA and SA key pair files from the all the controller    data directories:</p> <ul> <li><code>/var/lib/k0s/pki/ca.crt</code></li> <li><code>/var/lib/k0s/pki/ca.key</code></li> <li><code>/var/lib/k0s/pki/sa.pub</code></li> <li><code>/var/lib/k0s/pki/sa.key</code></li> </ul> <p>Delete the kubelet's kubeconfig file and the kubelet's PKI directory from all  worker data directories. Note that this includes controllers that have been  started with the <code>--enable-worker</code> flag:</p> <ul> <li><code>/var/lib/k0s/kubelet.conf</code></li> <li><code>/var/lib/k0s/kubelet/pki</code></li> </ul> </li> <li> <p>Choose one controller as the \"first\" one. Restart k0s on the first    controller. If this controller is running with the <code>--enable-worker</code> flag,    reboot the machine instead. This ensures that all processes and pods will    be cleanly restarted. After the restart, k0s will have regenerated a new    Kubernetes CA and SA key pair.</p> </li> <li> <p>Distribute the new CA and SA key pair to the other controllers: Copy over the    following files from the first controller to each of the remaining    controllers:</p> <ul> <li><code>/var/lib/k0s/pki/ca.crt</code></li> <li><code>/var/lib/k0s/pki/ca.key</code></li> <li><code>/var/lib/k0s/pki/sa.pub</code></li> <li><code>/var/lib/k0s/pki/sa.key</code></li> </ul> <p>After copying the files, the new CA and SA key pair are in place. Restart k0s  on the other controllers. For controllers running with the <code>--enable-worker</code>  flag, reboot the machines instead.</p> </li> <li> <p>Rejoin all workers. The easiest way to do this is to use a    <code>kubelet-bootstrap.conf</code> file. You can generate    such a file on a controller like this (see the section on join tokens for    details):</p> <pre><code>touch /tmp/rejoin-token &amp;&amp;\n  chmod 0600 /tmp/rejoin-token &amp;&amp;\n  k0s token create --expiry 1h |\n  base64 -d |\n  gunzip &gt;/tmp/rejoin-token\n</code></pre> <p>Copy that token to each worker node and place it at  <code>/var/lib/k0s/kubelet-bootstrap.conf</code>. Then reboot the machine.</p> </li> <li> <p>When all worker nodes are back online, the <code>kubelet-bootstrap.conf</code> files can    be safely removed from the worker nodes. The token can be invalidated without    waiting for its expiration: Use <code>k0s token list --role    worker</code> to list all tokens and <code>k0s token    invalidate &lt;token-id&gt;</code> to invalidate them    immediately.</p> </li> </ol>"},{"location":"troubleshooting/certificate-authorities/#see-also","title":"See also","text":"<ul> <li>Install using custom CAs</li> </ul>"},{"location":"troubleshooting/logs/","title":"Logs","text":""},{"location":"troubleshooting/logs/#logs","title":"Logs","text":"<p>k0s runs most of the Kubernetes and other system components as plain Linux child processes. As it acts as a watchdog for the child processes it also combines the logs for all such processes into its own log stream.</p> <p>k0s adds a \"selector\" to each components log stream so it is easier to distinguish logs from various components. For example the log stream from kubelet is enhanced with a selector <code>component=kubelet</code>:</p> <pre><code>Jul 08 08:46:25 worker-kppzr-lls2q k0s[1766]: time=\"2024-07-08 08:46:25\" level=info msg=\"I0708 08:46:25.876821    1814 operation_generator.go:721] \\\"MountVolume.SetUp succeeded for volume \\\\\\\"kube-api-access-7tfxw\\\\\\\" (UniqueName: \\\\\\\"kubernetes.io/projected/ca514728-a1de-4408-9be5-8b36ee896752-kube-api-access-7tfxw\\\\\\\") pod \\\\\\\"node-shell-a16894ee-eb67-4865-8964-44ca5c87e18d\\\\\\\" (UID: \\\\\\\"ca514728-a1de-4408-9be5-8b36ee896752\\\\\\\") \\\" pod=\\\"kube-system/node-shell-a16894ee-eb67-4865-8964-44ca5c87e18d\\\"\" component=kubelet stream=stderr\nJul 08 08:46:26 worker-kppzr-lls2q k0s[1766]: time=\"2024-07-08 08:46:26\" level=info msg=\"I0708 08:46:26.112550    1814 kuberuntime_container_linux.go:167] \\\"No swap cgroup controller present\\\" swapBehavior=\\\"\\\" pod=\\\"kube-system/node-shell-a16894ee-eb67-4865-8964-44ca5c87e18d\\\" containerName=\\\"shell\\\"\" component=kubelet stream=stderr\n</code></pre>"},{"location":"troubleshooting/logs/#where-are-the-logs","title":"Where are the logs?","text":""},{"location":"troubleshooting/logs/#systemd-based-setups","title":"systemd based setups","text":"<p>systemd stores logs in its journal. Access k0s and all component logs using <code>journalctl</code>. For example, to view kubelet logs, run <code>journalctl -u k0sworker | grep component=kubelet</code>.</p>"},{"location":"troubleshooting/logs/#openrc-based-setups","title":"OpenRC based setups","text":"<p>openRC stores service logs in <code>/var/log/k0sworker.log</code>. To view a specific component log, run <code>grep component=kubelet /var/log/k0s.log</code>.</p>"},{"location":"troubleshooting/support-dump/","title":"Support Insights","text":""},{"location":"troubleshooting/support-dump/#support-insight","title":"Support Insight","text":"<p>In many cases, especially when looking for commercial support, there's a need to share the cluster state with others. While one could always grant access to the live cluster, this is not always desirable or possible. For these situations, use the work provided by Troubleshoot.</p> <p>The Troubleshoot tool can produce a dump of the cluster state for sharing. The [<code>sbctl</code>] tool can expose the dump tarball as a Kubernetes API.</p> <p>The following example shows how this works with k0s.</p>"},{"location":"troubleshooting/support-dump/#setting-up","title":"Setting up","text":"<p>To gather all the needed data, install another tool called [<code>support-bundle</code>]. Download it from the Troubleshoot releases page. Make sure to select the executable for the correct architecture.</p>"},{"location":"troubleshooting/support-dump/#creating-support-bundle","title":"Creating support bundle","text":"<p>A Support Bundle needs to know what to collect and optionally, what to analyze. This is defined in a YAML file.</p> <p>While data collection can be customized to meet specific needs, the following reference configuration for k0s covers core elements such as:</p> <ul> <li>collecting info on the host</li> <li>collecting system component statuses from <code>kube-system</code> namespace</li> <li>checking health of Kubernetes API, Etcd etc. components</li> <li>collecting k0s logs</li> <li>checking status of firewalls, anti-virus etc. services which are known to interfere with Kubernetes</li> </ul> <p>Because host-level information is required, the commands must be run directly on the k0s nodes.</p> <p>After setting up the tooling, run the following command to generate a support bundle:</p> <pre><code>support-bundle --kubeconfig /var/lib/k0s/pki/admin.conf https://docs.k0sproject.io/stable/support-bundle-&lt;role&gt;.yaml\n</code></pre> <p>Above <code>&lt;role&gt;</code> refers to either <code>controller</code> or <code>worker</code>. Different roles require different information. When running a controller with <code>--enable-worker</code> or <code>--single</code>, which also makes it a worker, capture a combined dump:</p> <pre><code>support-bundle --kubeconfig /var/lib/k0s/pki/admin.conf https://docs.k0sproject.io/stable/support-bundle-controller.yaml https://docs.k0sproject.io/stable/support-bundle-worker.yaml\n</code></pre> <p>Once the data has been collected, a file named <code>support-bundle-&lt;timestamp&gt;.tar.gz</code> will be created. Share this file as needed.</p>"},{"location":"troubleshooting/troubleshooting/","title":"Common Pitfalls","text":""},{"location":"troubleshooting/troubleshooting/#common-pitfalls","title":"Common Pitfalls","text":"<p>There are few common cases we've seen where k0s fails to run properly.</p>"},{"location":"troubleshooting/troubleshooting/#coredns-in-crash-loop","title":"CoreDNS in crash-loop","text":"<p>The most common case we've encountered so far has been CoreDNS getting into crash-loop on the node(s).</p> <p>With kubectl you see something like this:</p> <pre><code>$ kubectl get pod --all-namespaces\nNAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE\nkube-system   calico-kube-controllers-5f6546844f-25px6   1/1     Running   0          167m\nkube-system   calico-node-fwjx5                          1/1     Running   0          164m\nkube-system   calico-node-t4tx5                          1/1     Running   0          164m\nkube-system   calico-node-whwsg                          1/1     Running   0          164m\nkube-system   coredns-5c98d7d4d8-tfs4q                   1/1     Error     17         167m\nkube-system   konnectivity-agent-9jkfd                   1/1     Running   0          164m\nkube-system   konnectivity-agent-bvhdb                   1/1     Running   0          164m\nkube-system   konnectivity-agent-r6mzj                   1/1     Running   0          164m\nkube-system   kube-proxy-kr2r9                           1/1     Running   0          164m\nkube-system   kube-proxy-tbljr                           1/1     Running   0          164m\nkube-system   kube-proxy-xbw7p                           1/1     Running   0          164m\nkube-system   metrics-server-7d4bcb75dd-pqkrs            1/1     Running   0          167m\n</code></pre> <p>When you check the logs, it'll show something like this:</p> <pre><code>kubectl -n kube-system logs coredns-5c98d7d4d8-tfs4q\n</code></pre> <pre><code>plugin/loop: Loop (127.0.0.1:55953 -&gt; :1053) detected for zone \".\", see https://coredns.io/plugins/loop#troubleshooting. Query: \"HINFO 4547991504243258144.3688648895315093531.\"\n</code></pre> <p>This is most often caused by systemd-resolved stub (or something similar) running locally and CoreDNS detects a possible loop with DNS queries.</p> <p>The easiest but most crude way to workaround is to disable the systemd-resolved stub and revert the hosts <code>/etc/resolv.conf</code> to original</p> <p>Read more at CoreDNS troubleshooting docs.</p>"},{"location":"troubleshooting/troubleshooting/#k0s-controller-fails-on-arm-boxes","title":"<code>k0s controller</code> fails on ARM boxes","text":"<p>In the logs you probably see etcd not starting up properly.</p> <p>Etcd is not fully supported on ARM architecture, thus you need to run <code>k0s controller</code> and thus also etcd process with the environment variable <code>ETCD_UNSUPPORTED_ARCH=arm</code>.</p> <p>As etcd is not fully supported on ARM, it also means that the k0s control plane with etcd itself is not fully supported on ARM either.</p>"},{"location":"troubleshooting/troubleshooting/#k0s-will-not-start-on-zfs-based-systems","title":"<code>k0s</code> will not start on ZFS-based systems","text":"<p>On ZFS-based systems k0s will fail to start because containerd runs by default in overlayfs mode to manage image layers. This is not compatible with ZFS and requires a custom config of containerd. The following steps should get k0s working on ZFS-based systems:</p> <ul> <li>check with <code>$ ctr -a /run/k0s/containerd.sock plugins ls</code> that the containerd ZFS snapshotter plugin is in <code>ok</code> state (should be the case if ZFS kernel modules and ZFS userspace utils are correctly configured):</li> </ul> <pre><code>TYPE                            ID                       PLATFORMS      STATUS    \n...\nio.containerd.snapshotter.v1    zfs                      linux/amd64    ok\n...\n</code></pre> <ul> <li>create a containerd config according to the documentation: <code>$ containerd config default &gt; /etc/k0s/containerd.toml</code></li> <li>modify the line in <code>/etc/k0s/containerd.toml</code>:</li> </ul> <pre><code>...\n    [plugins.\"io.containerd.grpc.v1.cri\".containerd]\n      snapshotter = \"overlayfs\"\n...\n</code></pre> <p>to</p> <pre><code>...\n    [plugins.\"io.containerd.grpc.v1.cri\".containerd]\n      snapshotter = \"zfs\"\n...\n</code></pre> <ul> <li>create a ZFS dataset to be used as snapshot storage at your desired location, e.g. <code>$ zfs create -o mountpoint=/var/lib/k0s/containerd/io.containerd.snapshotter.v1.zfs rpool/containerd</code></li> <li>install k0s as usual, e.g <code>$ k0s install controller --single -c /etc/k0s/k0s.yaml</code></li> <li>containerd should be launched with ZFS support and k0s should initialize the cluster correctly</li> </ul>"},{"location":"troubleshooting/troubleshooting/#pods-pending-when-using-cloud-providers","title":"Pods pending when using cloud providers","text":"<p>Once we enable cloud provider support on kubelet on worker nodes, kubelet will automatically add a taint <code>node.cloudprovider.kubernetes.io/uninitialized</code> for the node. This taint will prevent normal workloads to be scheduled on the node until the cloud provider controller actually runs second initialization on the node and removes the taint. This means that these nodes are not available for scheduling until the cloud provider controller is actually successfully running on the cluster.</p> <p>For troubleshooting your specific cloud provider see its documentation.</p>"},{"location":"troubleshooting/troubleshooting/#k0s-not-working-with-read-only-usr","title":"k0s not working with read only <code>/usr</code>","text":"<p>By default k0s does not run on nodes where <code>/usr</code> is read only.</p> <p>This can be fixed by changing the default path for <code>volumePluginDir</code> in your k0s config. You will need to change to values, one for the kubelet itself, and one for Calico.</p> <p>Here is a snippet of an example config with the default values changed:</p> <pre><code>spec:\n  controllerManager:\n    extraArgs:\n      flex-volume-plugin-dir: \"/etc/kubernetes/kubelet-plugins/volume/exec\"\n  network:\n    calico:\n      flexVolumeDriverPath: /etc/k0s/kubelet-plugins/volume/exec/nodeagent~uds\n  workerProfiles:\n    - name: coreos\n      values:\n        volumePluginDir: /etc/k0s/kubelet-plugins/volume/exec/\n</code></pre> <p>With this config you can start your controller as usual. Any workers will need to be started with</p> <pre><code>k0s worker --profile coreos [TOKEN]\n</code></pre>"},{"location":"troubleshooting/troubleshooting/#iptables-version-mismatch","title":"iptables version mismatch","text":"<p>If the running kernel has firewall rules created using an iptables version newer than the version shipped with k0s, the Kubernetes network will not work.</p> <p>To solve this, make sure that the iptables version used on host is same version as bundled with k0s. The k0s version is found in <code>/var/lib/k0s/bin</code>.</p>"},{"location":"troubleshooting/troubleshooting/#profiling","title":"Profiling","text":"<p>We drop any debug related information and symbols from the compiled binary by utilizing <code>-w -s</code> linker flags.</p> <p>To keep those symbols use <code>DEBUG</code> environment variable:</p> <pre><code>DEBUG=true make k0s\n</code></pre> <p>Any value not equal to the \"false\" would work.</p> <p>To add custom linker flags use <code>LDFLAGS</code> variable.</p> <pre><code>LD_FLAGS=\"--custom-flag=value\" make k0s\n</code></pre>"},{"location":"troubleshooting/troubleshooting/#using-a-custom-container-runtime-and-missing-labels-in-prometheus-metrics","title":"Using a custom container runtime and missing labels in Prometheus metrics","text":"<p>With Kubernetes' shift to CRI, Kubelet's method of obtaining container metrics through its embedded cAdvisor no longer works as it used to. This process doesn't go via CRI but directly interacts with the container runtime, which is only natively supported for containerd. K0s automatically manages this for its built-in containerd runtime. For custom containerd runtimes, you can use the flag <code>--kubelet-extra-flags=--containerd=/path/to/containerd.sock</code> when starting k0s.</p> <p>However, this solution is not applicable to other runtimes such as Docker when used via the cri-dockerd shim, and there is currently no easy fix. Kubelet is expected to be refactored in the future to gather container metrics from CRI instead, as specified in KEP-2371. For now, running a standalone cAdvisor, as explained in Kubernetes' known issues section, is a recommended workaround.</p>"},{"location":"troubleshooting/troubleshooting/#customized-configurations","title":"Customized configurations","text":"<ul> <li>All data directories reside under <code>/var/lib/k0s</code>, for example:<ul> <li><code>/var/lib/k0s/kubelet</code></li> <li><code>/var/lib/k0s/etcd</code></li> </ul> </li> </ul>"}]}